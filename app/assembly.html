<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script async src="{{{appclient}}}"></script>
    <link rel="stylesheet" type="text/css" href="styles/style.css" />
    <link rel="stylesheet" type="text/css" href="styles/modal.css" />
    <link rel="stylesheet" type="text/css" href="styles/filepreview.css" />
    <link rel="stylesheet" type="text/css" href="styles/desc_preview.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

    <!-- Add Quill CSS and JS -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
</head>

<body>
    <div class="tracker-form-container">
        <!-- Add Debug Button at the top -->
        <div class="debug-container">
            <button id="debugFillForm" class="debug-button">Fill Form with Demo Data</button>
        </div>
        <div class="form-title">
            <h2>Assembly</h2>
            <div class="form-title-underline"></div>
        </div>
        <form id="trackerForm">
            <!-- Auto-generated subject field -->
            <div class="form-group">
                <h3>Subject</h3>
                <input type="text" id="subject" name="subject" required>
                <div class="hint">Auto-generated based on ticket details and application</div>
            </div>

            <!-- New application field that will be used for subject generation -->
            <div class="form-group">
                <label for="application">Application*:</label>
                <input type="text" id="application" name="application" required placeholder="e.g. Bookshelves">
                <div class="hint">The application or system related to this issue</div>
            </div>

            <!-- Specific issue field that will be used for subject generation -->
            <div class="form-group">
                <label for="specificIssue">Specific Issue*:</label>
                <input type="text" id="specificIssue" name="specificIssue" required
                    placeholder="e.g. School Customization Folder Missing">
                <div class="hint">Brief description of the specific issue</div>
            </div>

            <!-- Summary field -->
            <div class="form-group">
                <h3>Summary</h3>
                <div id="issueSummaryEditor" style="height: 100px; background-color: white;"></div>
                <textarea id="issueSummary" name="issueSummary" style="display: none;"></textarea>
                <div class="hint">Brief summary of the issue</div>
            </div>

            <!-- Separator for description fields -->
            <h3>Description</h3>
            <div class="form-section-divider">
                <div class="hint">These fields will be used to generate the description</div>
            </div>



            <!-- Description details fields -->
            <div class="form-group">
                <label for="reportedIssueEditor">Reported Issue*:</label>
                <div id="reportedIssueEditor" style="height: 150px; background-color: white;"></div>
                <textarea id="reportedIssue" name="reportedIssue" style="display: none;"></textarea>
            </div>

            <div class="form-group">
                <label for="userInfo">User Name and Email/Role:</label>
                <input type="text" id="userInfo" name="userInfo" placeholder="e.g. John Doe, john@school.edu, Teacher">
            </div>

            <!-- Replace Product/Program Impacted field with a dropdown -->
            <div class="form-group">
                <label for="productImpacted">Product/Program Impacted:</label>
                <select id="productImpacted" name="productImpacted">
                    <!-- Options will be loaded from the custom field cf_product_type -->
                </select>
                <div class="hint">Select the product type</div>
            </div>

            <div class="form-group">
                <label for="xcodeInfo">Xcode:</label>
                <input type="text" id="xcodeInfo" name="xcodeInfo">
            </div>

            <div class="form-group">
                <label for="districtState">District State:</label>
                <input type="text" id="districtState" name="districtState">
            </div>

            <div class="form-group">
                <label for="impactType">Digital Only or Print Impacted as Well:</label>
                <select id="impactType" name="impactType">
                    <option value="">-- Select --</option>
                    <option value="Digital Only">Digital Only</option>
                    <option value="Print Only">Print Only</option>
                    <option value="Both Digital and Print">Both Digital and Print</option>
                </select>
            </div>

            <div class="form-group">
                <label for="dateReported">Date issue reported by user:</label>
                <input type="date" id="dateReported" name="dateReported">
            </div>

            <div class="form-group">
                <label for="impactScope">Teacher vs Student impact:</label>
                <select id="impactScope" name="impactScope">
                    <option value="">-- Select --</option>
                    <option value="Teacher Only">Teacher Only</option>
                    <option value="Student Only">Student Only</option>
                    <option value="Both Teacher and Student">Both Teacher and Student</option>
                    <option value="Unknown">Unknown</option>
                </select>
            </div>

            <div class="form-group">
                <label for="components">Components:</label>
                <input type="text" id="components" name="components"
                    placeholder="e.g. Assessment, Assignments, ePlanner">
                <div class="hint">Specific application or component affected</div>
            </div>

            <div class="form-group">
                <label for="stepsToReproduceEditor">Steps To Reproduce:</label>
                <div id="stepsToReproduceEditor" style="height: 100px; background-color: white;"></div>
                <textarea id="stepsToReproduce" name="stepsToReproduce" style="display: none;"></textarea>
            </div>

            <div class="form-group">
                <label for="actualResultsEditor">Actual Results:</label>
                <div id="actualResultsEditor" style="height: 100px; background-color: white;"></div>
                <textarea id="actualResults" name="actualResults" style="display: none;"></textarea>
            </div>

            <div class="form-group">
                <label for="expectedResultsEditor">Expected Results:</label>
                <div id="expectedResultsEditor" style="height: 100px; background-color: white;"></div>
                <textarea id="expectedResults" name="expectedResults" style="display: none;"></textarea>
            </div>

            <!-- Preview button for description -->
            <div class="form-group">
                <fw-button id="previewDescription" color="secondary" size="small">Preview Description</fw-button>
                <div class="hint">Click to see how the description will appear</div>
            </div>

            <!-- Hidden field for the generated description -->
            <div class="form-group" style="display: none;">
                <textarea id="description" name="description"></textarea>
            </div>

            <!-- Email field with dropdown if both emails are available -->
            <div class="form-group">
                <label for="email">Requester Email*:</label>
                <div class="email-selection">
                    <input type="email" id="email" name="email" required>
                    <div class="hint">This ticket will be created by you (the logged-in agent)</div>
                    <div id="emailStatus" class="email-status"></div>
                </div>
            </div>

            <div class="form-group">
                <label for="relatedTickets">Related Ticket IDs*:</label>
                <input type="text" id="relatedTickets" name="relatedTickets" required>
                <div class="hint">Comma-separated ticket IDs (e.g., 1,2,3)</div>
            </div>

            <div class="form-group">
                <label for="priority">Priority:</label>
                <select id="priority" name="priority">
                    <option value="1">Low</option>
                    <option value="2">Medium</option>
                    <option value="3">High</option>
                    <option value="4">Urgent</option>
                </select>
            </div>

            <div class="form-group">
                <label for="status">Status:</label>
                <select id="status" name="status">
                    <option value="2">Open</option>
                    <option value="3">Pending</option>
                    <option value="4">Resolved</option>
                    <option value="5">Closed</option>
                </select>
            </div>

            <!-- New Group field -->
            <div class="form-group">
                <label for="groupField">Group:</label>
                <select id="groupField" name="groupField">
                    <!-- Options will be loaded dynamically -->
                    <option>Loading groups...</option>
                </select>
                <div class="hint">Select a support group</div>
            </div>

            <!-- New Agent field (dependent on Group) -->
            <div class="form-group">
                <label for="agentField">Agent:</label>
                <select id="agentField" name="agentField">
                    <!-- Options will be loaded based on the selected group -->
                    <option>Loading agents...</option>
                </select>
                <div class="hint">Select an agent</div>
            </div>

            <div class="form-actions">
                <fw-button id="cancelTracker" color="secondary">Cancel</fw-button>
                <fw-button id="createTracker" color="primary" type="submit">Create Tracker</fw-button>
            </div>
            <!-- Description preview modal -->
            <div id="descriptionPreviewModal" class="description-preview-modal" style="display: none;">
                <div class="description-preview-content">
                    <h3>Description Preview</h3>
                    <div class="description-preview-text" id="descriptionPreviewText"></div>
                    <div class="form-actions">
                        <fw-button id="closePreview" color="secondary">Close</fw-button>
                    </div>
                </div>
            </div>
            </form>
            </div>

    <!-- Screenshot upload field -->
    <div class="form-group">
        <label for="screenshots" data-original-text="Attachments:">Attachments:</label>
        <div class="attachment-input-container">
            <input type="file" id="screenshots" name="screenshots" multiple>
            <div class="hint">Upload files to include in the ticket (15MB total)</div>
        </div>
        <div id="screenshotPreview" class="screenshot-preview"></div>
        <div id="attachmentCounter" class="attachment-counter"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Wait for the Freshworks SDK to be available
            let initRetries = 0;
            const maxRetries = 10;

            // Store ticket data from parent
            let ticketData = {
                isVip: false,
                districtName: '',
                currentTicketId: null,
                requesterEmail: ''
            };

            function initializeClient() {
                if (typeof client !== 'undefined') {
                    setupFormHandlers(client);
                } else if (typeof app !== 'undefined') {
                    app.initialized().then(function (clientObj) {
                        setupFormHandlers(clientObj);
                    }).catch(handleInitError);
                } else if (typeof window.frsh !== 'undefined' && window.frsh.init) {
                    window.frsh.init().then(function (clientObj) {
                        setupFormHandlers(clientObj);
                    }).catch(handleInitError);
                } else if (initRetries < maxRetries) {
                    initRetries++;
                    setTimeout(initializeClient, 100);
                } else {
                    handleInitError(new Error("Could not initialize client after multiple attempts"));
                }
            }

            function handleInitError(error) {
                console.error("Modal initialization error:", error);
                document.querySelector('.tracker-form-container').innerHTML =
                    '<div class="error-card">Failed to initialize app client. Please close and try again.</div>';
            }

            function setupFormHandlers(client) {
                window.client = client;
                console.log("Setting up form handlers");

                async function getLoggedInUserEmail() {
                    try {
                        console.log("Fetching agent email directly from modal");
                        const userData = await client.data.get("loggedInUser");
                        console.log("Agent data:", userData);
                        if (userData && userData.loggedInUser && userData.loggedInUser.contact && userData.loggedInUser.contact.email) {
                            const agentEmail = userData.loggedInUser.contact.email;
                            console.log("Found agent email:", agentEmail);
                            document.getElementById('email').value = agentEmail;
                            document.getElementById('emailStatus').innerHTML =
                                `<span style="color: green">✓ Email loaded: ${agentEmail}</span>`;
                            return agentEmail;
                        } else {
                            console.warn("Could not get agent email from userData");
                            document.getElementById('emailStatus').innerHTML =
                                '<span style="color: orange">⚠️ Email not found in user data</span>';
                            return null;
                        }
                    } catch (error) {
                        console.error("Error getting logged-in user data:", error);
                        document.getElementById('emailStatus').innerHTML =
                            '<span style="color: red">✗ Error loading email</span>';
                        return null;
                    }
                }

                async function getAssignedAgentEmail(ticketId) {
                    try {
                        const ticketResponse = await client.request.invokeTemplate("getTicketDetails", {
                            context: { ticketId: ticketId }
                        });
                        const ticketData = JSON.parse(ticketResponse.response);
                        console.log("Related ticket data:", ticketData);
                        if (!ticketData.responder_id) {
                            console.warn("Ticket doesn't have an assigned agent");
                            return null;
                        }
                        const agentResponse = await client.request.invokeTemplate("getAgentDetails", {
                            context: { agentId: ticketData.responder_id }
                        });
                        const agentData = JSON.parse(agentResponse.response);
                        console.log("Assigned agent data:", agentData);
                        if (agentData && agentData.contact && agentData.contact.email) {
                            console.log("Found assigned agent email:", agentData.contact.email);
                            document.getElementById('email').value = agentData.contact.email;
                            document.getElementById('emailStatus').innerHTML =
                                `<span style="color: green">✓ Using assigned agent's email: ${agentData.contact.email}</span>`;
                            return agentData.contact.email;
                        } else {
                            console.warn("Could not get assigned agent email");
                            return null;
                        }
                    } catch (error) {
                        console.error("Error getting assigned agent email:", error);
                        return null;
                    }
                }

                client.instance.context().then(async function (context) {
                    console.log("Modal context:", context);
                    if (context && context.data) {
                        ticketData = {
                            isVip: context.data.isVip || false,
                            districtName: context.data.districtName || '',
                            currentTicketId: context.data.currentTicketId || null,
                            requesterEmail: context.data.requesterEmail || '',
                            ticketRequesterEmail: context.data.ticketRequesterEmail || ''
                        };
                        console.log("Received ticket data:", ticketData);
                        if (ticketData.currentTicketId) {
                            document.getElementById('relatedTickets').value = ticketData.currentTicketId;
                            const assignedAgentEmail = await getAssignedAgentEmail(ticketData.currentTicketId);
                            if (!assignedAgentEmail) {
                                await getLoggedInUserEmail();
                            }
                        } else {
                            await getLoggedInUserEmail();
                        }
                        const today = new Date().toISOString().split('T')[0];
                        document.getElementById('dateReported').value = today;
                    } else {
                        console.log("No context data, fetching agent email directly");
                        await getLoggedInUserEmail();
                        const today = new Date().toISOString().split('T')[0];
                        document.getElementById('dateReported').value = today;
                    }
                    setupSubjectGeneration();
                }).catch(async function (error) {
                    console.error("Error getting modal context:", error);
                    await getLoggedInUserEmail();
                    setupSubjectGeneration();
                });

                if (!document.getElementById('email').value) {
                    document.getElementById('email').value = "freshdesk_agent@example.com";
                    document.getElementById('emailStatus').innerHTML =
                        '<span style="color: blue">ℹ️ Using placeholder email</span>';
                }

                function setupSubjectGeneration() {
                    const applicationField = document.getElementById('application');
                    const specificIssueField = document.getElementById('specificIssue');
                    applicationField.addEventListener('input', generateSubject);
                    specificIssueField.addEventListener('input', generateSubject);
                    generateSubject();
                }

                function generateSubject() {
                    const application = document.getElementById('application').value.trim();
                    const specificIssue = document.getElementById('specificIssue').value.trim();
                    let subject = '';
                    if (ticketData.isVip) {
                        subject = 'VIP* ';
                    }
                    if (ticketData.districtName) {
                        subject += ticketData.districtName;
                    }
                    if (application) {
                        subject += ' | ' + application;
                        if (specificIssue) {
                            subject += '- ' + specificIssue;
                        }
                    }
                    document.getElementById('subject').value = subject;
                }

                function generateDescription() {
                    const subject = document.getElementById('subject').value.trim();
                    const issueSummary = document.getElementById('issueSummary').value.trim();
                    const reportedIssue = document.getElementById('reportedIssue').value.trim();

                    // User info from userInfo field instead of separate fields
                    const userInfo = document.getElementById('userInfo').value.trim();

                    // Get the full product value from the dataset if available, otherwise fall back to the select value
                    const productImpacted = document.getElementById('productImpacted').dataset.fullValue ||
                        document.getElementById('productImpacted').value || '';

                    // Other fields
                    const xcodeInfo = document.getElementById('xcodeInfo').value.trim();
                    const districtState = document.getElementById('districtState').value.trim();
                    const impactType = document.getElementById('impactType').value;
                    const dateReported = document.getElementById('dateReported').value;
                    const impactScope = document.getElementById('impactScope').value;
                    const components = document.getElementById('components').value.trim();
                    const stepsToReproduce = document.getElementById('stepsToReproduce').value.trim();
                    const actualResults = document.getElementById('actualResults').value.trim();
                    const expectedResults = document.getElementById('expectedResults').value.trim();

                    let formattedDate = '';
                    if (dateReported) {
                        const date = new Date(dateReported);
                        formattedDate = date.toLocaleDateString('en-US', {
                            year: 'numeric', month: 'long', day: 'numeric'
                        });
                    }

                    // Main container with border and box shadow for a professional scorecard appearance
                    let description = '<div style="font-family: \'Segoe UI\', Arial, sans-serif; line-height: 1.5; border: 2px solid #d1d1d1; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); overflow: hidden; margin: 10px 0;">';

                    // Title banner with "Assembly" at the top
                    description += '<div style="background: linear-gradient(135deg, #1976d2 0%, #0d47a1 100%); color: white; padding: 15px 20px; font-size: 20px; font-weight: bold; letter-spacing: 0.5px; border-bottom: 2px solid #0d47a1;">Assembly Issue Tracker</div>';

                    // Summary section with enhanced styling
                    description += '<div style="border-bottom: 2px solid #e0e0e0; padding: 20px; background-color: #f9f9f9;">';
                    description += '<div style="font-weight: bold; color: #333; margin-bottom: 10px; font-size: 16px; border-left: 4px solid #1976d2; padding-left: 10px;">Summary</div>';
                    if (issueSummary) {
                        description += `<div style="margin-bottom: 5px; padding: 10px; background-color: white; border-radius: 4px; border: 1px solid #e0e0e0;">${issueSummary}</div>`;
                    } else {
                        description += `<div style="margin-bottom: 5px; padding: 10px; background-color: white; border-radius: 4px; border: 1px solid #e0e0e0;">${subject}</div>`;
                    }
                    description += '</div>';

                    // Reported Issue section with enhanced styling
                    description += '<div style="border-bottom: 2px solid #e0e0e0; padding: 20px; background-color: white;">';
                    description += '<div style="font-weight: bold; color: #333; margin-bottom: 10px; font-size: 16px; border-left: 4px solid #ff9800; padding-left: 10px;">Reported Issue</div>';

                    if (reportedIssue) {
                        description += `<div style="margin-bottom: 5px; padding: 10px; background-color: #fff9e6; border-radius: 4px; border: 1px solid #ffe0b2;">${reportedIssue}</div>`;
                    }
                    description += '</div>';

                    // Issue Details section with enhanced styling
                    description += '<div style="border-bottom: 2px solid #e0e0e0; padding: 20px; background-color: #f9f9f9;">';
                    description += '<div style="font-weight: bold; color: #333; margin-bottom: 10px; font-size: 16px; border-left: 4px solid #4caf50; padding-left: 10px;">Issue Details</div>';

                    // Table with enhanced styling
                    description += '<div style="display: table; width: 100%; border-collapse: separate; border-spacing: 0 8px;">';

                    // Function to create a table row with enhanced styling
                    const addRow = (label, value, isVip = false) => {
                        if (!value && !isVip) return '';
                        const vipStyle = isVip ? 'color: #d32f2f; font-weight: bold;' : '';
                        return `
            <div style="display: table-row;">
                <div style="display: table-cell; width: 35%; padding: 10px; vertical-align: top; font-weight: bold; background-color: #eef2f6; border-radius: 4px 0 0 4px; border: 1px solid #d1d1d1; border-right: none;">${label}:</div>
                <div style="display: table-cell; padding: 10px; vertical-align: top; background-color: white; border-radius: 0 4px 4px 0; border: 1px solid #d1d1d1; border-left: none; ${vipStyle}">${value || 'No'}</div>
            </div>
        `;
                    };

                    // Add all the rows with enhanced styling
                    if (userInfo) description += addRow('User Name and Email/Role', userInfo);
                    description += addRow('Product/Program Impacted', productImpacted);
                    description += addRow('Xcode', xcodeInfo);
                    description += addRow('District State', districtState);
                    description += addRow('Digital/Print Impact', impactType);
                    description += addRow('Date Reported', formattedDate);
                    description += addRow('Teacher/Student Impact', impactScope);

                    // Make VIP field red as requested
                    description += addRow('VIP Customer', ticketData.isVip ? 'Yes' : 'No', true);

                    description += '</div>'; // Close table
                    description += '</div>'; // Close Issue Details section

                    // Components section with enhanced styling
                    if (components) {
                        description += '<div style="border-bottom: 2px solid #e0e0e0; padding: 20px; background-color: white;">';
                        description += '<div style="font-weight: bold; color: #333; margin-bottom: 10px; font-size: 16px; border-left: 4px solid #9c27b0; padding-left: 10px;">Components</div>';
                        description += `<div style="margin-bottom: 5px; padding: 10px; background-color: #f3e5f5; border-radius: 4px; border: 1px solid #e1bee7;">${components}</div>`;
                        description += '</div>';
                    }

                    // Steps To Reproduce section with enhanced styling
                    if (stepsToReproduce) {
                        description += '<div style="border-bottom: 2px solid #e0e0e0; padding: 20px; background-color: #f9f9f9;">';
                        description += '<div style="font-weight: bold; color: #333; margin-bottom: 10px; font-size: 16px; border-left: 4px solid #2196f3; padding-left: 10px;">Steps To Reproduce</div>';
                        description += `<div style="margin-bottom: 5px; padding: 10px; background-color: white; border-radius: 4px; border: 1px solid #bbdefb;">${stepsToReproduce}</div>`;
                        description += '</div>'; // Close Steps section
                    }

                    // Actual Results with enhanced styling
                    if (actualResults) {
                        description += '<div style="border-bottom: 2px solid #e0e0e0; padding: 20px; background-color: white;">';
                        description += '<div style="font-weight: bold; color: #333; margin-bottom: 10px; font-size: 16px; border-left: 4px solid #ff9800; padding-left: 10px;">Actual Results</div>';
                        description += `<div style="background-color: #fff8e1; padding: 15px; border-radius: 4px; border: 1px solid #ffe082;">${actualResults}</div>`;
                        description += '</div>';
                    }

                    // Expected Results with enhanced styling
                    if (expectedResults) {
                        description += '<div style="padding: 20px; background-color: #f9f9f9;">';
                        description += '<div style="font-weight: bold; color: #333; margin-bottom: 10px; font-size: 16px; border-left: 4px solid #4caf50; padding-left: 10px;">Expected Results</div>';
                        description += `<div style="background-color: #e8f5e9; padding: 15px; border-radius: 4px; border: 1px solid #c8e6c9;">${expectedResults}</div>`;
                        description += '</div>';
                    }

                    // Close the main container
                    description += '</div>';

                    return description;
                }

                // New function to upload screenshot files to ImgBB and return an array of public URLs
                async function getScreenshotUrls() {
                    // Use our aggregated collection instead of the file input's files
                    const urls = [];
                    const IMGBB_API_KEY = "b3da8c974bc40dd87d896d84436dd76e"; // Your ImgBB API key
                    for (let i = 0; i < aggregatedScreenshotFiles.length; i++) {
                        const file = aggregatedScreenshotFiles[i];
                        const formData = new FormData();
                        formData.append('image', file);
                        try {
                            const response = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`, {
                                method: 'POST',
                                body: formData
                            });
                            const data = await response.json();
                            if (data && data.success) {
                                urls.push(data.data.display_url);
                            }
                        } catch (error) {
                            console.error("Error uploading screenshot:", error);
                        }
                    }
                    return urls;
                }

                // New async function that uses the existing generateDescription() output
                // and injects the inline screenshots into designated sections
                async function generateDescriptionWithScreenshots() {
                    const baseDescription = generateDescription();
                    const screenshotUrls = await getScreenshotUrls();
                    let enhancedDescription = baseDescription;
                    if (screenshotUrls.length > 0) {
                        const imgTags = screenshotUrls.map(url => `<img src="${url}" alt="Screenshot" style="max-width:100%;display:block;margin:10px 0;">`).join("");
                        // For each designated section, append the image tags after the primary content.
                        enhancedDescription = enhancedDescription.replace(
                            /(<h3[^>]*>\s*Reported Issue\s*<\/h3>[\s\S]*?<p[^>]*>.*?<\/p>)/i,
                            "$1" + imgTags
                        );
                        enhancedDescription = enhancedDescription.replace(
                            /(<h3[^>]*>\s*Summary\s*<\/h3>[\s\S]*?<p[^>]*>.*?<\/p>)/i,
                            "$1" + imgTags
                        );
                        enhancedDescription = enhancedDescription.replace(
                            /(<h3[^>]*>\s*Steps To Reproduce\s*<\/h3>[\s\S]*?(<div|<p)[^>]*>.*?(<\/div>|<\/p>))/i,
                            "$1" + imgTags
                        );
                        enhancedDescription = enhancedDescription.replace(
                            /(<h4[^>]*>\s*Actual Results\s*<\/h4>[\s\S]*?(<div|<p)[^>]*>.*?(<\/div>|<\/p>))/i,
                            "$1" + imgTags
                        );
                        enhancedDescription = enhancedDescription.replace(
                            /(<h4[^>]*>\s*Expected Results\s*<\/h4>[\s\S]*?(<div|<p)[^>]*>.*?(<\/div>|<\/p>))/i,
                            "$1" + imgTags
                        );
                    }
                    return enhancedDescription;
                }

                // Update previewDescription button event handler to use the new async function
                document.getElementById('previewDescription').addEventListener('click', async function (e) {
                    e.preventDefault();
                    const previewText = document.getElementById('descriptionPreviewText');
                    previewText.innerHTML = await generateDescriptionWithScreenshots();
                    document.getElementById('descriptionPreviewModal').style.display = 'block';
                });

                // Close preview button handler
                document.getElementById('closePreview').addEventListener('click', function () {
                    document.getElementById('descriptionPreviewModal').style.display = 'none';
                });

                // Handle form submission with fixed file upload sequence
                document.getElementById('trackerForm').addEventListener('submit', async function (e) {
                    e.preventDefault();
                    try {
                        let subdomainCheck;
                        try {
                            subdomainCheck = await client.iparams.get("freshdesk_subdomain");
                            console.log("Subdomain check:", subdomainCheck);
                            if (!subdomainCheck || !subdomainCheck.freshdesk_subdomain || !subdomainCheck.freshdesk_subdomain.trim()) {
                                throw new Error("Missing Freshdesk subdomain configuration");
                            }
                        } catch (configError) {
                            console.error("Configuration error:", configError);
                            client.interface.trigger("showNotify", {
                                type: "danger",
                                message: "App configuration error: Freshdesk subdomain is missing or invalid."
                            });
                            document.getElementById('createTracker').disabled = false;
                            return;
                        }

                        const subject = document.getElementById('subject').value;
                        const description = generateDescription();
                        const agentEmail = document.getElementById('email').value || "agent@freshdesk.com";
                        const relatedTicketsStr = document.getElementById('relatedTickets').value;
                        const priority = document.getElementById('priority').value;
                        const status = document.getElementById('status').value;
                        // Use our aggregated collection instead of the file input's files
                        const screenshotFiles = aggregatedScreenshotFiles;
                        const groupId = document.getElementById('groupField').value;
                        const agentId = document.getElementById('agentField').value;

                        // Get the product value but DON'T add it as a custom field
                        // We already include this in the description via the generateDescription function
                        const productImpacted = document.getElementById('productImpacted').dataset.fullValue ||
                            document.getElementById('productImpacted').value || '';

                        const relatedTicketIds = relatedTicketsStr.split(',')
                            .map(id => id.trim())
                            .filter(id => id !== '' && !isNaN(parseInt(id, 10)))
                            .map(id => parseInt(id, 10));

                        if (relatedTicketIds.length === 0) {
                            alert('Please enter at least one valid related ticket ID');
                            return;
                        }

                        console.log("Form values:", {
                            subject,
                            description: description.substring(0, 50) + "...",
                            email: agentEmail,
                            relatedTickets: relatedTicketsStr,
                            relatedTicketIds: relatedTicketIds,
                            priority,
                            status,
                            groupId,
                            agentId,
                            productImpacted, // Log it but don't send as custom field
                            attachments: screenshotFiles.length > 0 ? `${screenshotFiles.length} files selected` : 'No files'
                        });

                        // STEP 1: First create the ticket without attachments
                        const ticketData = {
                            email: agentEmail,
                            subject: subject,
                            description: description,
                            related_ticket_ids: relatedTicketIds,
                            priority: parseInt(priority, 10),
                            status: parseInt(status, 10),
                            type: "Incident"
                        };

                        // Add group ID if selected
                        if (groupId) {
                            ticketData.group_id = parseInt(groupId, 10);
                            console.log(`Setting group_id: ${groupId}`);
                        }

                        // Add agent ID if selected
                        if (agentId) {
                            ticketData.responder_id = parseInt(agentId, 10);
                            console.log(`Setting responder_id: ${agentId}`);
                        }

                        console.log("Creating ticket with data:", ticketData);

                        console.log("First creating ticket without attachments");

                        const createResponse = await client.request.invokeTemplate("createfdTicket", {
                            body: JSON.stringify(ticketData)
                        });

                        const newTicket = JSON.parse(createResponse.response);
                        console.log("Created ticket:", newTicket);
                        const newTicketId = newTicket.id;

                        if (!newTicketId) {
                            throw new Error("Failed to get ID of newly created ticket");
                        }

                        // STEP 2: Add attachments as a private note to the ticket
                        console.log(`Adding ${screenshotFiles.length} attachments as note to ticket #${newTicketId}`);

                        try {
                            // API credentials
                            const subdomain = "benchmarkeducationcompany";
                            const apiKey = "5TMgbcZdRFY70hSpEdj";

                            console.log(`Using subdomain: ${subdomain} to upload attachments`);

                            // Create FormData for the attachment upload
                            const formData = new FormData();
                            formData.append('body', 'Additional Screenshots and other file attachments');
                            formData.append('private', 'true');

                            // Add each file to the form data
                            for (let i = 0; i < screenshotFiles.length; i++) {
                                const file = screenshotFiles[i];
                                formData.append('attachments[]', file, file.name);
                            }

                            // Use XMLHttpRequest for direct API access
                            const xhr = new XMLHttpRequest();
                            xhr.open('POST', `https://${subdomain}.freshdesk.com/api/v2/tickets/${newTicketId}/notes`, true);

                            // Set up Basic Auth using the API key
                            xhr.setRequestHeader('Authorization', 'Basic ' + btoa(`${apiKey}:X`));

                            // Handle response
                            xhr.onload = function () {
                                if (xhr.status >= 200 && xhr.status < 300) {
                                    console.log("Attachments added successfully:", xhr.responseText);
                                    client.interface.trigger("showNotify", {
                                        type: "success",
                                        message: `Tracker #${newTicketId} created successfully with attachment`
                                    });
                                } else {
                                    console.error("Error from API:", xhr.status, xhr.responseText);
                                    client.interface.trigger("showNotify", {
                                        type: "warning",
                                        message: `Tracker #${newTicketId} created, but attachment upload failed`
                                    });
                                }
                                // Close the modal in either case
                                client.instance.close({ refreshTickets: true });
                            };

                            // Handle network errors
                            xhr.onerror = function () {
                                console.error("Network error while uploading attachments");
                                client.interface.trigger("showNotify", {
                                    type: "warning",
                                    message: `Tracker #${newTicketId} created, but attachment upload failed due to network error`
                                });
                                client.instance.close({ refreshTickets: true });
                            };

                            // Send the form data
                            xhr.send(formData);
                            console.log("Attachment request sent via direct XMLHttpRequest");

                        } catch (attachmentError) {
                            // Log attachment error but don't fail the overall process
                            console.error("Error adding attachments as note:", attachmentError);
                            console.warn("Continuing without attachments");

                            client.interface.trigger("showNotify", {
                                type: "warning",
                                message: `Tracker #${newTicketId} created, but attachment handling failed: ${attachmentError.message}`
                            });
                            client.instance.close({ refreshTickets: true });
                        }
                    } catch (error) {
                        console.error("Error creating tracker:", error);
                        console.error("Error details:", JSON.stringify(error, null, 2));
                        let errorMessage = "Failed to create tracker: ";
                        if (error.response) {
                            console.log("Raw error response:", error.response);
                            try {
                                const errorData = JSON.parse(error.response);
                                console.log("Parsed error data:", errorData);
                                errorMessage += errorData.description || error.response;
                            } catch (e) {
                                errorMessage += error.response;
                            }
                        } else if (error.errors && error.errors.length) {
                            errorMessage += error.errors.map(e => e.message || JSON.stringify(e)).join("; ");
                        } else {
                            errorMessage += error.message || "Unknown error";
                        }
                        client.interface.trigger("showNotify", {
                            type: "danger",
                            message: errorMessage
                        });
                        document.getElementById('createTracker').disabled = false;
                    }
                });

                let aggregatedScreenshotFiles = [];

                /**
                 * Enhanced file type detection for better previews
                 */
                function getFileTypeInfo(file) {
                    // Extract file extension
                    const fileName = file.name || '';
                    const fileExtension = fileName.split('.').pop().toLowerCase();
                    const mimeType = file.type || '';

                    // Default file type info
                    let iconClass = 'fa-file';
                    let fileTypeLabel = 'File';
                    let colorClass = '';

                    // Common document types
                    if (['doc', 'docx', 'odt', 'rtf'].includes(fileExtension) ||
                        mimeType.includes('word') || mimeType.includes('opendocument.text')) {
                        iconClass = 'fa-file-word';
                        fileTypeLabel = 'Document';
                        colorClass = 'word-color';
                    }
                    // Spreadsheet types
                    else if (['xls', 'xlsx', 'xlsm', 'csv', 'ods'].includes(fileExtension) ||
                        mimeType.includes('excel') || mimeType.includes('spreadsheet') ||
                        mimeType.includes('csv')) {
                        iconClass = 'fa-file-excel';
                        fileTypeLabel = 'Spreadsheet';
                        colorClass = 'excel-color';
                    }
                    // Presentation types
                    else if (['ppt', 'pptx', 'odp'].includes(fileExtension) ||
                        mimeType.includes('powerpoint') || mimeType.includes('presentation')) {
                        iconClass = 'fa-file-powerpoint';
                        fileTypeLabel = 'Presentation';
                        colorClass = 'powerpoint-color';
                    }
                    // PDF files
                    else if (fileExtension === 'pdf' || mimeType.includes('pdf')) {
                        iconClass = 'fa-file-pdf';
                        fileTypeLabel = 'PDF';
                        colorClass = 'pdf-color';
                    }
                    // Archive files
                    else if (['zip', 'rar', 'tar', 'gz', '7z'].includes(fileExtension) ||
                        mimeType.includes('zip') || mimeType.includes('compressed')) {
                        iconClass = 'fa-file-archive';
                        fileTypeLabel = 'Archive';
                        colorClass = 'archive-color';
                    }
                    // Plain text files
                    else if (['txt', 'log', 'md'].includes(fileExtension) ||
                        mimeType.includes('text/plain')) {
                        iconClass = 'fa-file-alt';
                        fileTypeLabel = 'Text';
                        colorClass = 'text-color';
                    }
                    // Code files
                    else if (['html', 'htm', 'xml', 'json', 'js', 'css', 'php', 'py', 'java', 'c', 'cpp'].includes(fileExtension) ||
                        mimeType.includes('code') || mimeType.includes('javascript') || mimeType.includes('html')) {
                        iconClass = 'fa-file-code';
                        fileTypeLabel = 'Code';
                        colorClass = 'code-color';
                    }
                    // Audio files
                    else if (['mp3', 'wav', 'ogg', 'flac', 'm4a'].includes(fileExtension) ||
                        mimeType.includes('audio')) {
                        iconClass = 'fa-file-audio';
                        fileTypeLabel = 'Audio';
                        colorClass = 'audio-color';
                    }
                    // Video files
                    else if (['mp4', 'mov', 'avi', 'wmv', 'flv', 'mkv', 'webm'].includes(fileExtension) ||
                        mimeType.includes('video')) {
                        iconClass = 'fa-file-video';
                        fileTypeLabel = 'Video';
                        colorClass = 'video-color';
                    }
                    // HAR files (HTTP Archive)
                    else if (fileExtension === 'har') {
                        iconClass = 'fa-file-code';
                        fileTypeLabel = 'HAR';
                        colorClass = 'har-color';
                    }

                    // Image files are handled differently with actual thumbnails
                    const isImage = file.type.match('image.*');

                    // Get file size in appropriate units
                    const fileSizeBytes = file.size;
                    let fileSize = '';

                    if (fileSizeBytes < 1024) {
                        fileSize = fileSizeBytes + ' B';
                    } else if (fileSizeBytes < 1024 * 1024) {
                        fileSize = (fileSizeBytes / 1024).toFixed(1) + ' KB';
                    } else {
                        fileSize = (fileSizeBytes / (1024 * 1024)).toFixed(1) + ' MB';
                    }

                    return {
                        iconClass,
                        fileTypeLabel,
                        colorClass,
                        isImage,
                        fileSize,
                        fileSizeBytes,
                        extension: fileExtension,
                        mimeType
                    };
                }

                /**
                 * Function to create a file preview element
                 */
                function createFilePreviewElement(file, index) {
                    const fileInfo = getFileTypeInfo(file);
                    const previewDiv = document.createElement('div');
                    previewDiv.className = 'file-thumbnail';
                    previewDiv.dataset.fileIndex = index;

                    if (fileInfo.isImage) {
                        // For image files, create a thumbnail preview
                        const reader = new FileReader();
                        reader.onload = function (e) {
                            previewDiv.innerHTML = `
                                <div class="thumbnail-container">
                                    <img src="${e.target.result}" title="${file.name}" alt="${file.name}"/>
                                </div>
                                <div class="file-filename" title="${file.name}">${file.name}</div>
                                <div class="file-size">${fileInfo.fileSize}</div>
                                <div class="file-remove" data-index="${index}">✕</div>`;

                            // Add event listener to the remove button
                            previewDiv.querySelector('.file-remove').addEventListener('click', function (e) {
                                e.stopPropagation();
                                const index = parseInt(this.dataset.index);
                                removeFile(index);
                            });
                        };
                        reader.readAsDataURL(file);
                    } else {
                        // For non-image files, show appropriate icon based on file type
                        previewDiv.innerHTML = `
                            <div class="thumbnail-container file-icon-container ${fileInfo.colorClass}">
                                <i class="fas ${fileInfo.iconClass} file-icon"></i>
                                <div class="file-type-label">${fileInfo.fileTypeLabel}</div>
                            </div>
                            <div class="file-filename" title="${file.name}">${file.name}</div>
                            <div class="file-size">${fileInfo.fileSize}</div>
                            <div class="file-remove" data-index="${index}">✕</div>`;

                        // Add event listener to the remove button
                        previewDiv.querySelector('.file-remove').addEventListener('click', function (e) {
                            e.stopPropagation();
                            const index = parseInt(this.dataset.index);
                            removeFile(index);
                        });
                    }

                    // Make the whole preview clickable to view file details
                    previewDiv.addEventListener('click', function () {
                        showFileDetails(file, index);
                    });

                    return previewDiv;
                }

                /**
                 * Function to show file details when a preview is clicked
                 */
                function showFileDetails(file, index) {
                    const fileInfo = getFileTypeInfo(file);
                    const detailsHtml = `
                        <div class="file-details-header">
                            <h3>File Details</h3>
                            <div class="file-details-close">✕</div>
                        </div>
                        <div class="file-details-content">
                            <div class="file-details-icon">
                                <i class="fas ${fileInfo.iconClass} file-icon-large"></i>
                            </div>
                            <div class="file-details-info">
                                <p><strong>Name:</strong> ${file.name}</p>
                                <p><strong>Type:</strong> ${file.type || 'Unknown'}</p>
                                <p><strong>Size:</strong> ${fileInfo.fileSize}</p>
                                <p><strong>Last Modified:</strong> ${new Date(file.lastModified).toLocaleString()}</p>
                            </div>
                        </div>
                        <div class="file-details-actions">
                            <button class="file-details-remove" data-index="${index}">Remove File</button>
                        </div>
                    `;

                    // Create or update the details modal
                    let detailsModal = document.getElementById('fileDetailsModal');
                    if (!detailsModal) {
                        detailsModal = document.createElement('div');
                        detailsModal.id = 'fileDetailsModal';
                        detailsModal.className = 'file-details-modal';
                        document.body.appendChild(detailsModal);
                    }

                    detailsModal.innerHTML = detailsHtml;
                    detailsModal.style.display = 'block';

                    // Add event listeners
                    detailsModal.querySelector('.file-details-close').addEventListener('click', function () {
                        detailsModal.style.display = 'none';
                    });

                    detailsModal.querySelector('.file-details-remove').addEventListener('click', function () {
                        const index = parseInt(this.dataset.index);
                        removeFile(index);
                        detailsModal.style.display = 'none';
                    });
                }

                // Enhanced file preview functionality with attachment totals
                document.getElementById('screenshots').addEventListener('change', function (e) {
                    const previewContainer = document.getElementById('screenshotPreview');
                    if (this.files.length > 0) {
                        // Add new files to our aggregated collection
                        for (let i = 0; i < this.files.length; i++) {
                            aggregatedScreenshotFiles.push(this.files[i]);
                        }

                        // Clear the preview container first to show all files
                        previewContainer.innerHTML = '';

                        // Add attachments summary at the top
                        updateAttachmentsSummary(previewContainer);

                        // Preview up to 5 files to avoid overwhelming the UI
                        const fileCount = Math.min(aggregatedScreenshotFiles.length, 5);
                        for (let i = 0; i < fileCount; i++) {
                            const filePreview = createFilePreviewElement(aggregatedScreenshotFiles[i], i);
                            previewContainer.appendChild(filePreview);
                        }

                        // Show note if there are more files than we're showing
                        if (aggregatedScreenshotFiles.length > 5) {
                            const noteDiv = document.createElement('div');
                            noteDiv.className = 'file-note';
                            noteDiv.textContent = `Note: Only showing the first 5 files. All ${aggregatedScreenshotFiles.length} files will be uploaded.`;
                            previewContainer.appendChild(noteDiv);
                        }

                        // Add a clear all button if there are files
                        if (aggregatedScreenshotFiles.length > 0) {
                            const clearAllDiv = document.createElement('div');
                            clearAllDiv.className = 'clear-files';
                            clearAllDiv.innerHTML = `<button type="button">Clear All Attachments (${aggregatedScreenshotFiles.length})</button>`;
                            clearAllDiv.querySelector('button').addEventListener('click', function () {
                                clearAllFiles();
                            });
                            previewContainer.appendChild(clearAllDiv);
                        }

                        // Update the attachment count indicator
                        updateAttachmentCountIndicator();

                        // Clear the file input so the same files can be selected again
                        this.value = '';
                    }
                });

                /**
                 * Calculate and display attachment totals information
                 */
                function updateAttachmentsSummary(container) {
                    if (!container) container = document.getElementById('screenshotPreview');

                    // Calculate total size
                    let totalSizeBytes = 0;
                    let fileTypes = new Set();

                    aggregatedScreenshotFiles.forEach(file => {
                        totalSizeBytes += file.size;
                        const extension = file.name.split('.').pop().toLowerCase();
                        fileTypes.add(extension);
                    });

                    // Format size for display
                    let formattedSize;
                    if (totalSizeBytes < 1024) {
                        formattedSize = totalSizeBytes + ' B';
                    } else if (totalSizeBytes < 1024 * 1024) {
                        formattedSize = (totalSizeBytes / 1024).toFixed(1) + ' KB';
                    } else {
                        formattedSize = (totalSizeBytes / (1024 * 1024)).toFixed(2) + ' MB';
                    }

                    // Create the summary element
                    const summaryDiv = document.createElement('div');
                    summaryDiv.className = 'attachments-summary';
                    if (totalSizeBytes > 10 * 1024 * 1024) { // Mark as large if over 10MB
                        summaryDiv.classList.add('large-size');
                    }

                    summaryDiv.innerHTML = `
                        <div class="attachments-count">
                            <strong>${aggregatedScreenshotFiles.length}</strong> file${aggregatedScreenshotFiles.length !== 1 ? 's' : ''} attached
                            ${fileTypes.size > 1 ? `(${fileTypes.size} different types)` : ''}
                        </div>
                        <div class="attachments-size">Total: ${formattedSize}</div>
                    `;

                    // Insert at the beginning of the container
                    if (container.firstChild) {
                        container.insertBefore(summaryDiv, container.firstChild);
                    } else {
                        container.appendChild(summaryDiv);
                    }

                    return summaryDiv;
                }

                // Function to remove a file by index
                function removeFile(index) {
                    if (index >= 0 && index < aggregatedScreenshotFiles.length) {
                        // Remove the file from our collection
                        aggregatedScreenshotFiles.splice(index, 1);

                        // Refresh the preview to reflect the change
                        const previewContainer = document.getElementById('screenshotPreview');
                        previewContainer.innerHTML = '';

                        // Re-add the summary information
                        if (aggregatedScreenshotFiles.length > 0) {
                            updateAttachmentsSummary(previewContainer);
                        }

                        // Rebuild the preview display
                        const fileCount = Math.min(aggregatedScreenshotFiles.length, 5);
                        for (let i = 0; i < fileCount; i++) {
                            const filePreview = createFilePreviewElement(aggregatedScreenshotFiles[i], i);
                            previewContainer.appendChild(filePreview);
                        }

                        // Show note if there are more files than we're showing
                        if (aggregatedScreenshotFiles.length > 5) {
                            const noteDiv = document.createElement('div');
                            noteDiv.className = 'file-note';
                            noteDiv.textContent = `Note: Only showing the first 5 files. All ${aggregatedScreenshotFiles.length} files will be uploaded.`;
                            previewContainer.appendChild(noteDiv);
                        }

                        // Add a clear all button if there are files
                        if (aggregatedScreenshotFiles.length > 0) {
                            const clearAllDiv = document.createElement('div');
                            clearAllDiv.className = 'clear-files';
                            clearAllDiv.innerHTML = `<button type="button">Clear All Attachments (${aggregatedScreenshotFiles.length})</button>`;
                            clearAllDiv.querySelector('button').addEventListener('click', function () {
                                clearAllFiles();
                            });
                            previewContainer.appendChild(clearAllDiv);
                        }

                        // Update the attachment count indicator
                        updateAttachmentCountIndicator();
                    }
                }

                // Function to clear all files
                function clearAllFiles() {
                    aggregatedScreenshotFiles = [];
                    document.getElementById('screenshotPreview').innerHTML = '';
                    updateAttachmentCountIndicator();
                }

                // Initialize the original label text when DOM is loaded
                const screenshotsLabel = document.querySelector('label[for="screenshots"]');
                if (screenshotsLabel) {
                    screenshotsLabel.setAttribute('data-original-text', screenshotsLabel.textContent);
                }

                document.getElementById('debugFillForm').addEventListener('click', function (e) {
                    e.preventDefault();
                    fillFormWithDemoData();
                });

                function fillFormWithDemoData() {
                    document.getElementById('application').value = 'Bookshelves App';
                    document.getElementById('specificIssue').value = 'Missing School Folder';
                    document.getElementById('issueSummary').value = 'Books not appearing in school folder';
                    document.getElementById('reportedIssue').value = 'User reports that when they log in to the Bookshelves app, the school folder is empty even though content should be visible.';
                    document.getElementById('userInfo').value = 'Jane Smith, jsmith@example.edu, Teacher';
                    document.getElementById('productImpacted').value = 'Math Workbook 5';
                    document.getElementById('xcodeInfo').value = 'XC12345';
                    document.getElementById('districtState').value = 'Florida';
                    document.getElementById('impactType').selectedIndex = 1;
                    const today = new Date().toISOString().split('T')[0];
                    document.getElementById('dateReported').value = today;
                    document.getElementById('impactScope').selectedIndex = 3;
                    document.getElementById('components').value = 'Login, Content Display, School Folder';
                    document.getElementById('stepsToReproduce').value = '1. Log in to Bookshelves app\n2. Navigate to School folder\n3. Observe that the folder appears empty';
                    document.getElementById('actualResults').value = 'School folder shows no content even though books have been assigned';
                    document.getElementById('expectedResults').value = 'School folder should display all books assigned to the user';
                    document.getElementById('relatedTickets').value = '1234, 5678';
                    document.getElementById('priority').selectedIndex = 1;
                    document.getElementById('status').selectedIndex = 0;
                    client.interface.trigger("showNotify", {
                        type: "success",
                        message: "Form filled with demo data"
                    });
                }

                // Initialize Quill editors for rich text fields
                const quillReported = new Quill("#reportedIssueEditor", { theme: "snow", placeholder: "Enter the reported issue..." });
                const quillSummary = new Quill("#issueSummaryEditor", { theme: "snow", placeholder: "Enter the summary..." });
                const quillSteps = new Quill("#stepsToReproduceEditor", { theme: "snow", placeholder: "Enter steps to reproduce..." });
                const quillActual = new Quill("#actualResultsEditor", { theme: "snow", placeholder: "Enter actual results..." });
                const quillExpected = new Quill("#expectedResultsEditor", { theme: "snow", placeholder: "Enter expected results..." });

                // Before form submission, copy Quill HTML into hidden textareas
                document.getElementById('trackerForm').addEventListener('submit', async function (e) {
                    // Update hidden textareas with editor content
                    document.getElementById('reportedIssue').value = quillReported.root.innerHTML;
                    document.getElementById('issueSummary').value = quillSummary.root.innerHTML;
                    document.getElementById('stepsToReproduce').value = quillSteps.root.innerHTML;
                    document.getElementById('actualResults').value = quillActual.root.innerHTML;
                    document.getElementById('expectedResults').value = quillExpected.root.innerHTML;
                    // Form submission continues with the normal flow
                });

                // Helper: Upload an image file to ImgBB and return its URL
                function uploadImageToImgbb(file) {
                    const formData = new FormData();
                    formData.append('image', file);
                    const IMGBB_API_KEY = "b3da8c974bc40dd87d896d84436dd76e";
                    return fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`, {
                        method: 'POST',
                        body: formData
                    })
                        .then(response => response.json())
                        .then(result => {
                            if (result.success) {
                                return result.data.display_url;
                            }
                            throw new Error("Image upload failed");
                        });
                }

                // Handles paste events on a Quill editor and processes image files
                function handlePasteImage(e, quill) {
                    const clipboardData = e.clipboardData || window.clipboardData;
                    if (!clipboardData) return;
                    const items = clipboardData.items;
                    if (!items) return;
                    for (let i = 0; i < items.length; i++) {
                        if (items[i].type.indexOf("image") !== -1) {
                            e.preventDefault();
                            const file = items[i].getAsFile();
                            uploadImageToImgbb(file)
                                .then(url => {
                                    const range = quill.getSelection();
                                    quill.insertEmbed(range.index, 'image', url);
                                })
                                .catch(error => console.error("Image upload error:", error));
                            return;
                        }
                    }
                }

                // Attach paste listener on each Quill editor so pasted images are uploaded automatically
                quillReported.root.addEventListener('paste', function (e) {
                    handlePasteImage(e, quillReported);
                });
                quillSummary.root.addEventListener('paste', function (e) {
                    handlePasteImage(e, quillSummary);
                });
                quillSteps.root.addEventListener('paste', function (e) {
                    handlePasteImage(e, quillSteps);
                });
                quillActual.root.addEventListener('paste', function (e) {
                    handlePasteImage(e, quillActual);
                });
                quillExpected.root.addEventListener('paste', function (e) {
                    handlePasteImage(e, quillExpected);
                });

                // API-based dropdown functionality
                // Function to fetch groups from Freshdesk API
                async function fetchGroups() {
                    try {
                        console.log("Fetching groups from Freshdesk API");
                        // Add a UI indicator that API is being called
                        const groupSelect = document.getElementById("groupField");
                        groupSelect.innerHTML = "<option>Loading groups...</option>";

                        const response = await client.request.invokeTemplate("getGroups", {});

                        if (!response || !response.response) {
                            throw new Error("Empty response from groups API");
                        }

                        const groups = JSON.parse(response.response);
                        console.log("Fetched groups:", groups);

                        groupSelect.innerHTML = ""; // Clear existing options

                        // Add a blank option
                        const blankOption = document.createElement("option");
                        blankOption.value = "";
                        blankOption.textContent = "-- Select a Group --";
                        groupSelect.appendChild(blankOption);

                        groups.forEach(group => {
                            const option = document.createElement("option");
                            option.value = group.id;
                            option.textContent = group.name;
                            groupSelect.appendChild(option);

                            // Set Escalations group as default
                            if (group.id === 67000396680) {
                                option.selected = true;
                            }
                        });

                        // After loading groups, instead of fetching agents, 
                        // always use the hardcoded agent list directly
                        loadHardcodedAgents();

                    } catch (error) {
                        console.error("Error fetching groups:", error);
                        console.error(error.stack);
                        // Fallback with hardcoded groups in case of API error
                        loadFallbackGroups();
                    }
                }

                // Function to always load the hardcoded agents instead of using the API
                function loadHardcodedAgents() {
                    console.log("Loading hardcoded agents list");
                    const agents = [
                        { id: 67025683491, name: "Mohammad Azeem" },
                        { id: 67030529218, name: "Jordan Fields" },
                        { id: 67031011668, name: "Suriya Iqbal" },
                        { id: 67040597168, name: "Anson Li" },
                        { id: 67051499418, name: "Drita Lulgjuraj" }
                    ];

                    const agentSelect = document.getElementById("agentField");
                    agentSelect.innerHTML = ""; // Clear existing options

                    // Add a blank option
                    const blankOption = document.createElement("option");
                    blankOption.value = "";
                    blankOption.textContent = "-- Select an Agent --";
                    agentSelect.appendChild(blankOption);

                    agents.forEach(agent => {
                        const option = document.createElement("option");
                        option.value = agent.id;
                        option.textContent = agent.name;
                        agentSelect.appendChild(option);
                    });
                }

                // Modified to use hardcoded agents instead of API
                function fetchAgentsForGroup(groupId) {
                    console.log(`Group selection changed, loading hardcoded agents for group: ${groupId}`);
                    // Always use the hardcoded list regardless of group
                    loadHardcodedAgents();
                }

                // Function to fetch product types
                function fetchProductTypes() {
                    console.log("Using hardcoded product types data");

                    // Set up the hardcoded product hierarchy
                    const productTypeHierarchy = {
                        "Not Product Specific": {},
                        "Assess 360": {},
                        "Benchmark Advance": {
                            "c2026": [],
                            "- c2022": [],
                            "c2022": [],
                            "c2021": [],
                            "c2018": [],
                            "c2017": [],
                            "Florida c2026": [],
                            "Florida": [],
                            "Intervention Resources": [],
                            "Pilots": [
                                "National Pilot",
                                "Units 1-4 Pilot - c2022",
                                "Units 1-4 Pilot c2022",
                                "Units 1-2 Pilot - c2022",
                                "Units 1-2 Pilot c2022",
                                "Units 3-4 Pilot - c2022",
                                "Units 3-4 Pilot c2022",
                                "Units 5-7 Pilot - c2022",
                                "Units 5-7 Pilot c2022",
                                "Units 8-10 Pilot - c2022",
                                "Units 8-10 Pilot c2022",
                                "Unknown"
                            ],
                            "Benchmark Advance": [],
                            "California c2017": [],
                            "California": []
                        },
                        "Benchmark Adelante": {
                            "c2026": [],
                            "c2023": [],
                            "- c2023": [],
                            "c2022": [],
                            "c2018": [],
                            "c2017": [],
                            "Florida c2026": [],
                            "California c2017": [],
                            "Utah": [],
                            "Pilots": [
                                "National Pilot",
                                "Units 1-4 Pilot - c2023",
                                "Units 1-4 Pilot c2023",
                                "Units 1-2 Pilot - c2023",
                                "Units 1-2 Pilot c2023",
                                "Units 3-4 Pilot - c2023",
                                "Units 3-4 Pilot c2023",
                                "Units 5-7 Pilot - c2023",
                                "Units 5-7 Pilot c2023",
                                "Units 8-10 Pilot - c2023",
                                "Units 8-10 Pilot c2023",
                                "Unknown"
                            ],
                            "Adelante": []
                        },
                        "Benchmark Workshop": {},
                        "Benchmark Taller": {},
                        "Ready To Advance": {},
                        "Listos Y Adelante": {
                            "Listos y Adelante Aprendizaje emergente": [],
                            "c2022": [],
                            "Edicion Texas": [],
                            "Listos Y Adelante": []
                        },
                        "Supplemental": {
                            "Foundational Skills Assessment": [],
                            "Oral Reading Records": [],
                            "Registros de lectura en voz alta™": [],
                            "Hello": [],
                            "Writer's Workshop": [],
                            "Reader's Workshop": [],
                            "4,500+ eBook Library": [],
                            "123 Andres": [],
                            "ACT Now!": [],
                            "Advance ALL": [],
                            "Advancing Language Learning": [],
                            "Anchor Comprehension Workshop": [],
                            "Authentic Voices": [],
                            "BEC Decodables": [],
                            "Benchmark Literacy": [],
                            "Benchmark Literacy 2016": [],
                            "Steps to Advance": [],
                            "Benchmark Common Core": [],
                            "Benchmark Phonics": [],
                            "SpiralUp Phonics": [],
                            "BuildUp Phonics": [],
                            "Phonics Intervention": [],
                            "Benchmark Phonics & Word Study Workshop": [],
                            "RIGOR": [],
                            "Benchmark Writer's Universe": [],
                            "Comprehension Skill Bags": [],
                            "Decodable Fluency Builders": [],
                            "Decodable Readers": [],
                            "Dynamite Decodables": [],
                            "Express": [],
                            "MySELF": [],
                            "Represent!": [],
                            "Fonética y gramática": [],
                            "Avanse": [],
                            "Mis libros de fonetica": [],
                            "Soluciones": [],
                            "Sound Spelling Cards and Videos/Transfer Kits": [],
                            "Spring Forward": [],
                            "PD Essentials": [
                                "Collections",
                                "Courses and Books"
                            ],
                            "PD Training: Curriculum Resources": []
                        }
                    };

                    // Create the dropdown structure in the DOM
                    const productContainer = document.querySelector('.form-group:has(#productImpacted)');

                    // Clean out the existing container
                    productContainer.innerHTML = '';

                    // Create label
                    const label = document.createElement('label');
                    label.setAttribute('for', 'productImpacted');
                    label.textContent = 'Product/Program Impacted:';
                    productContainer.appendChild(label);

                    // Create main product select
                    const mainSelect = document.createElement('select');
                    mainSelect.id = 'productImpacted';
                    mainSelect.name = 'productImpacted';

                    // Initialize the dataset property to store the full value
                    mainSelect.dataset.fullValue = '';

                    // Add the blank option
                    const blankOption = document.createElement('option');
                    blankOption.value = '';
                    blankOption.textContent = '-- Select a Product --';
                    mainSelect.appendChild(blankOption);

                    // Add product options
                    Object.keys(productTypeHierarchy).forEach(productName => {
                        const option = document.createElement('option');
                        option.value = productName;
                        option.textContent = productName;
                        mainSelect.appendChild(option);
                    });

                    productContainer.appendChild(mainSelect);

                    // Create a container for the second level dropdown (initially hidden)
                    const secondLevelContainer = document.createElement('div');
                    secondLevelContainer.id = 'secondLevelContainer';
                    secondLevelContainer.style.display = 'none';
                    secondLevelContainer.style.marginTop = '10px';

                    const secondLevelSelect = document.createElement('select');
                    secondLevelSelect.id = 'secondLevelSelect';
                    secondLevelSelect.name = 'secondLevelSelect';
                    secondLevelContainer.appendChild(secondLevelSelect);

                    productContainer.appendChild(secondLevelContainer);

                    // Create a container for the third level dropdown (initially hidden)
                    const thirdLevelContainer = document.createElement('div');
                    thirdLevelContainer.id = 'thirdLevelContainer';
                    thirdLevelContainer.style.display = 'none';
                    thirdLevelContainer.style.marginTop = '10px';

                    const thirdLevelSelect = document.createElement('select');
                    thirdLevelSelect.id = 'thirdLevelSelect';
                    thirdLevelSelect.name = 'thirdLevelSelect';
                    thirdLevelContainer.appendChild(thirdLevelSelect);

                    productContainer.appendChild(thirdLevelContainer);

                    // Add the hint text
                    const hintText = document.createElement('div');
                    hintText.className = 'hint';
                    hintText.textContent = 'Select the product type';
                    productContainer.appendChild(hintText);

                    // Event listener for the main product dropdown
                    mainSelect.addEventListener('change', function () {
                        const selectedProduct = this.value;
                        const secondLevel = productTypeHierarchy[selectedProduct];

                        // Update the full product value to include the first level
                        document.getElementById('productImpacted').dataset.fullValue = selectedProduct;

                        // Reset and hide third level
                        thirdLevelContainer.style.display = 'none';
                        thirdLevelSelect.innerHTML = '';

                        // Reset second level
                        secondLevelSelect.innerHTML = '';

                        if (selectedProduct && Object.keys(secondLevel).length > 0) {
                            // Add a blank option
                            const blankOption = document.createElement('option');
                            blankOption.value = '';
                            blankOption.textContent = '-- Select a Subcategory --';
                            secondLevelSelect.appendChild(blankOption);

                            // Add options for second level
                            Object.keys(secondLevel).forEach(subCategory => {
                                const option = document.createElement('option');
                                option.value = subCategory;
                                option.textContent = subCategory;
                                secondLevelSelect.appendChild(option);
                            });

                            // Show second level
                            secondLevelContainer.style.display = 'block';
                        } else {
                            // Hide second level if no subcategories
                            secondLevelContainer.style.display = 'none';
                        }
                    });

                    // Event listener for the second level dropdown
                    secondLevelSelect.addEventListener('change', function () {
                        const selectedProduct = mainSelect.value;
                        const selectedSubCategory = this.value;
                        const thirdLevel = productTypeHierarchy[selectedProduct][selectedSubCategory];

                        // Update the full product value to include first and second levels
                        document.getElementById('productImpacted').dataset.fullValue =
                            selectedProduct + ' - ' + selectedSubCategory;

                        // Reset third level
                        thirdLevelSelect.innerHTML = '';

                        if (selectedSubCategory && Array.isArray(thirdLevel) && thirdLevel.length > 0) {
                            // Add a blank option
                            const blankOption = document.createElement('option');
                            blankOption.value = '';
                            blankOption.textContent = '-- Select a Specific Item --';
                            thirdLevelSelect.appendChild(blankOption);

                            // Add options for third level
                            thirdLevel.forEach(item => {
                                const option = document.createElement('option');
                                option.value = item;
                                option.textContent = item;
                                thirdLevelSelect.appendChild(option);
                            });

                            // Show third level
                            thirdLevelContainer.style.display = 'block';
                        } else {
                            // Hide third level if no items
                            thirdLevelContainer.style.display = 'none';
                        }
                    });

                    // Event listener for the third level dropdown
                    thirdLevelSelect.addEventListener('change', function () {
                        const selectedProduct = mainSelect.value;
                        const selectedSubCategory = secondLevelSelect.value;
                        const selectedItem = this.value;

                        // Update the full product value to include all three levels
                        document.getElementById('productImpacted').dataset.fullValue =
                            selectedProduct + ' - ' + selectedSubCategory + ' - ' + selectedItem;
                    });

                    // Override the form submission to use the full hierarchical value
                    const originalSubmitHandler = document.getElementById('trackerForm').onsubmit;
                    document.getElementById('trackerForm').onsubmit = function (e) {
                        // Get the full value from all dropdown levels
                        const fullProductValue = document.getElementById('productImpacted').dataset.fullValue;
                        if (fullProductValue) {
                            // Set the product value to the full hierarchical value
                            document.getElementById('productImpacted').value = fullProductValue;
                        }

                        // Call the original handler if it exists
                        if (originalSubmitHandler) {
                            return originalSubmitHandler.call(this, e);
                        }
                    };
                }

                // Replace the API-based fetchProductTypes with our hardcoded version
                // Use the loadFallbackProductTypes as a backup method in case of issues
                function loadFallbackProductTypes() {
                    // Call the main function to ensure we always use the hardcoded version
                    fetchProductTypes();
                }

                // Fallback functions in case the API calls fail
                function loadFallbackGroups() {
                    console.log("Using fallback groups data");
                    const groups = [
                        { id: 67000396680, name: "Escalations" },
                        { id: 67000396681, name: "Support" },
                        { id: 67000396682, name: "Technical" }
                    ];

                    const groupSelect = document.getElementById("groupField");
                    groupSelect.innerHTML = ""; // Clear existing options

                    // Add a blank option
                    const blankOption = document.createElement("option");
                    blankOption.value = "";
                    blankOption.textContent = "-- Select a Group --";
                    groupSelect.appendChild(blankOption);

                    groups.forEach(group => {
                        const option = document.createElement("option");
                        option.value = group.id;
                        option.textContent = group.name;
                        groupSelect.appendChild(option);

                        // Set Escalations group as default
                        if (group.id === 67000396680) {
                            option.selected = true;
                        }
                    });

                    // Load fallback agents for the default group
                    loadFallbackAgents();
                }

                function loadFallbackAgents() {
                    console.log("Using fallback agents data");
                    const agents = [
                        { id: 67025683491, name: "Mohammad Azeem" },
                        { id: 67030529218, name: "Jordan Fields" },
                        { id: 67031011668, name: "Suriya Iqbal" },
                        { id: 67040597168, name: "Anson Li" },
                        { id: 67051499418, name: "Drita Lulgjuraj" }
                    ];

                    const agentSelect = document.getElementById("agentField");
                    agentSelect.innerHTML = ""; // Clear existing options

                    // Add a blank option
                    const blankOption = document.createElement("option");
                    blankOption.value = "";
                    blankOption.textContent = "-- Select an Agent --";
                    agentSelect.appendChild(blankOption);

                    agents.forEach(agent => {
                        const option = document.createElement("option");
                        option.value = agent.id;
                        option.textContent = agent.name;
                        agentSelect.appendChild(option);
                    });
                }

                function loadFallbackProductTypes() {
                    console.log("Using fallback product types data");
                    const productTypes = [
                        { id: "book", name: "Book" },
                        { id: "software", name: "Software" },
                        { id: "digital_content", name: "Digital Content" },
                        { id: "print_content", name: "Print Content" },
                        { id: "assessment", name: "Assessment" }
                    ];

                    const productSelect = document.getElementById("productImpacted");
                    productSelect.innerHTML = ""; // Clear existing options

                    // Add a blank option
                    const blankOption = document.createElement("option");
                    blankOption.value = "";
                    blankOption.textContent = "-- Select a Product --";
                    productSelect.appendChild(blankOption);

                    productTypes.forEach(product => {
                        const option = document.createElement("option");
                        option.value = product.id;
                        option.textContent = product.name;
                        productSelect.appendChild(option);
                    });
                }

                // When group changes, still call the function but it will always load hardcoded agents
                document.getElementById("groupField").addEventListener("change", function () {
                    const groupId = this.value;
                    if (groupId) {
                        // This will now load the hardcoded agents instead of doing an API call
                        fetchAgentsForGroup(parseInt(groupId, 10));
                    } else {
                        // Clear agents dropdown if no group selected
                        const agentSelect = document.getElementById("agentField");
                        agentSelect.innerHTML = "";
                        const blankOption = document.createElement("option");
                        blankOption.value = "";
                        blankOption.textContent = "-- Select a Group First --";
                        agentSelect.appendChild(blankOption);
                    }
                });

                // Initialize the dropdowns when the form loads
                fetchGroups();
                fetchProductTypes();
            }

            initializeClient();
        });
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            setTimeout(function () {
                var createBtn = document.getElementById('createTracker');
                if (createBtn) {
                    createBtn.onclick = function (e) {
                        e.preventDefault();
                        document.getElementById('trackerForm').dispatchEvent(new Event('submit'));
                    };
                }
                var cancelBtn = document.getElementById('cancelTracker');
                if (cancelBtn) {
                    cancelBtn.onclick = function () {
                        if (window.client) {
                            window.client.instance.close();
                        }
                    };
                }
                console.log('Extra event handlers attached to buttons');
            }, 500);
        });
    </script>


</body>

</html>