<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script async src="{{{appclient}}}"></script>
    <link rel="stylesheet" type="text/css" href="styles/dynamic-tracker.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <script src="tracker-config.js"></script>
    <style>
        div.card-header {
            background-color: #2C3E50;
            color: white;
        }

        /* ... existing styles ... */

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 5px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-input {
            margin: 0;
        }

        .checkbox-label {
            margin: 0;
            font-weight: normal;
        }
    </style>
</head>

<body>
    <!-- Loading overlay -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <div class="spinner-text">Creating ticket...</div>
        <div class="progress-status" style="margin-top: 10px; font-size: 12px;"></div>
    </div>

    <div class="tracker-form-container">
        <!-- Debug Button -->
        <div class="debug-container">
            <button id="debugFillForm" class="debug-button">Fill Form with Demo Data</button>
        </div>

        <!-- Form Title -->
        <div class="form-title">
            <h2 id="trackerTitle">Dynamic Tracker</h2>
        </div>

        <!-- Back Button -->
        <div class="back-button-container">
            <fw-button id="backButton" color="secondary" size="small"
                style="cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.2s ease;"
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)';"
                onmouseout="this.style.transform=''; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';">
                <i class="fas fa-arrow-left" style="margin-right: 8px;"></i>Back to Tracker Templates
            </fw-button>
        </div>

        <form id="trackerForm">
            <div class="cards-container" id="dynamicSections">
                <!-- Dynamic sections will be inserted here -->
            </div>

            <!-- Common ticket properties section -->
            <div class="card">
                <div class="card-header">
                    <i class="fas fa-tasks fa-lg section-icon"></i>
                    <h3>Ticket Properties</h3>
                </div>
                <div class="card-body">
                    <div class="form-group">
                        <label for="email" class="required-field">Requester Email</label>
                        <div class="input-with-icon">
                            <input type="email" id="email" name="email" required>
                        </div>
                        <div class="hint"><i class="fas fa-info-circle"></i> This ticket will be created by you (the
                            logged-in agent)</div>
                        <div id="emailStatus" class="email-status"></div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="relatedTickets" class="required-field">Related Ticket IDs</label>
                            <div class="input-with-icon">
                                <input type="text" id="relatedTickets" name="relatedTickets" required>
                            </div>
                            <div class="hint"><i class="fas fa-info-circle"></i> <strong>Required:</strong>
                                Comma-separated ticket IDs (e.g., 1,2,3). At least one ticket ID is required to create a
                                tracker.</div>
                        </div>

                        <div class="form-group">
                            <label for="priority">Priority</label>
                            <select id="priority" name="priority">
                                <option value="1">Low</option>
                                <option value="2">Medium</option>
                                <option value="3">High</option>
                                <option value="4">Urgent</option>
                            </select>
                            <div class="hint"><i class="fas fa-info-circle"></i> Select ticket priority</div>
                        </div>

                        <div class="form-group">
                            <label for="status">Status</label>
                            <select id="status" name="status">
                                <option value="2">Open</option>
                                <option value="3">Pending</option>
                                <option value="4">Resolved</option>
                                <option value="5">Closed</option>
                            </select>
                            <div class="hint"><i class="fas fa-info-circle"></i> Select ticket status</div>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="groupField">Group</label>
                            <select id="groupField" name="groupField">
                                <option>Loading groups...</option>
                            </select>
                            <div class="hint"><i class="fas fa-info-circle"></i> Select a support group</div>
                        </div>

                        <div class="form-group">
                            <label for="agentField">Agent</label>
                            <select id="agentField" name="agentField"></select>
                            <div class="hint"><i class="fas fa-info-circle"></i> Select an agent</div>
                        </div>

                        <div class="form-group">
                            <label for="districtField">District</label>
                            <input type="text" id="districtField" name="districtField" readonly>
                            <div class="hint"><i class="fas fa-info-circle"></i> Auto-populated from source ticket</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Attachments card -->
            <div class="card">
                <div class="card-header">
                    <i class="fas fa-paperclip fa-lg section-icon"></i>
                    <h3>ATTACHMENTS</h3>
                </div>
                <div class="card-body">
                    <div class="attachment-input-container">
                        <label for="screenshots" class="file-upload-button">
                            <i class="fas fa-cloud-upload-alt"></i> Choose files
                            <input type="file" id="screenshots" name="screenshots" multiple class="hidden-file-input">
                        </label>
                        <div class="hint"><i class="fas fa-info-circle"></i> Upload files to include in the ticket (15MB
                            total)</div>
                    </div>
                    <div id="screenshotPreview" class="screenshot-preview"></div>
                    <div id="attachmentCounter" class="attachment-counter"></div>
                </div>
            </div>
            <div style="display: none;">
                <textarea id="description" name="description"></textarea>
                <input type="hidden" id="trackerType" name="trackerType">
            </div>

            <div class="form-actions">
                <fw-button id="cancelTracker" color="secondary" size="small">
                    <i class="fas fa-times" style="margin-right: 8px;"></i>Cancel
                </fw-button>

                <fw-button id="createTracker" color="primary" type="submit" size="small" style="margin-left: 10px;">
                    <i class="fas fa-check" style="margin-right: 8px;"></i>Create Tracker
                </fw-button>
            </div>
    </div>
    </div>
    </form>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            console.log("Dynamic tracker template initializing...");
            // Get the tracker type from URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const trackerType = urlParams.get('type') || 'blank';

            // Store tracker type in hidden field
            document.getElementById('trackerType').value = trackerType;

            // Log the tracker type
            console.log("Loading tracker template:", trackerType);

            // Get the config for this tracker type
            const config = TRACKER_CONFIGS[trackerType] || {
                title: "Blank Tracker",
                icon: "fa-file",
                description: "Generic tracker template",
                sections: []
            };

            // If this is the SIM Assignment template, ensure there's no attachments card
            if (trackerType === 'sim-assignment') {
                // Filter out any attachments section that might have been added
                config.sections = config.sections.filter(section => section.id !== 'attachments');
            }

            // Set the page title
            document.getElementById('trackerTitle').innerHTML = `<i class="fas ${config.icon} mr-2"></i> ${config.title}`;
            document.title = config.title;

            // Build dynamic sections based on configuration
            buildDynamicSections(config);

            // Initialize the app
            initializeTrackerApp(trackerType, config);
        });

        function buildDynamicSections(config) {
            const container = document.getElementById('dynamicSections');

            // Clear any existing content
            container.innerHTML = '';

            // Add each section defined in the config
            config.sections.forEach(section => {
                // Skip the "attachments" section for the SIM Assignment template
                if (config.title === "SIM Assignment Tracker" && section.id === "attachments") {
                    return; // Skip this section
                }

                const sectionHtml = buildSection(section);
                container.innerHTML += sectionHtml;
            });
        }

        function buildSection(section) {
            let html = `
                <div class="card" id="section-${section.id}">
                    <div class="card-header">
                        <i class="fas ${section.icon} fa-lg section-icon"></i>
                        <h3>${section.title}</h3>
                    </div>
                    <div class="card-body">
                        ${buildFields(section.fields)}
                    </div>
                </div>
            `;
            return html;
        }

        function buildFields(fields) {
            let html = '';

            fields.forEach(field => {
                html += `<div class="form-group">`;

                // Add label if not a richtext editor with empty label
                if (!(field.type === 'richtext' && field.label === '')) {
                    html += `<label for="${field.id}" ${field.required ? 'class="required-field"' : ''}>${field.label}</label>`;
                }

                // Add the appropriate input based on field type
                switch (field.type) {
                    case 'text':
                        html += `<input type="text" id="${field.id}" name="${field.id}" ${field.required ? 'required' : ''} ${field.placeholder ? `placeholder="${field.placeholder}"` : ''}>`;
                        break;

                    case 'email':
                        html += `<input type="email" id="${field.id}" name="${field.id}" ${field.required ? 'required' : ''}>`;
                        break;

                    case 'textarea':
                        html += `<textarea id="${field.id}" name="${field.id}" rows="4" ${field.required ? 'required' : ''}></textarea>`;
                        break;

                    case 'date':
                        html += `<input type="date" id="${field.id}" name="${field.id}" ${field.required ? 'required' : ''}>`;
                        break;

                    case 'select':
                        html += `
                            <select id="${field.id}" name="${field.id}" ${field.required ? 'required' : ''}>
                                ${field.options.map(option => `<option value="${option}">${option}</option>`).join('')}
                            </select>
                        `;
                        break;

                    case 'richtext':
                        html += `
                            <div class="quill-editor-container">
                                <div id="${field.id}Editor" style="min-height: 120px;"></div>
                                <textarea id="${field.id}" name="${field.id}" style="display: none;"></textarea>
                            </div>
                        `;
                        break;

                    case 'checkboxes':
                        html += `<div class="checkbox-group">`;
                        field.options.forEach(option => {
                            html += `
                                <div class="checkbox-item">
                                    <input type="checkbox" 
                                        id="${option.id}" 
                                        name="${field.id}" 
                                        value="${option.id}"
                                        class="checkbox-input">
                                    <label for="${option.id}" class="checkbox-label">${option.label}</label>
                                </div>
                            `;
                        });
                        html += `</div>`;
                        break;

                    default:
                        html += `<input type="text" id="${field.id}" name="${field.id}" ${field.required ? 'required' : ''}>`;
                }

                // Add hint if provided
                if (field.hint) {
                    html += `<div class="hint"><i class="fas fa-info-circle"></i> ${field.hint}</div>`;
                }

                html += `</div>`;
            });

            return html;
        }

        function initializeTrackerApp(trackerType, config) {
            const trackerApp = new TrackerApp(trackerType, config);
            window.trackerApp = trackerApp;
            trackerApp.init();
        }

        class TrackerApp {
            constructor(trackerType, config) {
                this.trackerType = trackerType;
                this.config = config;
                this.client = null;
                this.quillEditors = {};
                this.aggregatedScreenshotFiles = [];
                this.ticketData = {
                    isVip: false,
                    districtName: '',
                    currentTicketId: null,
                    requesterEmail: '',
                    ticketRequesterEmail: ''
                };
            }

            async init() {
                try {
                    console.log('Initializing TrackerApp');
                    await this.initClient();

                    // Move debugDistrictFields to the end
                    // this.debugDistrictFields(); - REMOVE THIS LINE

                    this.initEventListeners();
                    this.initQuillEditors();
                    this.initFormData();
                    await this.loadInitialData();

                    // Add hidden description field if it doesn't exist
                    this.ensureHiddenFields();

                    // Set up custom file uploaders
                    this.setupCustomFileUploaders();

                    // Load data from localStorage based on tracker type
                    this.loadDataFromStorage();

                    // Hide specified ticket property fields
                    this.hideTicketPropertyFields();

                    // Remove the Attachments card at the bottom
                    this.removeBottomAttachmentsCard();

                    // Move the debug to the end, after all initialization is complete
                    this.debugDistrictFields();

                    // Add this at the end of the method
                    // Special handling for Achievement Levels tracker to ensure district name is populated
                    if (this.trackerType === 'sim-achievement-levels') {
                        setTimeout(() => {
                            // Ensure district name is populated by checking multiple sources
                            const districtField = document.getElementById('districtField');
                            const districtNameField = document.getElementById('districtName');

                            if (districtField && districtField.value && districtNameField) {
                                // If districtField has value, use it
                                if (districtField && districtField.value) {
                                    districtNameField.value = districtField.value;
                                    console.log(`Set districtName from districtField: ${districtField.value}`);
                                }
                                // If not, try to get from ticket data
                                else if (this.ticketData && this.ticketData.districtName) {
                                    districtNameField.value = this.ticketData.districtName;
                                    console.log(`Set districtName from ticketData: ${this.ticketData.districtName}`);
                                }

                                // Update the formatted subject
                                this.updateAchievementLevelsSubject();
                            }
                        }, 1000); // Delay to ensure everything else is loaded
                    }

                    // Special handling for Achievement Levels tracker
                    if (this.trackerType === 'sim-achievement-levels') {
                        // Wait a bit to let other initialization processes finish
                        setTimeout(async () => {
                            try {
                                // Get VIP status directly from the source ticket
                                const relatedTicketsField = document.getElementById('relatedTickets');
                                if (relatedTicketsField && relatedTicketsField.value) {
                                    const sourceTicketId = parseInt(relatedTicketsField.value.split(',')[0], 10);
                                    if (!isNaN(sourceTicketId)) {
                                        console.log("Getting VIP status from ticket", sourceTicketId);

                                        try {
                                            const response = await this.client.request.invokeTemplate("getTicketDetails", {
                                                context: { ticketId: sourceTicketId }
                                            });

                                            const ticketData = JSON.parse(response.response);
                                            if (ticketData && ticketData.custom_fields) {
                                                // Check for VIP status in custom fields
                                                const vipFields = ['cf_vip', 'vip', 'cf_vip_status', 'vip_customer', 'cf_is_vip'];
                                                for (const field of vipFields) {
                                                    if (ticketData.custom_fields[field] !== undefined) {
                                                        const fieldValue = ticketData.custom_fields[field];
                                                        const isVip = fieldValue === true ||
                                                            fieldValue === "true" ||
                                                            fieldValue === "Yes";

                                                        console.log(`VIP status found in ${field}:`, isVip);
                                                        this.ticketData.isVip = isVip;

                                                        // Also set the checkbox
                                                        const vipCheckbox = document.getElementById('hiddenVIPStatus');
                                                        if (vipCheckbox) {
                                                            vipCheckbox.checked = isVip;
                                                            console.log('Set hidden VIP checkbox to:', isVip);
                                                        }

                                                        // If VIP, set priority to HIGH (priority 3)
                                                        if (isVip) {
                                                            console.log("Setting priority to HIGH (3) based on VIP status");
                                                            // Set the priority in the form
                                                            const priorityField = document.getElementById('priority');
                                                            if (priorityField) {
                                                                priorityField.value = "3"; // 3 = HIGH priority
                                                            }
                                                            // Also store in ticketData for when we create the ticket
                                                            this.ticketData.priority = 3;

                                                            // Make sure the VIP status is reflected in the subject
                                                            this.updateAchievementLevelsSubject();
                                                        }

                                                        break;
                                                    }
                                                }
                                            }
                                        } catch (error) {
                                            console.error("Error getting source ticket VIP status:", error);
                                        }
                                    }
                                }

                                // After all data gathering, update the subject with proper VIP status
                                this.updateAchievementLevelsSubject();

                            } catch (error) {
                                console.error("Error in Achievement Levels special handling:", error);
                            }
                        }, 1000);
                    }

                    console.log('TrackerApp initialized successfully');

                    // Add this to your init method
                    await this.inspectDistrictDropdownField();
                } catch (error) {
                    console.error('Failed to initialize TrackerApp:', error);
                    this.showError('Failed to initialize app. Please try again.');
                }
            }

            // Add this new method
            removeBottomAttachmentsCard() {
                // Find the Attachments card at the bottom
                const cards = document.querySelectorAll('.card');
                cards.forEach(card => {
                    const header = card.querySelector('.card-header h3');
                    if (header && header.textContent.trim() === 'ATTACHMENTS') {
                        // This is the bottom attachments card, remove it
                        card.remove();
                        console.log('Removed bottom Attachments card');
                    }
                });
            }

            // Add this new method to hide ticket property fields
            hideTicketPropertyFields() {
                // Fields to hide: status, priority, group, related ticket IDs, requester email
                const fieldsToHide = [
                    { id: 'status', parent: 'form-group' },
                    { id: 'priority', parent: 'form-group' },
                    { id: 'groupField', parent: 'form-group' },
                    { id: 'relatedTickets', parent: 'form-group' },
                    { id: 'email', parent: 'form-group' }
                ];

                fieldsToHide.forEach(field => {
                    const element = document.getElementById(field.id);
                    if (element) {
                        // Find the parent container to hide the entire field including label
                        const parent = this.findParentWithClass(element, field.parent);
                        if (parent) {
                            parent.style.display = 'none';
                            console.log(`Hid ${field.id} field`);
                        } else {
                            // If parent not found, just hide the element itself
                            element.style.display = 'none';
                            console.log(`Hid ${field.id} element (parent not found)`);
                        }
                    } else {
                        console.warn(`Could not find element with id: ${field.id}`);
                    }
                });
            }

            initFormData() {
                console.log('Initializing form data');
                // This can be empty, but must exist as a function
            }

            async initClient() {
                // Initialize client code (same as in existing app)
                return new Promise((resolve, reject) => {
                    let attempts = 0;
                    const maxAttempts = 10;

                    const tryInit = () => {
                        attempts++;
                        console.log(`Attempt ${attempts} to initialize Freshworks client`);

                        if (typeof client !== 'undefined') {
                            this.client = client;
                            resolve(client);
                        } else if (typeof app !== 'undefined') {
                            app.initialized().then(clientObj => {
                                this.client = clientObj;
                                resolve(clientObj);
                            }).catch(reject);
                        } else if (typeof window.frsh !== 'undefined' && window.frsh.init) {
                            window.frsh.init().then(clientObj => {
                                this.client = clientObj;
                                resolve(clientObj);
                            }).catch(reject);
                        } else if (attempts < maxAttempts) {
                            setTimeout(tryInit, 100);
                        } else {
                            reject(new Error('Could not initialize client after multiple attempts'));
                        }
                    };

                    tryInit();
                });
            }

            initQuillEditors() {
                console.log('Initializing Quill editors');
                // Clear any previous editors
                this.quillEditors = {};

                // Initialize Quill editors based on config
                this.config.sections.forEach(section => {
                    section.fields.forEach(field => {
                        if (field.type === 'richtext') {
                            const editorId = `${field.id}Editor`;
                            const editorElement = document.getElementById(editorId);

                            if (editorElement) {
                                // Make sure to set min-height directly on the element
                                editorElement.style.minHeight = '120px';

                                try {
                                    // Define a custom image handler for the toolbar
                                    const customImageHandler = () => {
                                        const input = document.createElement('input');
                                        input.setAttribute('type', 'file');
                                        input.setAttribute('accept', 'image/*');
                                        input.click();

                                        input.onchange = () => {
                                            if (input.files && input.files[0]) {
                                                const file = input.files[0];

                                                // Show loading indicator
                                                const range = editor.getSelection(true);
                                                editor.insertText(range.index, "Uploading image... ", { italic: true, color: '#999' });
                                                const placeholderIndex = range.index;

                                                // Upload to ImgBB
                                                this.uploadImageToImgBB(file).then(imageUrl => {
                                                    // Delete the placeholder text
                                                    editor.deleteText(placeholderIndex, "Uploading image... ".length);

                                                    // Insert the image
                                                    editor.insertEmbed(placeholderIndex, 'image', imageUrl);
                                                    editor.setSelection(placeholderIndex + 1);
                                                }).catch(error => {
                                                    console.error('Error uploading image:', error);

                                                    // Replace placeholder with error message
                                                    editor.deleteText(placeholderIndex, "Uploading image... ".length);
                                                    editor.insertText(placeholderIndex, "⚠️ Image upload failed ", { italic: true, color: 'red' });
                                                });
                                            }
                                        };
                                    };

                                    // Initialize Quill with simplified toolbar
                                    const editor = new Quill(`#${editorId}`, {
                                        theme: 'snow',
                                        placeholder: `Enter ${field.id.replace(/([A-Z])/g, ' $1').toLowerCase()}...`,
                                        modules: {
                                            toolbar: {
                                                container: [
                                                    ['bold', 'italic'],                        // Bold and italic
                                                    [{ 'color': [] }, { 'background': [] }],   // Color and highlight
                                                    [{ 'align': [] }],                         // Alignment
                                                    ['link', 'image']                          // Link and image
                                                ],
                                                handlers: {
                                                    'image': customImageHandler.bind(this)
                                                }
                                            }
                                        }
                                    });

                                    // Ensure the editor is properly enabled
                                    editor.enable();

                                    // Store reference in our global map
                                    this.quillEditors[field.id] = editor;

                                    // Add paste image handling
                                    editor.root.addEventListener('paste', e => this.handlePasteImage(e, editor));

                                    // Add drop handling for images
                                    editor.root.addEventListener('drop', e => this.handleDropImage(e, editor));

                                    console.log(`Initialized Quill editor for ${field.id}`);
                                } catch (error) {
                                    console.error(`Error initializing Quill editor for ${field.id}:`, error);
                                }
                            } else {
                                console.warn(`Editor element not found for ${field.id}`);
                            }
                        }
                    });
                });

                // Convert textareas to Quill editors
                this.convertTextareasToQuill();
            }

            // Add this new method to convert textareas to Quill editors
            convertTextareasToQuill() {
                // Find all textareas that aren't already hidden or part of a Quill editor
                const textareas = document.querySelectorAll('textarea:not([style*="display: none"]):not([id$="Editor"])');

                textareas.forEach(textarea => {
                    // Skip if already processed or if the ID is "description"
                    if (textarea.id === 'description' || this.quillEditors[textarea.id]) {
                        return;
                    }

                    console.log(`Converting textarea ${textarea.id} to Quill editor`);

                    // Create container for the editor
                    const container = document.createElement('div');
                    container.className = 'quill-editor-container';

                    // Create the editor div
                    const editorDiv = document.createElement('div');
                    editorDiv.id = `${textarea.id}Editor`;
                    editorDiv.style.minHeight = '120px';

                    // Add the editor div to the container
                    container.appendChild(editorDiv);

                    // Replace the textarea with the container
                    textarea.parentNode.replaceChild(container, textarea);

                    // Move the textarea into the container (hidden)
                    textarea.style.display = 'none';
                    container.appendChild(textarea);

                    // Initialize the Quill editor
                    try {
                        const editor = new Quill(`#${textarea.id}Editor`, {
                            theme: 'snow',
                            placeholder: textarea.placeholder || `Enter ${textarea.id.replace(/([A-Z])/g, ' $1').toLowerCase()}...`,
                            modules: {
                                toolbar: {
                                    container: [
                                        ['bold', 'italic'],                      // Bold and italic
                                        [{ 'color': [] }, { 'background': [] }], // Color and highlight
                                        [{ 'align': [] }],                       // Alignment
                                        ['link', 'image']                        // Link and image
                                    ]
                                }
                            }
                        });

                        // Set initial content if textarea had value
                        if (textarea.value) {
                            editor.root.innerHTML = textarea.value;
                        }

                        // Store reference to the editor
                        this.quillEditors[textarea.id] = editor;

                        // Update textarea when editor changes
                        editor.on('text-change', () => {
                            textarea.value = editor.root.innerHTML;
                        });
                    } catch (error) {
                        console.error(`Error converting textarea ${textarea.id} to Quill:`, error);
                    }
                });
            }

            initEventListeners() {
                console.log('Setting up event listeners');

                // Back button
                const backButton = document.getElementById('backButton');
                if (backButton) {
                    backButton.addEventListener('click', () => {
                        window.location.href = 'template-selector.html';
                    });
                }

                // Cancel button
                const cancelButton = document.getElementById('cancelTracker');
                if (cancelButton) {
                    cancelButton.addEventListener('click', () => {
                        window.location.href = 'template-selector.html';
                    });
                }

                // Submit form - Fix for Create Tracker button
                const form = document.getElementById('trackerForm');
                if (form) {
                    form.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleFormSubmit();
                    });
                }

                // Also add direct event handler to the createTracker button
                const createTrackerButton = document.getElementById('createTracker');
                if (createTrackerButton) {
                    createTrackerButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        console.log('Create Tracker button clicked');
                        this.handleFormSubmit();
                    });
                }

                // File input change
                const fileInput = document.getElementById('screenshots');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        this.handleFileInputChange(e);
                    });
                }

                // Debug button
                const debugButton = document.getElementById('debugFillForm');
                if (debugButton) {
                    debugButton.addEventListener('click', () => {
                        this.fillFormWithDemoData();
                    });
                }

                // Add a debugging button to the debug-container to show user data
                const debugContainer = document.querySelector('.debug-container');
                if (debugContainer) {
                    // First button - Check User Data
                    const checkUserButton = document.createElement('button');
                    checkUserButton.className = 'debug-button';
                    checkUserButton.textContent = 'Check User Data';
                    checkUserButton.style.marginLeft = '10px';
                    checkUserButton.addEventListener('click', async () => {
                        try {
                            const userData = await this.client.data.get("loggedInUser");
                            console.log("Current user data:", userData);

                            // Show more detailed info in an alert
                            let emailInfo = "No email found";
                            if (userData && userData.loggedInUser && userData.loggedInUser.email) {
                                emailInfo = userData.loggedInUser.email;
                            }

                            alert(`User email: ${emailInfo}\n\nSee console for full user data`);
                        } catch (error) {
                            console.error("Error checking user data:", error);
                            alert("Error checking user data. See console for details.");
                        }
                    });

                    debugContainer.appendChild(checkUserButton);

                    // Second button - Check District Data
                    // REMOVED: const debugContainer = document.querySelector('.debug-container');
                    // Just use the existing debugContainer variable
                    const checkDistrictButton = document.createElement('button');
                    checkDistrictButton.className = 'debug-button';
                    checkDistrictButton.textContent = 'Check District Data';
                    checkDistrictButton.style.marginLeft = '10px';
                    checkDistrictButton.addEventListener('click', () => {
                        // Get current ticket data to check district field
                        this.client.data.get("ticket").then(ticketData => {
                            console.group("District Field Debugging");
                            console.log("Current ticket data:", ticketData);

                            // Check custom fields for district
                            if (ticketData && ticketData.ticket && ticketData.ticket.custom_fields) {
                                console.log("Custom fields:", ticketData.ticket.custom_fields);

                                // Log any field that might contain district information
                                Object.keys(ticketData.ticket.custom_fields).forEach(key => {
                                    if (key.toLowerCase().includes('district')) {
                                        console.log(`Potential district field: ${key} = ${ticketData.ticket.custom_fields[key]}`);
                                    }
                                });
                            }

                            // Check if district field in DOM is populated
                            const districtField = document.getElementById('districtField');
                            console.log("District field element:", districtField);
                            console.log("District field value:", districtField ? districtField.value : "Element not found");

                            console.groupEnd();

                            alert("District data check complete. See console for details.");
                        }).catch(error => {
                            console.error("Error checking district data:", error);
                            alert("Error checking district data. See console for details.");
                        });
                    });

                    debugContainer.appendChild(checkDistrictButton);
                }

                // Add a "Use My Email" button next to the email field
                const emailField = document.getElementById('email');
                if (emailField) {
                    const emailFieldParent = emailField.parentElement;

                    // Create a button container
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.marginTop = '8px';

                    // Create the button
                    const useMyEmailButton = document.createElement('button');
                    useMyEmailButton.type = 'button';
                    useMyEmailButton.className = 'email-input-button';
                    useMyEmailButton.innerHTML = '<i class="fas fa-user"></i> Use My Email';
                    useMyEmailButton.style.backgroundColor = '#f0f0f0';
                    useMyEmailButton.style.border = '1px solid #ddd';
                    useMyEmailButton.style.borderRadius = '4px';
                    useMyEmailButton.style.padding = '5px 10px';
                    useMyEmailButton.style.cursor = 'pointer';
                    useMyEmailButton.style.marginRight = '8px';

                    // Add click handler
                    useMyEmailButton.addEventListener('click', () => {
                        const emailInput = prompt("Enter your email address:", emailField.value || "");
                        if (emailInput && emailInput.trim()) {
                            emailField.value = emailInput.trim();
                        }
                    });

                    buttonContainer.appendChild(useMyEmailButton);

                    // Insert after email field
                    emailFieldParent.appendChild(buttonContainer);
                }

                // Add dynamic subject line builder for Assembly template
                if (this.trackerType === 'assembly') {
                    const subjectFields = ['xcode', 'application', 'specificIssue', 'gradesImpacted'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateFormattedSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateFormattedSubject();
                    }
                }

                // Add dynamic subject line builder for SEDCUST template
                if (this.trackerType === 'sedcust') {
                    const subjectFields = ['xcode', 'application', 'resourcePath', 'specificIssue'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateSedcustSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateSedcustSubject();
                    }
                }

                // Add dynamic subject line builder for SIM Assignment template
                if (this.trackerType === 'sim-assignment') {
                    const subjectFields = ['isVIP', 'districtName', 'application', 'specificIssue', 'userRole'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateSimAssignmentSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateSimAssignmentSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateSimAssignmentSubject();
                    }
                }

                // Add dynamic subject line builder for SIM Assessment Reports template
                if (this.trackerType === 'sim-assessment-reports') {
                    const subjectFields = ['isVIP', 'districtName', 'application', 'specificIssue', 'userRole'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateSIMAssessmentReportsSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateSIMAssessmentReportsSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateSIMAssessmentReportsSubject();
                    }
                }

                // Add dynamic subject line builder for SIM Achievement Levels template
                if (this.trackerType === 'sim-achievement-levels') {
                    const subjectFields = ['isVIP', 'districtName'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateAchievementLevelsSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateAchievementLevelsSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateAchievementLevelsSubject();
                    }
                }

                // Set up conditional fields
                this.setupConditionalFields();

                // Initialize HAR file attached dropdown behavior for both templates
                if (this.trackerType === 'sim-assignment' || this.trackerType === 'sim-assessment-reports') {
                    const harFileAttached = document.getElementById('harFileAttached');
                    const harFileReason = document.getElementById('harFileReason');

                    if (harFileAttached && harFileReason) {
                        // Set initial state
                        const harFileReasonContainer = this.findParentWithClass(harFileReason, 'form-group');

                        if (harFileAttached.value === 'No') {
                            if (harFileReasonContainer) {
                                harFileReasonContainer.style.display = 'block';

                                // Add visual indication that the field is now required
                                const label = harFileReasonContainer.querySelector('label');
                                if (label) {
                                    label.classList.add('required-field');
                                }
                            }
                        } else {
                            if (harFileReasonContainer) {
                                harFileReasonContainer.style.display = 'none';
                            }
                        }

                        // Add change listener
                        harFileAttached.addEventListener('change', function () {
                            // Get the container again inside this scope
                            const reasonContainer = document.getElementById('harFileReason') ?
                                window.trackerApp.findParentWithClass(document.getElementById('harFileReason'), 'form-group') : null;

                            if (this.value === 'No') {
                                if (reasonContainer) {
                                    reasonContainer.style.display = 'block';

                                    // Add visual indication that the field is now required
                                    const label = reasonContainer.querySelector('label');
                                    if (label) {
                                        label.classList.add('required-field');
                                    }
                                }

                                // Hide the uploader container
                                const harUploaderContainer = document.getElementById('harUploaderContainer');
                                if (harUploaderContainer) harUploaderContainer.style.display = 'none';
                            } else {
                                if (reasonContainer) {
                                    reasonContainer.style.display = 'none';

                                    // Remove the required indication
                                    const label = reasonContainer.querySelector('label');
                                    if (label) {
                                        label.classList.remove('required-field');
                                    }
                                }

                                // Show the uploader container 
                                const harUploaderContainer = document.getElementById('harUploaderContainer');
                                if (harUploaderContainer) harUploaderContainer.style.display = 'block';
                            }
                        });
                    }
                }

                // Update hint for related tickets
                const relatedTicketsField = document.getElementById('relatedTickets');
                if (relatedTicketsField) {
                    const hintDiv = relatedTicketsField.parentElement.nextElementSibling;
                    if (hintDiv && hintDiv.classList.contains('hint')) {
                        hintDiv.innerHTML = '<i class="fas fa-info-circle"></i> <strong>Required:</strong> ' +
                            'Currently includes the source ticket ID. Add more ticket IDs separated by commas if needed.';
                    }
                }

                // Add Achievement Levels specific handlers
                if (this.trackerType === 'sim-achievement-levels') {
                    // Ensure formattedSubject is updated with the hidden fields
                    this.updateAchievementLevelsSubject();

                    // Set up the smartsheet file uploader
                    this.setupSmartsheetUploader();

                    // Hide the isVIP field (stored in localStorage for subject formatting)
                    const hiddenFields = ['isVIP'];
                    hiddenFields.forEach(fieldId => {
                        const field = document.getElementById(fieldId);
                        if (field) {
                            const parent = this.findParentWithClass(field, 'form-group');
                            if (parent) parent.style.display = 'none';
                        }
                    });

                    // Add a periodic check to ensure VIP status remains in the subject line
                    this.startVipStatusMonitor();
                }

                // In your initEventListeners method, add this to create a hidden VIP status checkbox
                const hiddenContainer = document.querySelector('div[style="display: none;"]') ||
                    document.createElement('div');

                if (!hiddenContainer.parentNode) {
                    hiddenContainer.style.display = 'none';
                    document.body.appendChild(hiddenContainer);
                }

                // Create hidden VIP checkbox if it doesn't exist
                if (!document.getElementById('hiddenVIPStatus')) {
                    const vipCheckbox = document.createElement('input');
                    vipCheckbox.type = 'checkbox';
                    vipCheckbox.id = 'hiddenVIPStatus';
                    vipCheckbox.name = 'hiddenVIPStatus';
                    hiddenContainer.appendChild(vipCheckbox);
                }

                // Add dynamic subject line builder for SIM Library View template
                if (this.trackerType === 'sim-library-view') {
                    const subjectFields = ['isVIP', 'districtName', 'application', 'specificIssue', 'userRole'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateSimLibraryViewSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateSimLibraryViewSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateSimLibraryViewSubject();
                    }
                }

                // Add this to the initEventListeners method, where the other template-specific subject handlers are
                if (this.trackerType === 'sim-fsa') {
                    const subjectFields = ['isVIP', 'districtName', 'application', 'specificIssue', 'userRole'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateSimFsaSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateSimFsaSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateSimFsaSubject();
                    }
                }

                // Add to the initEventListeners method
                if (this.trackerType === 'sim-assignment' ||
                    this.trackerType === 'sim-assessment-reports' ||
                    this.trackerType === 'sim-fsa' ||
                    this.trackerType === 'sim-library-view') {

                    // Handle "All Users" checkbox
                    const allUsersCheckbox = document.querySelector('input[value="allUsers"]');
                    const individualRoleCheckboxes = document.querySelectorAll('input[name="userRole"]:not([value="allUsers"])');

                    if (allUsersCheckbox) {
                        allUsersCheckbox.addEventListener('change', (e) => {
                            // If "All Users" is checked, uncheck other options
                            if (e.target.checked) {
                                individualRoleCheckboxes.forEach(cb => {
                                    cb.checked = false;
                                    cb.disabled = true;
                                });
                            } else {
                                individualRoleCheckboxes.forEach(cb => {
                                    cb.disabled = false;
                                });
                            }
                            this.updateSubjectLine();
                        });
                    }

                    // Handle individual role checkboxes
                    individualRoleCheckboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', () => {
                            // If all individual roles are selected, check "All Users" instead
                            const allIndividualSelected = Array.from(individualRoleCheckboxes)
                                .every(cb => cb.checked);

                            if (allIndividualSelected && allUsersCheckbox) {
                                allUsersCheckbox.checked = true;
                                individualRoleCheckboxes.forEach(cb => {
                                    cb.checked = false;
                                    cb.disabled = true;
                                });
                            }
                            this.updateSubjectLine();
                        });
                    });
                }
            }

            updateFormattedSubject() {
                const xcodeValue = document.getElementById('xcode')?.value || '';
                const applicationValue = document.getElementById('application')?.value || '';
                const specificIssueValue = document.getElementById('specificIssue')?.value || '';
                const gradesImpactedValue = document.getElementById('gradesImpacted')?.value || '';

                const formattedSubject =
                    `${xcodeValue} | ${applicationValue} | ${specificIssueValue} : ${gradesImpactedValue}`;

                const formattedSubjectField = document.getElementById('formattedSubject');
                if (formattedSubjectField) {
                    formattedSubjectField.value = formattedSubject;

                    // Also update the hidden subject field to ensure it's submitted correctly
                    const subjectField = document.getElementById('subject');
                    if (subjectField) {
                        subjectField.value = formattedSubject;
                    }
                }
            }

            updateSedcustSubject() {
                const xcodeValue = document.getElementById('xcode')?.value || '';
                const applicationValue = document.getElementById('application')?.value || '';
                const resourcePathValue = document.getElementById('resourcePath')?.value || '';
                const specificIssueValue = document.getElementById('specificIssue')?.value || '';

                // Keep first two as pipes, only last one as dash
                const formattedSubject =
                    `${xcodeValue} | ${applicationValue} | ${resourcePathValue} - ${specificIssueValue}`;

                const formattedSubjectField = document.getElementById('formattedSubject');
                if (formattedSubjectField) {
                    formattedSubjectField.value = formattedSubject;

                    // Also update the hidden subject field to ensure it's submitted correctly
                    const subjectField = document.getElementById('subject');
                    if (subjectField) {
                        subjectField.value = formattedSubject;
                    }
                }
            }

            // Replace the existing formatUserRoles method with this updated version
            formatUserRoles(selectedRoles) {
                // If "All Users" is selected, return that
                if (selectedRoles.includes('allUsers')) {
                    return "All Users";
                }

                // If all three individual roles are selected, return "All Users"
                if (selectedRoles.includes('students') &&
                    selectedRoles.includes('teachers') &&
                    selectedRoles.includes('admin')) {
                    return "All Users";
                }

                // Format multiple selections
                const roleMap = {
                    'students': 'Students',
                    'teachers': 'Teachers',
                    'admin': 'Admin'
                };

                const selectedLabels = selectedRoles
                    .filter(role => role !== 'allUsers')
                    .map(role => roleMap[role]);

                // At this point, we should only have 1 or 2 roles
                // Join with & if there are 2 roles
                if (selectedLabels.length === 2) {
                    return selectedLabels.join(' & ');
                }

                // Return single role
                return selectedLabels[0] || '';
            }

            // Update the subject line methods for each template
            updateSimAssignmentSubject() {
                const isVIP = document.getElementById('isVIP')?.value || 'No';
                const vipPrefix = isVIP === "Yes" ? "VIP * " : "";
                const districtValue = document.getElementById('districtName')?.value || '';
                const applicationValue = document.getElementById('application')?.value || '';
                const specificIssueValue = document.getElementById('specificIssue')?.value || '';

                // Get all checked user role checkboxes
                const userRoleCheckboxes = document.querySelectorAll('input[name="userRole"]:checked');
                const selectedRoles = Array.from(userRoleCheckboxes).map(cb => cb.value);
                const formattedUserRole = this.formatUserRoles(selectedRoles);

                const formattedSubject =
                    `${vipPrefix}${districtValue} | ${applicationValue} - ${specificIssueValue} for ${formattedUserRole}`;

                const formattedSubjectField = document.getElementById('formattedSubject');
                if (formattedSubjectField) {
                    formattedSubjectField.value = formattedSubject;

                    // Also update the hidden subject field
                    const subjectField = document.getElementById('subject');
                    if (subjectField) {
                        subjectField.value = formattedSubject;
                    }
                }
            }

            // Update the other template methods similarly
            updateSIMAssessmentReportsSubject() {
                // Same pattern as above with VIP * spacing and user role formatting
                const isVIP = document.getElementById('isVIP')?.value || 'No';
                const vipPrefix = isVIP === "Yes" ? "VIP * " : "";
                const districtValue = document.getElementById('districtName')?.value || '';
                const applicationValue = document.getElementById('application')?.value || '';
                const specificIssueValue = document.getElementById('specificIssue')?.value || '';

                // Get all checked user role checkboxes
                const userRoleCheckboxes = document.querySelectorAll('input[name="userRole"]:checked');
                const selectedRoles = Array.from(userRoleCheckboxes).map(cb => cb.value);
                const formattedUserRole = this.formatUserRoles(selectedRoles);

                const formattedSubject =
                    `${vipPrefix}${districtValue} | ${applicationValue} - ${specificIssueValue} for ${formattedUserRole}`;

                const formattedSubjectField = document.getElementById('formattedSubject');
                if (formattedSubjectField) {
                    formattedSubjectField.value = formattedSubject;

                    // Also update the hidden subject field
                    const subjectField = document.getElementById('subject');
                    if (subjectField) {
                        subjectField.value = formattedSubject;
                    }
                }
            }

            updateSimLibraryViewSubject() {
                const isVIP = document.getElementById('isVIP')?.value || 'No';
                const vipPrefix = isVIP === "Yes" ? "VIP * " : "";
                const districtValue = document.getElementById('districtName')?.value || '';
                const applicationValue = document.getElementById('application')?.value || '';
                const specificIssueValue = document.getElementById('specificIssue')?.value || '';

                // Get all checked user role checkboxes
                const userRoleCheckboxes = document.querySelectorAll('input[name="userRole"]:checked');
                const selectedRoles = Array.from(userRoleCheckboxes).map(cb => cb.value);
                const formattedUserRole = this.formatUserRoles(selectedRoles);

                // Only add the "for" part if there are selected roles
                const userRolePart = formattedUserRole ? ` for ${formattedUserRole}` : '';

                const formattedSubject =
                    `${vipPrefix}${districtValue} | ${applicationValue} - ${specificIssueValue}${userRolePart}`;

                const formattedSubjectField = document.getElementById('formattedSubject');
                if (formattedSubjectField) {
                    formattedSubjectField.value = formattedSubject;

                    // Also update the hidden subject field
                    const subjectField = document.getElementById('subject');
                    if (subjectField) {
                        subjectField.value = formattedSubject;
                    }
                }
            }

            updateSimFsaSubject() {
                const isVIPField = document.querySelector('select[name="isVIP"]');
                const districtNameField = document.querySelector('input[name="districtName"]');
                const applicationField = document.querySelector('input[name="application"]');
                const specificIssueField = document.querySelector('input[name="specificIssue"]');

                // Get all checked user role checkboxes
                const userRoleCheckboxes = document.querySelectorAll('input[name="userRole"]:checked');
                const selectedRoles = Array.from(userRoleCheckboxes).map(cb => cb.value);
                const formattedUserRole = this.formatUserRoles(selectedRoles);

                // Build the subject line
                let subject = '';
                if (isVIPField && isVIPField.value === 'Yes') {
                    subject += 'VIP* ';
                }
                if (districtNameField && districtNameField.value) {
                    subject += `${districtNameField.value} | `;
                }
                if (applicationField && applicationField.value) {
                    subject += applicationField.value;
                }
                if (specificIssueField && specificIssueField.value) {
                    subject += ` - ${specificIssueField.value}`;
                }
                if (formattedUserRole) {
                    subject += ` for ${formattedUserRole}`;
                }

                // Update both the formatted and hidden subject fields
                const formattedSubjectField = document.querySelector('input[name="formattedSubject"]');
                const hiddenSubjectField = document.querySelector('input[name="subject"]');

                if (formattedSubjectField) {
                    formattedSubjectField.value = subject;
                }
                if (hiddenSubjectField) {
                    hiddenSubjectField.value = subject;
                }
            }

            // Create a new non-async method for immediate subject updates
            updateAchievementLevelsSubjectSync() {
                try {
                    // First check if we already have a pre-formatted subject from template-selector
                    if (this.ticketData && this.ticketData.formattedSubject) {
                        const subject = this.ticketData.formattedSubject;

                        // Update DOM fields with the pre-formatted subject
                        const formattedSubjectField = document.getElementById('formattedSubject');
                        if (formattedSubjectField) {
                            formattedSubjectField.value = subject;

                            // Also update the hidden subject field
                            const subjectField = document.getElementById('subject');
                            if (subjectField) {
                                subjectField.value = subject;
                            }

                            // Cache for comparison
                            this._cachedSubjectLine = subject;
                        }

                        console.log('Using pre-formatted subject with VIP status:', subject);
                        return;
                    }

                    // If no pre-formatted subject, fall back to existing logic
                    const districtNameField = document.getElementById('districtName');
                    const districtName = districtNameField ? districtNameField.value || '' : '';

                    // SIMPLIFY VIP logic - use multiple sources
                    let isVip = false;

                    // Check all possible sources for VIP status
                    const vipCheckbox = document.getElementById('hiddenVIPStatus');
                    if (vipCheckbox && vipCheckbox.checked) {
                        isVip = true;
                    } else if (this.ticketData && this.ticketData.isVip === true) {
                        isVip = true;
                    }

                    // Hardcode VIP prefix based on the determined status  
                    const vipPrefix = isVip ? 'VIP* ' : '';

                    // Format the subject line
                    const subject = `${vipPrefix}${districtName} | Custom Achievement Levels`;

                    // Update DOM fields
                    const formattedSubjectField = document.getElementById('formattedSubject');
                    if (formattedSubjectField) {
                        formattedSubjectField.value = subject;

                        // Also update the hidden subject field
                        const subjectField = document.getElementById('subject');
                        if (subjectField) {
                            subjectField.value = subject;
                        }

                        // Cache for comparison
                        this._cachedSubjectLine = subject;
                    }

                    console.log('Updated Achievement Levels subject line:', subject, 'isVip:', isVip);
                } catch (error) {
                    console.log('Error in sync subject update:', error);
                }
            }

            // Keep the async method for background updates
            async updateAchievementLevelsSubject() {
                try {
                    // Fetch latest VIP status
                    await this.checkAndUpdateVIPStatus();

                    // Update the subject with latest data
                    this.updateAchievementLevelsSubjectSync();
                } catch (error) {
                    console.log('Error in async subject update:', error);
                }
            }

            loadDataFromStorage() {
                // Try to load data from localStorage based on tracker type
                const storageKey = `${this.trackerType}Data`;
                const storedData = localStorage.getItem(storageKey);

                if (storedData) {
                    try {
                        const parsedData = JSON.parse(storedData);
                        console.log(`Found stored data for ${this.trackerType}:`, parsedData);

                        // Populate fields from stored data
                        if (parsedData.currentTicketId) {
                            // Set the related tickets field to include the source ticket ID
                            const relatedTicketsField = document.getElementById('relatedTickets');
                            if (relatedTicketsField && !relatedTicketsField.value) {
                                relatedTicketsField.value = parsedData.currentTicketId;
                                console.log(`Set related tickets field to source ticket: ${parsedData.currentTicketId}`);
                            }
                        }

                        // Add explicit check and debug for district field and districtName
                        if (parsedData.districtName) {
                            const districtField = document.getElementById('districtField');
                            const districtNameField = document.getElementById('districtName');

                            if (districtField) {
                                districtField.value = parsedData.districtName;
                                // Style it as non-editable
                                districtField.style.backgroundColor = '#f0f0f0';
                                districtField.style.color = '#666';
                                districtField.style.border = '1px solid #ddd';
                                districtField.style.cursor = 'not-allowed';
                                console.log(`Set district field to: ${parsedData.districtName}`);

                                // Ensure this value is stored for ticket creation
                                this.districtDropdownValue = parsedData.districtName;
                                this.districtField = parsedData.districtName;
                            }

                            if (districtNameField) {
                                districtNameField.value = parsedData.districtName;
                                // Make it read-only
                                districtNameField.readOnly = true;
                                districtNameField.style.backgroundColor = '#f0f0f0';
                                districtNameField.style.color = '#666';
                                districtNameField.style.border = '1px solid #ddd';
                                districtNameField.style.cursor = 'not-allowed';
                                console.log(`Set districtName field to: ${parsedData.districtName}`);
                            }
                        } else {
                            console.warn('No district name found in stored data');
                        }

                        // IMPORTANT - Set email field directly
                        if (parsedData.requesterEmail) {
                            const emailField = document.getElementById('email');
                            emailField.value = parsedData.requesterEmail;
                            console.log(`Set email to: ${parsedData.requesterEmail}`);
                        }

                        // IMPORTANT - Make sure priority is set with the right value
                        if (parsedData.priority) {
                            const priorityField = document.getElementById('priority');
                            priorityField.value = parsedData.priority.toString();
                            console.log(`Set priority to: ${parsedData.priority}`);
                        }

                        if (parsedData.isVip !== undefined) {
                            // Find and set VIP field if it exists in this tracker
                            const vipField = document.getElementById('isVIP');
                            if (vipField) {
                                vipField.value = parsedData.isVip ? 'Yes' : 'No';
                            }

                            // Also set hidden VIP checkbox
                            const vipCheckbox = document.getElementById('hiddenVIPStatus');
                            if (vipCheckbox) {
                                vipCheckbox.checked = !!parsedData.isVip;
                                console.log('Set VIP checkbox from stored data:', !!parsedData.isVip);
                            }

                            // Store in ticketData
                            this.ticketData.isVip = !!parsedData.isVip;
                            console.log('Set ticketData.isVip from stored data:', !!parsedData.isVip);
                        }

                        // Clear localStorage to avoid reusing stale data
                        localStorage.removeItem(storageKey);

                        // Add support for product type field
                        if (parsedData.productType) {
                            this.ticketData.productType = parsedData.productType;
                            console.log(`Retrieved product type from stored data:`, this.ticketData.productType);
                        }

                        // Add support for product field
                        if (parsedData.product) {
                            this.ticketData.product = parsedData.product;
                            console.log(`Retrieved product from stored data:`, this.ticketData.product);
                        }

                        // Add support for product subsection field
                        if (parsedData.productSubsection) {
                            this.ticketData.productSubsection = parsedData.productSubsection;
                            console.log(`Retrieved product subsection from stored data:`, this.ticketData.productSubsection);
                        }
                    } catch (error) {
                        console.error("Error parsing stored data:", error);
                    }
                } else {
                    console.warn(`No stored data found for ${this.trackerType}`);
                }

                // Special handling for Achievement Levels tracker
                if (this.trackerType === 'sim-achievement-levels') {
                    // Ensure the district name is populated
                    setTimeout(() => {
                        const districtField = document.getElementById('districtField');
                        const districtNameField = document.getElementById('districtName');

                        if (districtField && districtField.value && districtNameField) {
                            console.log(`Setting districtName to ${districtField.value} from districtField`);
                            districtNameField.value = districtField.value;

                            // Update the subject
                            this.updateAchievementLevelsSubject();
                        }
                    }, 500); // Short delay to ensure fields are available
                }

                // Add this to the loadDataFromStorage method instead
                if (this.trackerType === 'sim-fsa') {
                    const subjectDistrictField = document.querySelector('#section-subject #districtName');
                    const issueDistrictField = document.querySelector('#section-issueDescription #districtName');

                    if (subjectDistrictField && issueDistrictField) {
                        // If we have stored data, use that
                        if (storedData) {
                            try {
                                const parsedData = JSON.parse(storedData);
                                if (parsedData.districtName) {
                                    subjectDistrictField.value = parsedData.districtName;
                                    issueDistrictField.value = parsedData.districtName;
                                    console.log(`Set both district fields to: ${parsedData.districtName}`);
                                }
                            } catch (error) {
                                console.error('Error parsing stored data for district fields:', error);
                            }
                        }

                        // Make the issue description district field read-only
                        issueDistrictField.readOnly = true;
                        issueDistrictField.style.backgroundColor = '#f0f0f0';
                        issueDistrictField.style.color = '#666';
                        issueDistrictField.style.border = '1px solid #ddd';
                        issueDistrictField.style.cursor = 'not-allowed';

                        // Add event listener to keep fields in sync
                        subjectDistrictField.addEventListener('input', () => {
                            issueDistrictField.value = subjectDistrictField.value;
                        });
                    }
                }
            }

            async loadInitialData() {
                try {
                    console.log('Loading initial data');

                    // Get the current ticket ID first
                    let currentTicketId = null;
                    try {
                        const ticketData = await this.client.data.get("ticket");
                        if (ticketData && ticketData.ticket && ticketData.ticket.id) {
                            currentTicketId = ticketData.ticket.id;
                            console.log("Got current ticket ID:", currentTicketId);

                            // Store it for future use
                            this.ticketData.currentTicketId = currentTicketId;

                            // Get product type if available
                            if (ticketData.ticket.custom_fields && ticketData.ticket.custom_fields.cf_product_type) {
                                this.ticketData.productType = ticketData.ticket.custom_fields.cf_product_type;
                                console.log("Retrieved product type from ticket:", this.ticketData.productType);
                            }

                            // Get product if available
                            if (ticketData.ticket.custom_fields && ticketData.ticket.custom_fields.cf_product) {
                                this.ticketData.product = ticketData.ticket.custom_fields.cf_product;
                                console.log("Retrieved product from ticket:", this.ticketData.product);
                            }

                            // Get product subsection if available
                            if (ticketData.ticket.custom_fields && ticketData.ticket.custom_fields.cf_product_subsection) {
                                this.ticketData.productSubsection = ticketData.ticket.custom_fields.cf_product_subsection;
                                console.log("Retrieved product subsection from ticket:", this.ticketData.productSubsection);
                            }

                            // Populate the related tickets field with the current ticket ID
                            const relatedTicketsField = document.getElementById('relatedTickets');
                            if (relatedTicketsField && !relatedTicketsField.value) {
                                relatedTicketsField.value = currentTicketId.toString();
                                console.log("Prepopulated related tickets field with current ticket ID");
                            }

                            // Handle district field synchronization for specific templates
                            if (this.trackerType === 'assembly' || this.trackerType === 'assembly-rollover' || this.trackerType === 'sim-assignment') {
                                const districtField = document.getElementById('districtField');
                                const districtNameField = document.getElementById('districtName');

                                if (districtField && districtNameField) {
                                    console.log("District field value:", districtField.value);
                                    // Copy the district value to district name field
                                    districtNameField.value = districtField.value;

                                    // Make it read-only and style it as non-editable
                                    districtNameField.readOnly = true;
                                    districtNameField.style.backgroundColor = '#f0f0f0';
                                    districtNameField.style.color = '#666';
                                    districtNameField.style.border = '1px solid #ddd';
                                    districtNameField.style.cursor = 'not-allowed';
                                } else {
                                    console.warn("Could not find districtField or districtNameField");
                                }
                            }

                            // Only apply readonly to districtName fields, NOT districtState
                            document.querySelectorAll('input[id="districtName"]').forEach(field => {
                                field.readOnly = true;
                                field.style.backgroundColor = '#f0f0f0';
                                field.style.color = '#666';
                                field.style.border = '1px solid #ddd';
                                field.style.cursor = 'not-allowed';
                            });

                            // Remove any styling that might have been applied to districtState
                            document.querySelectorAll('input[id="districtState"]').forEach(field => {
                                field.readOnly = false;
                                field.style.backgroundColor = '';
                                field.style.color = '';
                                field.style.border = '';
                                field.style.cursor = '';
                            });

                            // Check if this is one of the templates that needs company state data
                            if (this.trackerType === 'sedcust' ||
                                this.trackerType === 'assembly' ||       // Added assembly template
                                this.trackerType === 'assembly-rollover' || // Added assembly-rollover
                                this.trackerType === 'sim-achievement-levels' ||
                                this.trackerType === 'timeout-extension') {

                                // Get company ID from ticket data
                                const companyId = ticketData.ticket.company_id;
                                if (companyId) {
                                    console.log("Found company ID:", companyId);
                                    // Fetch company data to get state
                                    try {
                                        this.fetchCompanyState(companyId);
                                    } catch (companyError) {
                                        console.error("Error fetching company data:", companyError);
                                    }
                                } else {
                                    console.log("No company ID found in ticket data");
                                }
                            }
                        }
                    } catch (ticketError) {
                        console.warn("Could not get current ticket ID:", ticketError);
                    }

                    // Rest of your existing loadInitialData code...
                    // FIRST PRIORITY: Get agent email directly from API
                    try {
                        const userData = await this.client.data.get("loggedInUser");
                        console.log("Direct API user data:", userData);

                        // Try to extract email from various possible locations
                        let agentEmail = '';
                        if (userData && userData.loggedInUser) {
                            // Log the full structure to understand where the email might be
                            console.log("Full userData.loggedInUser:", JSON.stringify(userData.loggedInUser));

                            // Try different possible locations for the email
                            if (userData.loggedInUser.email) {
                                agentEmail = userData.loggedInUser.email;
                            } else if (userData.loggedInUser.contact && userData.loggedInUser.contact.email) {
                                agentEmail = userData.loggedInUser.contact.email;
                            } else if (userData.loggedInUser.primary_email) {
                                agentEmail = userData.loggedInUser.primary_email;
                            } else if (userData.loggedInUser.user && userData.loggedInUser.user.email) {
                                agentEmail = userData.loggedInUser.user.email;
                            }

                            // If we find the email, use it
                            if (agentEmail) {
                                const emailField = document.getElementById('email');
                                emailField.value = agentEmail;
                                console.log("Set email directly from agent data:", agentEmail);
                            } else {
                                // Last resort: try to get email from another API call
                                try {
                                    // Try to get current agent ID
                                    if (userData.loggedInUser.id) {
                                        const agentId = userData.loggedInUser.id;
                                        const agentResponse = await this.client.request.invokeTemplate("getAgentDetails", {
                                            context: {
                                                agentId: agentId
                                            }
                                        });
                                        const agentData = JSON.parse(agentResponse.response);

                                        if (agentData && agentData.contact && agentData.contact.email) {
                                            const emailField = document.getElementById('email');
                                            emailField.value = agentData.contact.email;
                                            console.log("Set email from agent details API:", agentData.contact.email);
                                        }
                                    }
                                } catch (error) {
                                    console.warn("Error getting agent details:", error);
                                }
                            }
                        } else {
                            console.warn("Could not get agent email from userData:", userData);
                        }
                    } catch (agentError) {
                        console.error("Error getting agent email:", agentError);
                    }

                    // Fall back to a hardcoded email if we still don't have one
                    const emailField = document.getElementById('email');
                    if (!emailField.value) {
                        // Try to get the ticket requester's email as a last resort
                        try {
                            const ticketData = await this.client.data.get("ticket");
                            if (ticketData && ticketData.ticket && ticketData.ticket.requester && ticketData.ticket.requester.email) {
                                emailField.value = ticketData.ticket.requester.email;
                                console.log("Set email from ticket requester:", ticketData.ticket.requester.email);
                            }
                        } catch (error) {
                            console.warn("Could not get ticket data:", error);
                        }
                    }

                    // Rest of the method continues as before
                    const today = new Date().toISOString().split('T')[0];
                    document.querySelectorAll('input[type="date"]').forEach(dateField => {
                        dateField.value = today;
                    });

                    await this.loadTicketContext();
                    await this.loadGroups();
                } catch (error) {
                    console.error('Error loading initial data:', error);
                }
            }

            async loadTicketContext() {
                // Simple stub implementation
                console.log('Loading ticket context');
                return Promise.resolve();
            }

            async loadGroups() {
                console.log('Loading groups');

                try {
                    // Show loading state
                    const groupField = document.getElementById('groupField');
                    groupField.innerHTML = '<option value="">Loading groups...</option>';

                    // Fetch groups from API
                    const response = await this.client.request.invokeTemplate("getGroups", {});
                    const groups = JSON.parse(response.response);

                    if (Array.isArray(groups) && groups.length > 0) {
                        // Build options
                        let options = '<option value="">-- Select Group --</option>';
                        let escalationsGroupId = null;

                        groups.forEach(group => {
                            // Check if this is the Escalations group
                            const isEscalations = group.name.toLowerCase() === 'escalations';
                            if (isEscalations) {
                                escalationsGroupId = group.id;
                            }

                            // Add the group to the dropdown
                            options += `<option value="${group.id}" ${isEscalations ? 'selected' : ''}>${group.name}</option>`;
                        });

                        // Set options
                        groupField.innerHTML = options;
                        console.log(`Loaded ${groups.length} groups`);

                        // Load only the specific agents - not all agents
                        await this.loadSpecificAgents();
                    } else {
                        groupField.innerHTML = '<option value="">No groups available</option>';

                        // Set default to Escalations anyway
                        groupField.innerHTML = `
                            <option value="">-- Select Group --</option>
                            <option value="escalations" selected>Escalations</option>
                            <option value="1">Support</option>
                            <option value="2">Engineering</option>
                        `;

                        // Also load the specific agents
                        await this.loadSpecificAgents();
                    }
                } catch (error) {
                    console.error('Error loading groups:', error);

                    // Fallback with Escalations selected
                    document.getElementById('groupField').innerHTML = `
                        <option value="">-- Select Group --</option>
                        <option value="escalations" selected>Escalations</option>
                        <option value="1">Support</option>
                        <option value="2">Engineering</option>
                    `;

                    // Load the specific agents
                    await this.loadSpecificAgents();
                }
            }

            async loadSpecificAgents() {
                console.log('Loading specific agents');

                // List of specific agent IDs to display
                const specificAgentIds = [67025683491, 67030529218, 67031011668, 67040597168, 67051499418];

                try {
                    // Show loading state
                    const agentField = document.getElementById('agentField');
                    agentField.innerHTML = '<option value="">Loading agents...</option>';

                    // Fetch all agents from API
                    const response = await this.client.request.invokeTemplate("getAllAgents", {});
                    const allAgents = JSON.parse(response.response);

                    if (Array.isArray(allAgents) && allAgents.length > 0) {
                        // Filter to only include specific agents
                        const specificAgents = allAgents.filter(agent =>
                            specificAgentIds.includes(agent.id)
                        );

                        // Build options
                        let options = '<option value="">-- Select Agent --</option>';

                        specificAgents.forEach(agent => {
                            // Get agent name
                            let agentName = 'Unknown Agent';
                            let agentId = agent.id;

                            if (agent.contact && agent.contact.name) {
                                agentName = agent.contact.name;
                            } else if (agent.name) {
                                agentName = agent.name;
                            } else if (agent.email) {
                                agentName = agent.email.split('@')[0]; // Use part of email as name
                            }

                            options += `<option value="${agentId}">${agentName}</option>`;
                        });

                        // Set options
                        agentField.innerHTML = options;
                        console.log(`Loaded ${specificAgents.length} specific agents`);
                    } else {
                        agentField.innerHTML = '<option value="">No agents available</option>';
                    }
                } catch (error) {
                    console.error('Error loading specific agents:', error);

                    // Fallback hardcoded agents
                    document.getElementById('agentField').innerHTML = `
                        <option value="">-- Select Agent --</option>
                        <option value="67025683491">Escalation Agent 1</option>
                        <option value="67030529218">Escalation Agent 2</option>
                        <option value="67031011668">Escalation Agent 3</option>
                        <option value="67040597168">Escalation Agent 4</option>
                        <option value="67051499418">Escalation Agent 5</option>
                    `;
                }
            }

            handleFormSubmit() {
                console.log('Form submitted');

                // Show the loading overlay
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'flex';
                }

                // Set default values for hidden required fields
                this.setDefaultValuesForHiddenFields();

                // Reset previous errors
                document.querySelectorAll('.validation-error').forEach(el => el.remove());
                document.querySelectorAll('.field-error').forEach(el => el.classList.remove('field-error'));

                // ... other form handling code ...

                // Validate the form first
                if (!this.validateForm()) {
                    // Hide loading overlay if validation fails
                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'none';
                    }
                    return;
                }

                // Get all form data and update hidden description field
                try {
                    // Get the data and sanitize it
                    let formData = this.getFormData();
                    formData = this.sanitizeFormData(formData);

                    console.log('Form data:', formData);

                    // Generate description using the configured template
                    const description = this.generateDescription();
                    document.getElementById('description').value = description;
                    console.log('Generated description:', description);

                    // Create the ticket in Freshdesk
                    this.createTicket(formData);
                } catch (error) {
                    console.error('Error submitting form:', error);
                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'none';
                    }
                    this.showError('Error submitting form: ' + (error.message || 'Unknown error'));
                }
            }

            // Add this new method to set default values for hidden required fields
            setDefaultValuesForHiddenFields() {
                // Set default status if hidden
                const statusField = document.getElementById('status');
                if (statusField && statusField.style.display === 'none' && !statusField.value) {
                    statusField.value = '2'; // Default to Open
                }

                // Set default priority if hidden
                const priorityField = document.getElementById('priority');
                if (priorityField && priorityField.style.display === 'none' && !priorityField.value) {
                    priorityField.value = '2'; // Default to Medium
                }

                // Ensure email has a value
                const emailField = document.getElementById('email');
                if (emailField && emailField.style.display === 'none' && !emailField.value) {
                    // Try to get from the window variable if available
                    if (this.client && this.client.data) {
                        this.client.data.get("loggedInUser").then(userData => {
                            if (userData && userData.loggedInUser && userData.loggedInUser.email) {
                                emailField.value = userData.loggedInUser.email;
                            }
                        }).catch(err => console.error("Error getting logged-in user email:", err));
                    }
                }
            }

            validateForm() {
                // Reset any previous validation errors
                document.querySelectorAll('.validation-error').forEach(el => el.remove());
                document.querySelectorAll('.field-error').forEach(el => el.classList.remove('field-error'));

                let isValid = true;

                // Check required fields (but skip hidden ones)
                const requiredFields = document.querySelectorAll('[required]');
                for (let field of requiredFields) {
                    // Skip validation for hidden fields
                    const parent = this.findParentWithClass(field, 'form-group');
                    if (parent && parent.style.display === 'none') {
                        continue;
                    }

                    if (!field.value.trim()) {
                        isValid = false;
                        this.showFieldError(field, 'This field is required');
                    }
                }

                // Add conditional required validation for HAR file reason
                if (this.trackerType === 'sim-assignment' || this.trackerType === 'sim-assessment-reports') {
                    const harFileAttached = document.getElementById('harFileAttached');
                    const harFileReason = document.getElementById('harFileReason');

                    if (harFileAttached && harFileReason && harFileAttached.value === 'No') {
                        // If HAR file is not attached, reason is required
                        if (!harFileReason.value.trim()) {
                            isValid = false;
                            this.showFieldError(harFileReason, 'Please provide a reason for not attaching a HAR file');
                        }
                    }
                }

                // Rest of validation code remains the same...

                // Email validation for email fields
                const emailFields = document.querySelectorAll('input[type="email"]');
                for (let field of emailFields) {
                    if (field.value && !this.isValidEmail(field.value)) {
                        isValid = false;
                        this.showFieldError(field, 'Please enter a valid email address');
                    }
                }

                // Check the Quill editors for required content
                Object.keys(this.quillEditors).forEach(id => {
                    const editor = this.quillEditors[id];
                    const textareaElement = document.getElementById(id);

                    if (textareaElement && textareaElement.hasAttribute('required')) {
                        const content = editor.getText().trim();
                        if (!content) {
                            isValid = false;
                            const editorElement = editor.container;
                            this.showFieldError(editorElement, 'This field is required');
                            editor.container.classList.add('field-error');
                        }
                    }
                });

                // Check if related tickets field is filled
                const relatedTicketsField = document.getElementById('relatedTickets');
                if (!relatedTicketsField.value.trim()) {
                    isValid = false;
                    this.showFieldError(relatedTicketsField, 'At least one related ticket ID is required to create a tracker');
                }

                if (!isValid) {
                    this.showError('Please correct the errors in the form');
                }

                // Add this to your validateForm method
                // Ensure VIP tickets always get priority 3
                if (this.ticketData && this.ticketData.isVip) {
                    console.log("Form validation: Ensuring HIGH priority (3) for VIP ticket");
                    const priorityField = document.getElementById('priority');
                    if (priorityField) {
                        priorityField.value = "3";
                    }
                }

                return isValid;
            }

            showFieldError(field, message) {
                // Add error class to the field
                field.classList.add('field-error');

                // Create and append the error message
                const errorElement = document.createElement('div');
                errorElement.className = 'validation-error';
                errorElement.textContent = message;

                // Insert after the field
                if (field.parentNode) {
                    field.parentNode.appendChild(errorElement);
                }
            }

            isValidEmail(email) {
                const re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
                return re.test(String(email).toLowerCase());
            }

            generateDescription() {
                // Get values from all form fields
                const formData = this.getFormData();

                // Log all keys in formData to help debug
                console.log("Form data keys:", Object.keys(formData));
                console.log("Screenshots description:", formData.screenshotsDescription);
                console.log("Steps to reproduce:", formData.stepsToReproduce);

                // Use the description generator from the config
                let description = '';
                if (this.config.descriptionGenerator) {
                    description = this.config.descriptionGenerator(formData);
                } else {
                    // Default description generator for blank template
                    description = `<div>${formData.subject || 'No subject'}</div>`;
                }

                return description;
            }

            getFormData() {
                // Get values from all form fields
                const formData = {};

                // Get values from Quill editors
                Object.keys(this.quillEditors).forEach(id => {
                    const editor = this.quillEditors[id];
                    const textareaElement = document.getElementById(id);
                    if (textareaElement) {
                        const content = editor.root.innerHTML;
                        textareaElement.value = content;
                        formData[id] = content;
                    }
                });

                // Get values from regular form fields
                const formElements = document.getElementById('trackerForm').elements;
                for (let i = 0; i < formElements.length; i++) {
                    const element = formElements[i];
                    if (element.name && element.name !== '') {
                        formData[element.name] = element.value;
                    }
                }

                // Add district dropdown field explicitly
                if (this.districtDropdownValue) {
                    formData.districtDropdownValue = this.districtDropdownValue;
                } else if (formData.districtField) {
                    // If districtDropdownValue is not available, use districtField
                    formData.districtDropdownValue = formData.districtField;
                }

                return formData;
            }

            showError(message) {
                console.error(message);
                // Display error in UI
                if (typeof client !== 'undefined') {
                    client.interface.trigger("showNotify", {
                        type: "danger",
                        message: message
                    }).catch(err => console.error("Error showing notification:", err));
                } else {
                    alert('Error: ' + message);
                }
            }

            handleFileInputChange(e) {
                const files = Array.from(e.target.files);
                const previewContainer = document.getElementById('screenshotPreview');
                const counter = document.getElementById('attachmentCounter');

                if (!files.length) return;

                // Append to existing files instead of replacing them
                this.aggregatedScreenshotFiles = [...this.aggregatedScreenshotFiles, ...files];

                // Create previews for the newly added files
                files.forEach(file => {
                    const thumbnail = document.createElement('div');
                    thumbnail.className = 'screenshot-thumbnail';

                    // Create thumbnail content
                    const fileTypeIcon = this.getFileTypeIcon(file.type);
                    thumbnail.innerHTML = `
                        <div class="file-preview">
                            <i class="${fileTypeIcon}"></i>
                        </div>
                        <div class="screenshot-filename">${file.name}</div>
                        <div class="screenshot-remove" data-filename="${file.name}">×</div>
                    `;

                    previewContainer.appendChild(thumbnail);
                });

                // Update counter
                if (this.aggregatedScreenshotFiles.length > 0) {
                    counter.textContent = `${this.aggregatedScreenshotFiles.length} file(s) selected (${this.formatFileSize(this.aggregatedScreenshotFiles.reduce((total, file) => total + file.size, 0))})`;
                } else {
                    counter.textContent = '';
                }

                // Add event listeners to remove buttons
                document.querySelectorAll('.screenshot-remove').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const filename = e.target.getAttribute('data-filename');
                        this.removeFile(filename);
                    });
                });

                // Reset the file input to allow selecting the same files again
                e.target.value = '';
            }

            getFileTypeIcon(mimeType) {
                if (mimeType.startsWith('image/')) return 'fas fa-image';
                if (mimeType.startsWith('video/')) return 'fas fa-video';
                if (mimeType.startsWith('audio/')) return 'fas fa-music';
                if (mimeType.includes('pdf')) return 'fas fa-file-pdf';
                if (mimeType.includes('word') || mimeType.includes('document')) return 'fas fa-file-word';
                if (mimeType.includes('excel') || mimeType.includes('sheet')) return 'fas fa-file-excel';
                if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return 'fas fa-file-powerpoint';
                if (mimeType.includes('zip') || mimeType.includes('compressed')) return 'fas fa-file-archive';
                return 'fas fa-file';
            }

            formatFileSize(bytes) {
                if (bytes < 1024) return bytes + ' bytes';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
            }

            removeFile(filename) {
                // Remove from stored files array
                this.aggregatedScreenshotFiles = this.aggregatedScreenshotFiles.filter(file => file.name !== filename);

                // Remove thumbnail from UI
                const thumbnails = document.querySelectorAll('.screenshot-thumbnail');
                thumbnails.forEach(thumbnail => {
                    const filenameElement = thumbnail.querySelector('.screenshot-filename');
                    if (filenameElement && filenameElement.textContent === filename) {
                        thumbnail.remove();
                    }
                });

                // Update counter
                const counter = document.getElementById('attachmentCounter');
                if (this.aggregatedScreenshotFiles.length > 0) {
                    counter.textContent = `${this.aggregatedScreenshotFiles.length} file(s) selected (${this.formatFileSize(this.aggregatedScreenshotFiles.reduce((total, file) => total + file.size, 0))})`;
                } else {
                    counter.textContent = '';
                }
            }

            fillFormWithDemoData() {
                console.log("Filling form with demo data...");

                // KEEP the related tickets field (don't overwrite it)
                // const relatedTicketsField = document.getElementById('relatedTickets');
                // if (relatedTicketsField && !relatedTicketsField.value) {
                //     relatedTicketsField.value = "123456"; // Sample ticket ID for testing
                // }

                // Set priority
                document.getElementById('priority').value = '2';

                // Set status
                document.getElementById('status').value = '2'; // Open

                // Set subject if it exists
                const subjectField = document.getElementById('subject');
                if (subjectField) {
                    subjectField.value = `Test ${this.config.title}`;
                }

                // Set values in quill editors
                Object.keys(this.quillEditors).forEach(id => {
                    this.quillEditors[id].root.innerHTML = '<p>This is sample content for testing.</p>';
                });

                // Set ALL text fields that aren't special fields
                document.querySelectorAll('input[type="text"]').forEach(input => {
                    const fieldId = input.id.toLowerCase();

                    // Skip these special fields
                    if (fieldId !== 'subject' &&
                        fieldId !== 'relatedtickets' &&
                        fieldId !== 'districtfield') {

                        // Use a sensible default value based on the field's ID
                        input.value = `Sample ${input.id.replace(/([A-Z])/g, ' $1').toLowerCase()}`;

                        // For common fields, provide more realistic values
                        if (fieldId === 'districtname') {
                            input.value = 'Demo School District';
                        } else if (fieldId === 'xcode') {
                            input.value = 'X12345';
                        } else if (fieldId === 'application') {
                            input.value = 'Demo Application';
                        } else if (fieldId === 'specificissue') {
                            input.value = 'Sample Issue';
                        } else if (fieldId.includes('email')) {
                            input.value = 'demo@example.com';
                        }
                    }
                });

                // Set select fields to their first option if not already set (except group/agent fields)
                document.querySelectorAll('select').forEach(select => {
                    const selectId = select.id.toLowerCase();
                    if (selectId !== 'groupfield' &&
                        selectId !== 'agentfield' &&
                        !select.value &&
                        select.options.length > 0) {

                        // For selects, choose the first or second option to avoid blank values
                        select.value = select.options[Math.min(1, select.options.length - 1)].value;
                    }
                });

                // Ensure date fields have a value
                document.querySelectorAll('input[type="date"]').forEach(dateField => {
                    if (!dateField.value) {
                        const today = new Date();
                        dateField.value = today.toISOString().split('T')[0];
                    }
                });

                // If this is one of the templates with a formatted subject, update it
                if (this.trackerType === 'assembly') {
                    this.updateFormattedSubject();
                } else if (this.trackerType === 'sedcust') {
                    this.updateSedcustSubject();
                } else if (this.trackerType === 'sim-assignment') {
                    this.updateSimAssignmentSubject();
                } else if (this.trackerType === 'sim-assessment-reports') {
                    this.updateSIMAssessmentReportsSubject();
                }

                console.log("Form filled with demo data");
            }

            handlePasteImage(e, editor) {
                const clipboardData = e.clipboardData;
                if (!clipboardData || !clipboardData.items) return;

                const items = clipboardData.items;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') !== -1) {
                        e.preventDefault(); // Prevent default paste behavior

                        // Show loading indicator in editor
                        const range = editor.getSelection(true);
                        editor.insertText(range.index, "Uploading image... ", { italic: true, color: '#999' });
                        const placeholderIndex = range.index;

                        // Get the file from clipboard
                        const file = items[i].getAsFile();
                        console.log('Image pasted into editor:', file.name);

                        // Upload to ImgBB
                        this.uploadImageToImgBB(file).then(imageUrl => {
                            // Delete the placeholder text
                            editor.deleteText(placeholderIndex, "Uploading image... ".length);

                            // Insert the image at original paste position
                            editor.insertEmbed(placeholderIndex, 'image', imageUrl);
                            editor.setSelection(placeholderIndex + 1);
                        }).catch(error => {
                            console.error('Error uploading pasted image:', error);

                            // Replace placeholder with error message
                            editor.deleteText(placeholderIndex, "Uploading image... ".length);
                            editor.insertText(placeholderIndex, "⚠️ Image upload failed ", { italic: true, color: 'red' });
                        });

                        // Only handle the first image in the clipboard
                        break;
                    }
                }
            }

            handleDropImage(e, editor) {
                e.preventDefault();

                if (e.dataTransfer.files && e.dataTransfer.files.length) {
                    const file = e.dataTransfer.files[0];

                    // Check if it's an image
                    if (file.type.match(/^image\/(gif|jpe?g|png|webp|bmp)$/i)) {
                        // Show loading indicator
                        const range = editor.getSelection(true);
                        editor.insertText(range.index, "Uploading image... ", { italic: true, color: '#999' });
                        const placeholderIndex = range.index;

                        // Upload to ImgBB
                        this.uploadImageToImgBB(file).then(imageUrl => {
                            // Delete the placeholder text
                            editor.deleteText(placeholderIndex, "Uploading image... ".length);

                            // Insert the image at drop position
                            editor.insertEmbed(placeholderIndex, 'image', imageUrl);
                            editor.setSelection(placeholderIndex + 1);
                        }).catch(error => {
                            console.error('Error uploading dropped image:', error);

                            // Replace placeholder with error message
                            editor.deleteText(placeholderIndex, "Uploading image... ".length);
                            editor.insertText(placeholderIndex, "⚠️ Image upload failed ", { italic: true, color: 'red' });
                        });
                    }
                }
            }

            async uploadImageToImgBB(imageFile) {
                console.log(`Uploading image to ImgBB: ${imageFile.name} (${this.formatFileSize(imageFile.size)})`);

                try {
                    // Convert the image to base64
                    const base64Image = await this.readFileAsBase64(imageFile);

                    // Create form data for the API request
                    const formData = new FormData();
                    formData.append('key', 'b3da8c974bc40dd87d896d84436dd76e'); // Your ImgBB API key
                    formData.append('image', base64Image);
                    formData.append('name', imageFile.name);

                    // Make the API request
                    const response = await fetch('https://api.imgbb.com/1/upload', {
                        method: 'POST',
                        body: formData
                    });

                    // Parse the response
                    const result = await response.json();

                    if (result.success) {
                        console.log('Image uploaded successfully:', result.data.url);
                        // Return the display URL (medium size) for better quality
                        return result.data.display_url;
                    } else {
                        throw new Error(result.error?.message || 'Upload failed');
                    }
                } catch (error) {
                    console.error('Error uploading to ImgBB:', error);
                    throw error;
                }
            }

            readFileAsBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        // Get the base64 part without the prefix
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            handleTicketCreationSuccess(ticketData) {
                console.log('Ticket created successfully:', ticketData);

                // Hide loading overlay only after all operations (including attachments) are done
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'flex'; // Keep showing until attachments are processed
                    loadingOverlay.querySelector('.spinner-text').textContent = "Processing attachments...";
                }

                // Show success message
                const successMessage = document.createElement('div');
                successMessage.className = 'success-message';
                successMessage.innerHTML = `
                    <i class="fas fa-check-circle"></i>
                    Tracker ticket #${ticketData.id} created successfully!
                `;

                // Insert at the top of the form
                const form = document.getElementById('trackerForm');
                form.insertBefore(successMessage, form.firstChild);

                // We'll use Promise.all to make sure we process all async operations
                const processingTasks = [];

                // Upload any attachments as a separate note
                const hasScreenshots = this.aggregatedScreenshotFiles && this.aggregatedScreenshotFiles.length > 0;
                const hasHarFile = this.trackerType === 'sim-assignment' && this.harFile;

                if (hasScreenshots || hasHarFile) {
                    processingTasks.push(this.addAttachmentsAsNote(ticketData.id));
                }

                // Wait for all processing to complete
                Promise.all(processingTasks)
                    .then(() => {
                        console.log('All post-creation tasks completed successfully');

                        // Hide loading overlay
                        if (loadingOverlay) {
                            loadingOverlay.style.display = 'none';
                        }

                        // Disable submit button
                        const submitButton = document.getElementById('createTracker');
                        if (submitButton) {
                            submitButton.disabled = true;
                        }

                        // Show notification
                        this.client.interface.trigger("showNotify", {
                            type: "success",
                            message: `Tracker ticket #${ticketData.id} created successfully!`
                        }).catch(err => console.error("Error showing notification:", err));

                        // Get the Freshdesk subdomain and automatically open the ticket in a new tab
                        this.client.iparams.get("freshdesk_subdomain").then(iparams => {
                            const subdomain = iparams.freshdesk_subdomain.replace(/\.freshdesk\.com$/i, '');
                            const ticketUrl = `https://${subdomain}.freshdesk.com/a/tickets/${ticketData.id}`;

                            // Open in a new tab
                            window.open(ticketUrl, '_blank');

                            // Return to template selector after a short delay
                            setTimeout(() => {
                                window.location.href = 'template-selector.html';
                            }, 1500);
                        }).catch((error) => {
                            console.error("Error getting subdomain:", error);
                            // Fallback to generic URL
                            window.open(`https://freshdesk.com/a/tickets/${ticketData.id}`, '_blank');

                            // Return to template selector after a short delay
                            setTimeout(() => {
                                window.location.href = 'template-selector.html';
                            }, 1500);
                        });
                    })
                    .catch(error => {
                        console.error('Error during post-creation tasks:', error);

                        // Hide loading overlay
                        if (loadingOverlay) {
                            loadingOverlay.style.display = 'none';
                        }

                        // Show a more helpful error message
                        this.showError('Ticket created, but there was an error uploading attachments. You may need to manually add files to the ticket.');

                        // Still open the ticket
                        this.client.iparams.get("freshdesk_subdomain").then(iparams => {
                            const subdomain = iparams.freshdesk_subdomain.replace(/\.freshdesk\.com$/i, '');
                            const ticketUrl = `https://${subdomain}.freshdesk.com/a/tickets/${ticketData.id}`;
                            window.open(ticketUrl, '_blank');

                            // Return to template selector after a short delay
                            setTimeout(() => {
                                window.location.href = 'template-selector.html';
                            }, 1500);
                        }).catch(() => {
                            window.open(`https://freshdesk.com/a/tickets/${ticketData.id}`, '_blank');
                            setTimeout(() => window.location.href = 'template-selector.html', 1500);
                        });
                    });
            }

            async associateWithRelatedTickets(ticketId) {
                // Skip if no related tickets
                if (!this.relatedTicketIds || this.relatedTicketIds.length === 0) {
                    return;
                }

                console.log(`Associating ticket #${ticketId} with related tickets:`, this.relatedTicketIds);

                // Process each related ticket
                for (const relatedId of this.relatedTicketIds) {
                    try {
                        await this.client.request.invokeTemplate("associateTickets", {
                            context: {
                                primaryTicketId: ticketId,
                                secondaryTicketId: relatedId
                            }
                        });
                        console.log(`Successfully associated with ticket #${relatedId}`);
                    } catch (error) {
                        console.error(`Failed to associate with ticket #${relatedId}:`, error);
                        // Continue with other tickets even if one fails
                    }
                }
            }

            async createTicket(formData) {
                try {
                    const loadingOverlay = document.getElementById('loadingOverlay');

                    // Get the formatted subject from the form
                    const formattedSubjectField = document.getElementById('formattedSubject');
                    let subject = formattedSubjectField ? formattedSubjectField.value : formData.subject;

                    // If no formatted subject, fall back to regular subject
                    if (!subject) {
                        subject = formData.subject || `${this.config.title} - ${new Date().toLocaleDateString()}`;
                    }

                    // Parse and validate related tickets
                    let relatedTicketIds = [];
                    if (formData.relatedTickets) {
                        relatedTicketIds = formData.relatedTickets.split(',')
                            .map(id => id.trim())
                            .filter(id => id !== '')
                            .map(id => parseInt(id, 10))
                            .filter(id => !isNaN(id));
                    }

                    // Get source ticket data from the first related ticket
                    let sourceTicketData = null;
                    if (relatedTicketIds.length > 0) {
                        try {
                            const sourceTicketId = relatedTicketIds[0];
                            const response = await this.client.request.invokeTemplate("getTicketDetails", {
                                context: { ticketId: sourceTicketId }
                            });
                            sourceTicketData = JSON.parse(response.response);
                            console.log("Retrieved source ticket data:", sourceTicketData);
                        } catch (error) {
                            console.error("Error getting source ticket data:", error);
                        }
                    }

                    // Add validation to check if related tickets exist
                    try {
                        for (const ticketId of relatedTicketIds) {
                            const response = await this.client.request.invokeTemplate("getTicketDetails", {
                                context: { ticketId: ticketId }
                            });
                            // If we get here, the ticket exists
                            console.log(`Verified related ticket ${ticketId} exists`);
                        }
                    } catch (error) {
                        console.error("Error validating related tickets:", error);
                        throw new Error("One or more related ticket IDs are invalid or inaccessible. Please verify the ticket numbers.");
                    }

                    // Generate description BEFORE creating ticketData
                    const description = this.generateDescription();
                    document.getElementById('description').value = description;

                    // Create the ticket data object
                    let ticketData = {
                        email: formData.email,
                        subject: subject,
                        description: description,
                        status: parseInt(formData.status || 2),
                        priority: parseInt(formData.priority || 2),
                        tags: [`tracker-${this.trackerType}`, "TESTING"],
                        related_ticket_ids: relatedTicketIds,
                        source: 101,
                        custom_fields: {}
                    };

                    // Initialize custom_fields if not already done
                    ticketData.custom_fields = ticketData.custom_fields || {};

                    // Copy custom fields from source ticket if available
                    if (sourceTicketData && sourceTicketData.custom_fields) {
                        // List of custom fields to include from source ticket
                        const customFieldsToPreserve = [
                            'cf_account_manager',
                            'cf_rvp',
                            'cf_categorization',
                            'cf_subcategory',
                            'cf_issue_detail',
                            'cf_product_type',
                            'cf_product',
                            'cf_product_subsection',
                            'cf_vip'
                        ];

                        // Copy the custom fields
                        customFieldsToPreserve.forEach(field => {
                            if (sourceTicketData.custom_fields[field] !== undefined) {
                                ticketData.custom_fields[field] = sourceTicketData.custom_fields[field];
                                console.log(`Copied custom field ${field} from source ticket:`, ticketData.custom_fields[field]);
                            }
                        });
                    }

                    // Set district field
                    if (formData.districtField) {
                        ticketData.custom_fields.cf_district509811 = String(formData.districtField);
                        console.log(`Set district field - cf_district509811: ${formData.districtField}`);
                    }
                    // Use fallback methods if district field not available
                    else if (formData.districtName) {
                        ticketData.custom_fields.cf_district509811 = String(formData.districtName);
                        console.log(`Using districtName as fallback for district field: ${formData.districtName}`);
                    }
                    else if (formData.districtDropdownValue) {
                        ticketData.custom_fields.cf_district509811 = String(formData.districtDropdownValue);
                        console.log(`Using districtDropdownValue as fallback for district field: ${formData.districtDropdownValue}`);
                    }

                    // Add group if selected
                    if (formData.groupField && formData.groupField !== '') {
                        const groupId = parseInt(formData.groupField, 10);
                        if (!isNaN(groupId)) {
                            ticketData.group_id = groupId;
                        }
                    }

                    // Add agent if selected
                    if (formData.agentField && formData.agentField !== '') {
                        const responderId = parseInt(formData.agentField, 10);
                        if (!isNaN(responderId)) {
                            ticketData.responder_id = responderId;
                        }
                    }

                    // Final check for VIP status and priority
                    if (this.ticketData && this.ticketData.isVip) {
                        console.log("Final check: Setting priority to HIGH (3) for VIP ticket");
                        ticketData.priority = 3;
                    }

                    // Debug log the final ticket data
                    console.log('Final ticket data to be sent:', JSON.stringify(ticketData, null, 2));

                    // Create the ticket
                    const response = await this.client.request.invokeTemplate("createfdTicket", {
                        body: JSON.stringify(ticketData)
                    });

                    console.log('Ticket created successfully, raw response:', response.response);
                    const responseData = JSON.parse(response.response);
                    console.log('Parsed ticket data:', responseData);

                    this.handleTicketCreationSuccess(responseData);
                } catch (error) {
                    console.error('Error creating ticket:', error);
                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'none';
                    }
                    this.showError('Failed to create ticket: ' + (error.message || 'Unknown error'));
                }
            }

            // Add this new method to fix image URLs
            fixImageUrls(html) {
                if (!html) return html;

                try {
                    // Create a temporary div to parse the HTML
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;

                    // Find all image tags
                    const images = tempDiv.querySelectorAll('img');

                    // Fix each image URL
                    images.forEach(img => {
                        const src = img.getAttribute('src');
                        if (src) {
                            // Make sure the URL has a protocol
                            if (!src.startsWith('http://') && !src.startsWith('https://')) {
                                img.setAttribute('src', 'https://' + src);
                            }

                            // Make sure the URL is properly encoded
                            const fixedUrl = encodeURI(decodeURI(src));
                            if (fixedUrl !== src) {
                                img.setAttribute('src', fixedUrl);
                            }
                        }
                    });

                    return tempDiv.innerHTML;
                } catch (error) {
                    console.error('Error fixing image URLs:', error);
                    return html; // Return the original HTML if there's an error
                }
            }

            debugLogRequest(req, title = 'API Request') {
                console.group(title);
                console.log('URL:', req.url);
                console.log('Method:', req.method);
                console.log('Headers:', req.headers);
                console.log('Body:', req.body);
                console.groupEnd();
            }

            // Add this method to your TrackerApp class to upload attachments after ticket creation
            async uploadAttachmentsToTicket(ticketId) {
                const hasScreenshots = this.aggregatedScreenshotFiles && this.aggregatedScreenshotFiles.length > 0;
                let hasHarFile = false;

                if (this.trackerType === 'sim-assignment' && this.harFile) {
                    // Only for SIM Assignment, process the HAR file
                    hasHarFile = true;
                }

                if (!hasScreenshots && !hasHarFile) {
                    return;
                }

                try {
                    // Process screenshots first
                    if (hasScreenshots) {
                        console.log(`Uploading ${this.aggregatedScreenshotFiles.length} attachments to ticket #${ticketId}...`);

                        // Process one attachment at a time
                        for (const file of this.aggregatedScreenshotFiles) {
                            try {
                                // Convert file to base64
                                const base64Data = await this.readFileAsBase64(file);

                                // Create note with attachment
                                const noteData = {
                                    ticketId: ticketId,
                                    noteBody: `Attachment: ${file.name}`,
                                    isPrivate: false,
                                    fileContent: base64Data,
                                    fileName: file.name,
                                    fileType: file.type
                                };

                                // Use the server component to upload the attachment
                                const response = await this.client.request.invoke('handle_attachments', {
                                    data: noteData
                                });

                                if (response.status >= 200 && response.status < 300) {
                                    console.log(`Successfully uploaded attachment: ${file.name}`);
                                } else {
                                    console.error(`Failed to upload attachment: ${file.name}`, response);
                                }
                            } catch (attachmentError) {
                                console.error(`Error uploading attachment ${file.name}:`, attachmentError);
                                // Continue with other attachments even if one fails
                            }
                        }
                    }

                    // Process HAR file if exists
                    if (hasHarFile) {
                        try {
                            console.log(`Uploading HAR file to ticket #${ticketId}...`);

                            // Convert file to base64
                            const base64Data = await this.readFileAsBase64(this.harFile);

                            // Create note with HAR file
                            const noteData = {
                                ticketId: ticketId,
                                noteBody: `HAR File: ${this.harFile.name}`,
                                isPrivate: false,
                                fileContent: base64Data,
                                fileName: this.harFile.name,
                                fileType: this.harFile.type
                            };

                            // Use the server component to upload the HAR file
                            const response = await this.client.request.invoke('handle_attachments', {
                                data: noteData
                            });

                            if (response.status >= 200 && response.status < 300) {
                                console.log(`Successfully uploaded HAR file: ${this.harFile.name}`);
                            } else {
                                console.error(`Failed to upload HAR file: ${this.harFile.name}`, response);
                            }
                        } catch (harError) {
                            console.error(`Error uploading HAR file ${this.harFile.name}:`, harError);
                        }
                    }
                } catch (error) {
                    console.error('Error uploading attachments:', error);
                    this.showError('Note: Some attachments may not have been uploaded correctly.');
                }
            }

            sanitizeFormData(formData) {
                // Make sure group_id is a number
                if (formData.groupField) {
                    try {
                        // If it's a string like "escalations", replace with appropriate ID
                        if (formData.groupField === "escalations") {
                            formData.groupField = "67000570680"; // Replace with actual Escalations group ID
                        }

                        // Try to convert to number
                        const groupId = parseInt(formData.groupField, 10);
                        if (isNaN(groupId)) {
                            console.warn(`Invalid group ID: ${formData.groupField}, removing`);
                            delete formData.groupField;
                        }
                    } catch (e) {
                        console.warn(`Error processing group ID: ${e.message}`);
                        delete formData.groupField;
                    }
                }

                // Also sanitize agent ID
                if (formData.agentField) {
                    try {
                        const agentId = parseInt(formData.agentField, 10);
                        if (isNaN(agentId)) {
                            console.warn(`Invalid agent ID: ${formData.agentField}, removing`);
                            delete formData.agentField;
                        }
                    } catch (e) {
                        console.warn(`Error processing agent ID: ${e.message}`);
                        delete formData.agentField;
                    }
                }

                return formData;
            }

            // Add this method to handle HAR file uploads
            handleHarFileUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                const previewContainer = document.getElementById('harFilePreview');
                if (!previewContainer) {
                    console.error('HAR file preview container not found');
                    return;
                }

                // Clear previous preview
                previewContainer.innerHTML = '';

                // Create preview element
                const thumbnail = document.createElement('div');
                thumbnail.className = 'screenshot-thumbnail';

                // Create thumbnail content
                thumbnail.innerHTML = `
                    <div class="file-preview">
                        <i class="fas fa-file-code"></i>
                    </div>
                    <div class="screenshot-filename">${file.name}</div>
                    <div class="har-remove" data-filename="${file.name}">×</div>
                `;

                previewContainer.appendChild(thumbnail);

                // Store file for later use
                this.harFile = file;

                // Add event listener to remove button
                document.querySelector('#harFilePreview .har-remove').addEventListener('click', () => {
                    previewContainer.innerHTML = '';
                    this.harFile = null;

                    // Reset file input
                    document.getElementById('harFile').value = '';
                });
            }

            // Add this method to your TrackerApp class
            setupConditionalFields() {
                // Look for fields with conditions and set up their display logic
                this.config.sections.forEach(section => {
                    section.fields.forEach(field => {
                        if (field.condition) {
                            const targetField = document.getElementById(field.id);

                            if (!targetField) {
                                console.warn(`Conditional field ${field.id} not found in DOM`);
                                return;
                            }

                            // Find the container for the entire field group
                            const fieldContainer = this.findParentWithClass(targetField, 'form-group');
                            if (!fieldContainer) {
                                console.warn(`Could not find form-group container for ${field.id}`);
                                return;
                            }

                            // Find the controlling field and set up a change listener
                            const controlField = document.getElementById(field.condition.field);
                            if (!controlField) {
                                console.warn(`Control field ${field.condition.field} not found for conditional field ${field.id}`);
                                return;
                            }

                            // Initial setup - hide/show based on current value
                            this.updateConditionalField(controlField, fieldContainer, field.condition.value);

                            // Add event listener to control field
                            controlField.addEventListener('change', () => {
                                this.updateConditionalField(controlField, fieldContainer, field.condition.value);
                            });
                        }
                    });
                });
            }

            // Helper method to find parent element with a specific class
            findParentWithClass(element, className) {
                while (element && !element.classList.contains(className)) {
                    element = element.parentElement;
                }
                return element;
            }

            // Helper method to update the display of a conditional field
            updateConditionalField(controlField, targetContainer, conditionValue) {
                if (controlField.value === conditionValue) {
                    targetContainer.style.display = '';
                } else {
                    targetContainer.style.display = 'none';
                }
            }

            // Add this method to your TrackerApp class
            setupCustomFileUploaders() {
                // Apply to sim-assignment, sim-assessment-reports, sim-library-view, and sim-fsa templates
                if (this.trackerType !== 'sim-assignment' &&
                    this.trackerType !== 'sim-assessment-reports' &&
                    this.trackerType !== 'sim-library-view' &&
                    this.trackerType !== 'sim-fsa' &&
                    this.trackerType !== 'sim-orr') {
                    return;
                }

                try {
                    // Track if we've added a screenshots section
                    let hasScreenshotsSection = false;

                    // Add file uploader to Screenshots & Videos section
                    const screenshotsSection = document.getElementById('section-screenshots');
                    if (screenshotsSection) {
                        hasScreenshotsSection = true;

                        // First update the section title to the new longer name
                        const headerElement = screenshotsSection.querySelector('.card-header h3');
                        if (headerElement) {
                            headerElement.textContent = "SCREENSHOTS, VIDEOS, & OTHER SUPPORTING FILE ATTACHMENTS";
                        }

                        const sectionBody = screenshotsSection.querySelector('.card-body');
                        if (!sectionBody) {
                            console.error('Screenshots section body not found');
                            return;
                        }

                        // Clear existing content
                        sectionBody.innerHTML = '';

                        // Add a Quill editor first
                        const quillContainer = document.createElement('div');
                        quillContainer.className = 'quill-editor-container';
                        quillContainer.innerHTML = `
                            <div id="screenshotsDescriptionEditor" style="min-height: 120px;"></div>
                            <textarea id="screenshotsDescription" name="screenshotsDescription" style="display: none;"></textarea>
                            <div class="hint"><i class="fas fa-info-circle"></i> Add description for your screenshots and videos</div>
                        `;
                        sectionBody.appendChild(quillContainer);

                        // Initialize Quill editor
                        this.initializeQuillEditor('screenshotsDescription', 'screenshotsDescriptionEditor');

                        // Then add file uploader after the Quill editor
                        const uploaderContainer = document.createElement('div');
                        uploaderContainer.className = 'attachment-input-container';
                        uploaderContainer.style.marginTop = '15px';
                        uploaderContainer.innerHTML = `
                            <label for="screenshots" class="file-upload-button">
                                <i class="fas fa-cloud-upload-alt"></i> Upload Files
                                <input type="file" id="screenshots" name="screenshots" multiple class="hidden-file-input">
                            </label>
                            <div class="hint"><i class="fas fa-info-circle"></i> Add screenshots, videos or other supporting files to help illustrate the issue</div>
                            <div class="file-size-warning" style="margin-top: 10px; background-color: #f4c42f4d; color: #d3932ffc;">
                                <strong>⚠️ IMPORTANT:</strong> Maximum total attachment size is 20MB. Files exceeding this limit will NOT be attached to the ticket.
                            </div>
                            <div id="screenshotPreview" class="screenshot-preview"></div>
                            <div id="attachmentCounter" class="attachment-counter"></div>
                        `;
                        sectionBody.appendChild(uploaderContainer);

                        // Add event listener to the file input
                        const fileInput = sectionBody.querySelector('#screenshots');
                        if (fileInput) {
                            fileInput.addEventListener('change', (e) => {
                                this.handleFileInputChange(e);
                            });
                        }
                    }

                    // If we didn't find a screenshots section, add one
                    if (!hasScreenshotsSection) {
                        console.log('Adding screenshots section as it was not found in the template');
                        const dynamicSections = document.getElementById('dynamicSections');
                        if (dynamicSections) {
                            // Create new screenshots section
                            const newScreenshotsSection = document.createElement('div');
                            newScreenshotsSection.className = 'card';
                            newScreenshotsSection.id = 'section-screenshots';

                            // Create header
                            newScreenshotsSection.innerHTML = `
                                <div class="card-header">
                                    <i class="fas fa-images fa-lg section-icon"></i>
                                    <h3>SCREENSHOTS, VIDEOS, & OTHER SUPPORTING FILE ATTACHMENTS</h3>
                                </div>
                                <div class="card-body">
                                </div>
                            `;

                            // Add to DOM
                            dynamicSections.appendChild(newScreenshotsSection);

                            // Now add content to the body
                            const sectionBody = newScreenshotsSection.querySelector('.card-body');

                            // Add a Quill editor first
                            const quillContainer = document.createElement('div');
                            quillContainer.className = 'quill-editor-container';
                            quillContainer.innerHTML = `
                                <div id="screenshotsDescriptionEditor" style="min-height: 120px;"></div>
                                <textarea id="screenshotsDescription" name="screenshotsDescription" style="display: none;"></textarea>
                                <div class="hint"><i class="fas fa-info-circle"></i> Add description for your screenshots and videos</div>
                            `;
                            sectionBody.appendChild(quillContainer);

                            // Initialize Quill editor
                            this.initializeQuillEditor('screenshotsDescription', 'screenshotsDescriptionEditor');

                            // Then add file uploader
                            const uploaderContainer = document.createElement('div');
                            uploaderContainer.className = 'attachment-input-container';
                            uploaderContainer.style.marginTop = '15px';
                            uploaderContainer.innerHTML = `
                                <label for="screenshots" class="file-upload-button">
                                    <i class="fas fa-cloud-upload-alt"></i> Upload Files
                                    <input type="file" id="screenshots" name="screenshots" multiple class="hidden-file-input">
                                </label>
                                <div class="hint"><i class="fas fa-info-circle"></i> Add screenshots, videos or other supporting files to help illustrate the issue</div>
                                <div class="file-size-warning" style="margin-top: 10px; background-color: #f4c42f4d; color: #d3932ffc;">
                                    <strong>⚠️ IMPORTANT:</strong> Maximum total attachment size is 20MB. Files exceeding this limit will NOT be attached to the ticket.
                                </div>
                                <div id="screenshotPreview" class="screenshot-preview"></div>
                                <div id="attachmentCounter" class="attachment-counter"></div>
                            `;
                            sectionBody.appendChild(uploaderContainer);

                            // Add event listener to the file input
                            const fileInput = sectionBody.querySelector('#screenshots');
                            if (fileInput) {
                                fileInput.addEventListener('change', (e) => {
                                    this.handleFileInputChange(e);
                                });
                            }
                        }
                    }

                    // Setup HAR file uploader
                    this.setupHarFileUploader();

                } catch (error) {
                    console.error('Error setting up custom file uploaders:', error);
                }
            }

            // Add this helper method to initialize Quill editors
            initializeQuillEditor(id, editorId) {
                try {
                    const editor = new Quill(`#${editorId}`, {
                        theme: 'snow',
                        placeholder: 'Add description for your files...',
                        modules: {
                            toolbar: {
                                container: [
                                    ['bold', 'italic'],
                                    [{ 'color': [] }, { 'background': [] }],
                                    [{ 'align': [] }],
                                    ['link', 'image']
                                ]
                            }
                        }
                    });

                    // Store reference to the editor
                    this.quillEditors[id] = editor;

                    // Add paste and drop handlers
                    editor.root.addEventListener('paste', e => this.handlePasteImage(e, editor));
                    editor.root.addEventListener('drop', e => this.handleDropImage(e, editor));

                    console.log(`Initialized Quill editor for ${id}`);
                } catch (error) {
                    console.error(`Error initializing Quill editor for ${id}:`, error);
                }
            }

            // Add a method to set up the HAR file uploader
            setupHarFileUploader() {
                // Apply to sim-assignment, sim-assessment-reports, sim-library-view and sim-fsa templates
                if (this.trackerType !== 'sim-assignment' &&
                    this.trackerType !== 'sim-assessment-reports' &&
                    this.trackerType !== 'sim-library-view' &&
                    this.trackerType !== 'sim-fsa') {
                    return;
                }

                // Find the HAR file attached dropdown
                const harFileAttached = document.getElementById('harFileAttached');
                if (!harFileAttached) {
                    console.warn('HAR file attached dropdown not found');
                    return;
                }

                // Find the harFileReason field and its container
                const harFileReason = document.getElementById('harFileReason');
                const harFileReasonContainer = harFileReason ? this.findParentWithClass(harFileReason, 'form-group') : null;

                if (harFileReasonContainer) {
                    // Create and add the HAR file uploader container
                    const harUploaderHTML = `
                        <div class="form-group" id="harUploaderContainer" style="display: none;">
                            <label for="harFileInput">Upload HAR File</label>
                            <div class="attachment-input-container">
                                <label for="harFileInput" class="file-upload-button">
                                    <i class="fas fa-cloud-upload-alt"></i> Choose HAR File
                                    <input type="file" id="harFileInput" name="harFileInput" accept=".har" class="hidden-file-input">
                                </label>
                                <div class="hint"><i class="fas fa-info-circle"></i> Upload a HAR file to provide detailed network information</div>
                                <div class="file-size-warning" style="margin-top: 10px; background-color: #f4c42f4d; color: #d3932ffc;">
                                    <strong>⚠️ IMPORTANT:</strong> Maximum HAR file size is 20MB.
                                </div>
                                <div id="harFilePreviewContainer" class="screenshot-preview"></div>
                            </div>
                        </div>
                    `;

                    // Insert the HAR uploader before the reason field container
                    harFileReasonContainer.insertAdjacentHTML('beforebegin', harUploaderHTML);

                    // Make sure initial state is correct
                    const uploaderContainer = document.getElementById('harUploaderContainer');
                    if (harFileAttached.value === 'Yes') {
                        if (uploaderContainer) uploaderContainer.style.display = 'block';
                        harFileReasonContainer.style.display = 'none';
                    } else {
                        if (uploaderContainer) uploaderContainer.style.display = 'none';
                        harFileReasonContainer.style.display = 'block';
                    }

                    // Add event listener to the HAR file input
                    const harFileInput = document.getElementById('harFileInput');
                    if (harFileInput) {
                        harFileInput.addEventListener('change', (e) => {
                            this.handleHarFileInputChange(e);
                        });
                    }

                    // Add change listener to harFileAttached dropdown
                    harFileAttached.addEventListener('change', function () {
                        const uploaderContainer = document.getElementById('harUploaderContainer');
                        const reasonContainer = document.getElementById('harFileReason') ?
                            window.trackerApp.findParentWithClass(document.getElementById('harFileReason'), 'form-group') : null;

                        if (this.value === 'Yes') {
                            if (uploaderContainer) uploaderContainer.style.display = 'block';
                            if (reasonContainer) {
                                reasonContainer.style.display = 'none';
                                // Remove the required indication
                                const label = reasonContainer.querySelector('label');
                                if (label) label.classList.remove('required-field');
                            }
                        } else {
                            if (uploaderContainer) uploaderContainer.style.display = 'none';
                            if (reasonContainer) {
                                reasonContainer.style.display = 'block';
                                // Add visual indication that the field is now required
                                const label = reasonContainer.querySelector('label');
                                if (label) label.classList.add('required-field');
                            }
                        }
                    });
                } else {
                    console.warn('Could not find HAR file reason container');
                }
            }

            // Add a new method specifically for handling HAR file inputs
            handleHarFileInputChange(e) {
                const file = e.target.files[0];
                if (!file) return;

                // Use the unique preview container ID
                const previewContainer = document.getElementById('harFilePreviewContainer');
                if (!previewContainer) {
                    console.error('HAR file preview container not found');
                    return;
                }

                // Clear previous preview
                previewContainer.innerHTML = '';

                // Create preview element
                const thumbnail = document.createElement('div');
                thumbnail.className = 'screenshot-thumbnail';

                // Create thumbnail content
                thumbnail.innerHTML = `
                    <div class="file-preview">
                        <i class="fas fa-file-code"></i>
                    </div>
                    <div class="screenshot-filename">${file.name}</div>
                    <div class="har-remove" data-filename="${file.name}">×</div>
                `;

                previewContainer.appendChild(thumbnail);

                // Store file for later use
                this.harFile = file;

                // Add event listener to remove button
                document.querySelector('#harFilePreviewContainer .har-remove').addEventListener('click', () => {
                    previewContainer.innerHTML = '';
                    this.harFile = null;

                    // Reset file input
                    document.getElementById('harFileInput').value = '';
                });
            }

            // Add this new method to the TrackerApp class
            ensureHiddenFields() {
                // Check for description field
                let descriptionField = document.getElementById('description');
                if (!descriptionField) {
                    // Create hidden description textarea if it doesn't exist
                    const hiddenContainer = document.querySelector('div[style="display: none;"]');
                    if (!hiddenContainer) {
                        // Create the container if it doesn't exist
                        const container = document.createElement('div');
                        container.style.display = 'none';
                        document.getElementById('trackerForm').appendChild(container);

                        // Add hidden description field
                        const textarea = document.createElement('textarea');
                        textarea.id = 'description';
                        textarea.name = 'description';
                        container.appendChild(textarea);

                        // Add hidden tracker type field
                        const input = document.createElement('input');
                        input.type = 'hidden';
                        input.id = 'trackerType';
                        input.name = 'trackerType';
                        input.value = this.trackerType;
                        container.appendChild(input);
                    } else {
                        // Just add the description field
                        const textarea = document.createElement('textarea');
                        textarea.id = 'description';
                        textarea.name = 'description';
                        hiddenContainer.appendChild(textarea);

                        // Check if tracker type field exists
                        if (!document.getElementById('trackerType')) {
                            const input = document.createElement('input');
                            input.type = 'hidden';
                            input.id = 'trackerType';
                            input.name = 'trackerType';
                            input.value = this.trackerType;
                            hiddenContainer.appendChild(input);
                        }
                    }
                }
            }

            // Replace the addAttachmentsAsNote method with this version that uses a single note
            async addAttachmentsAsNote(ticketId) {
                const hasScreenshots = this.aggregatedScreenshotFiles && this.aggregatedScreenshotFiles.length > 0;
                const hasHarFile = (this.trackerType === 'sim-assignment' ||
                    this.trackerType === 'sim-assessment-reports' ||
                    this.trackerType === 'sim-fsa') &&
                    this.harFile;

                if (!hasScreenshots && !hasHarFile) {
                    return Promise.resolve(); // Nothing to do
                }

                try {
                    console.log('Adding attachments as a single note to ticket #' + ticketId);

                    // Prepare the files to upload
                    const filesToUpload = [];

                    // Add screenshots if present
                    if (hasScreenshots) {
                        filesToUpload.push(...this.aggregatedScreenshotFiles);
                    }

                    // Add HAR file if present
                    if (hasHarFile) {
                        filesToUpload.push(this.harFile);
                        console.log('Added HAR file to upload queue:', this.harFile.name);
                    }

                    // Show progress in loading overlay
                    const loadingText = document.querySelector('.spinner-text');
                    if (loadingText) {
                        loadingText.textContent = `Preparing ${filesToUpload.length} attachments...`;
                    }

                    const progressStatus = document.querySelector('.progress-status');
                    if (progressStatus) {
                        progressStatus.textContent = `Creating note with ${filesToUpload.length} files...`;
                    }

                    // Use a single API call to add all attachments in one note
                    await this.addMultipleAttachmentsInOneNote(ticketId, filesToUpload);

                    console.log('All attachments added in a single note');
                    return Promise.resolve();
                } catch (error) {
                    console.error('Error adding attachments as note:', error);
                    return Promise.reject(error);
                }
            }

            // Add this new method to handle multiple attachments in one note
            async addMultipleAttachmentsInOneNote(ticketId, files) {
                try {
                    // Show progress
                    const progressStatus = document.querySelector('.progress-status');
                    if (progressStatus) {
                        progressStatus.textContent = `Uploading ${files.length} files...`;
                    }

                    // HARDCODED CREDENTIALS FOR TESTING ONLY - REMOVE IN PRODUCTION
                    const subdomain = "benchmarkeducationcompany"; // Your Freshdesk subdomain
                    const apiKey = "59uXal9xdL1XHfLn2D58"; // Your API key

                    console.log(`Using hardcoded credentials for testing: subdomain=${subdomain}`);

                    // Create a FormData object for proper multipart/form-data submission
                    const formData = new FormData();

                    // Create a meaningful note body that lists all files
                    let noteBody = 'Attachments:';
                    files.forEach(file => {
                        noteBody += `\n- ${file.name}`;
                    });

                    formData.append('body', noteBody);
                    formData.append('private', 'false');

                    // Add all files to the same FormData object
                    for (const file of files) {
                        // Convert file to base64
                        const base64Data = await this.readFileAsBase64(file);

                        // Convert base64 to Blob and add as attachment
                        const blob = this.base64ToBlob(base64Data, file.type || 'application/octet-stream');

                        // Add each file with the same field name (attachments[])
                        formData.append('attachments[]', blob, file.name);

                        console.log(`Added ${file.name} to form data`);
                    }

                    // Build authorization header with proper format
                    const authString = btoa(`${apiKey}:X`);

                    console.log(`Making API request to https://${subdomain}.freshdesk.com/api/v2/tickets/${ticketId}/notes with ${files.length} attachments`);

                    // Make the fetch request
                    const response = await fetch(`https://${subdomain}.freshdesk.com/api/v2/tickets/${ticketId}/notes`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Basic ${authString}`
                            // Do NOT set Content-Type - let the browser set it with boundary
                        },
                        body: formData
                    });

                    // Log the full response for debugging
                    console.log(`Response status: ${response.status}`);
                    const responseText = await response.text();
                    console.log(`Response text: ${responseText}`);

                    let data;
                    try {
                        // Try to parse JSON response
                        data = JSON.parse(responseText);
                    } catch (e) {
                        console.error("Failed to parse response as JSON", e);
                        data = { text: responseText };
                    }

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status} - ${JSON.stringify(data)}`);
                    }

                    console.log(`Successfully added all attachments in a single note to ticket #${ticketId}:`, data);

                    // Update progress
                    if (progressStatus) {
                        progressStatus.style.color = 'green';
                        progressStatus.textContent = `Successfully added ${files.length} files in a single note`;
                    }

                    return { status: response.status, response: JSON.stringify(data) };
                } catch (error) {
                    console.error('Error adding multiple attachments:', error);
                    throw error;
                }
            }

            // Add this new method to debug district fields
            debugDistrictFields() {
                try {
                    console.group('District and Product Fields Debug');

                    // Log all district-related fields
                    const districtFields = document.querySelectorAll('[id*="district"], [id*="District"]');
                    console.log(`Found ${districtFields.length} district-related fields`);

                    districtFields.forEach(field => {
                        console.log(`Field ID: ${field.id}, Value: "${field.value}", Type: ${field.type}, ReadOnly: ${field.readOnly}`);
                    });

                    // Log product field information
                    console.log("Product Fields information:");
                    if (this.ticketData) {
                        console.log("Product Type:", this.ticketData.productType || "Not set");
                        console.log("Product:", this.ticketData.product || "Not set");
                        console.log("Product Subsection:", this.ticketData.productSubsection || "Not set");
                    } else {
                        console.log("No product fields found in ticketData");
                    }

                    // Only try to get ticket data if client is initialized
                    if (this.client && this.client.data) {
                        // Use a safer approach that won't interrupt initialization
                        setTimeout(() => {
                            this.client.data.get("ticket").then(ticketData => {
                                console.log("Parent ticket data:", ticketData);

                                if (ticketData && ticketData.ticket && ticketData.ticket.custom_fields) {
                                    console.log("Custom fields:", ticketData.ticket.custom_fields);

                                    // Look for district field in all possible locations
                                    let districtValue = null;
                                    const customFields = ticketData.ticket.custom_fields;

                                    // Only check cf_district509811 field
                                    if (customFields.cf_district509811) {
                                        districtValue = customFields.cf_district509811;
                                    }

                                    console.log("District value from parent ticket:", districtValue);

                                    // Populate district fields if found
                                    if (districtValue) {
                                        const districtField = document.getElementById('districtField');
                                        const districtNameField = document.getElementById('districtName');

                                        if (districtField) {
                                            districtField.value = districtValue;
                                            console.log(`Set districtField to "${districtValue}"`);
                                        }

                                        if (districtNameField) {
                                            districtNameField.value = districtValue;
                                            console.log(`Set districtNameField to "${districtValue}"`);

                                            // Style it as read-only
                                            districtNameField.readOnly = true;
                                            districtNameField.style.backgroundColor = '#f0f0f0';
                                            districtNameField.style.color = '#666';
                                            districtNameField.style.border = '1px solid #ddd';
                                            districtNameField.style.cursor = 'not-allowed';
                                        }
                                    }
                                }
                            }).catch(err => {
                                // Just log the error but don't let it interrupt initialization
                                console.error("Error getting ticket data during debug:", err);
                            });
                        }, 100); // Small delay to ensure initialization continues
                    }

                    console.groupEnd();
                } catch (error) {
                    // Catch any errors but don't let them interrupt initialization
                    console.error("Error in debug logging:", error);
                    console.groupEnd();
                }
            }

            // Find the fixImageUrls method and add this new method beneath it

            fixSIMAssignmentDescription(description) {
                // Check if STEPS TO REPRODUCE section is missing
                if (!description.includes('STEPS TO REPRODUCE') && document.getElementById('stepsToReproduce')) {
                    console.log("Steps to reproduce section missing, fixing it");
                    const stepsToReproduce = document.getElementById('stepsToReproduce').value;

                    // Find where to insert the steps section (after user info)
                    const userInfoEndIndex = description.indexOf('</div><div style="margin-bottom: 20px;"></div><div style="color: #000000;"><span style="text-decoration: underline; background-color: #c1e9d9;">EXPECTED RESULTS');

                    if (userInfoEndIndex !== -1 && stepsToReproduce) {
                        const beforeSteps = description.substring(0, userInfoEndIndex);
                        const afterSteps = description.substring(userInfoEndIndex);

                        // Create steps section
                        const stepsSection = `</div><div style="margin-bottom: 20px;"></div><div style="color: #000000;"><span style="text-decoration: underline; background-color: #c1e9d9;">STEPS TO REPRODUCE</span></div><div>${stepsToReproduce}</div>`;

                        // Insert steps section
                        description = beforeSteps + stepsSection + afterSteps;
                    }
                }

                return description;
            }

            // Add this method to your TrackerApp class
            async uploadAttachmentDirectly(ticketId, file, noteBody) {
                try {
                    // Get the subdomain from iparams
                    const iparams = await this.client.iparams.get("freshdesk_subdomain");
                    const subdomain = iparams.freshdesk_subdomain;

                    // Convert file to base64 for transport
                    const base64Content = await this.readFileAsBase64(file);

                    // Create a FormData object
                    const formData = new FormData();
                    formData.append('body', noteBody || `Attachment: ${file.name}`);
                    formData.append('private', 'false');

                    // Convert base64 back to a file
                    const blob = this.base64ToBlob(base64Content, file.type);
                    formData.append('attachments[]', blob, file.name);

                    // Use the browser's fetch API to make the request
                    const response = await fetch(`https://${subdomain}.freshdesk.com/api/v2/tickets/${ticketId}/notes`, {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Basic ' + btoa(iparams.freshdesk_api_key + ':X')
                        },
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`API error: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Error uploading attachment directly:', error);
                    throw error;
                }
            }

            // Helper method to convert base64 to Blob
            base64ToBlob(base64, mimeType) {
                const byteString = atob(base64);
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);

                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }

                return new Blob([ab], { type: mimeType || 'application/octet-stream' });
            }

            // Add new method to fetch company data and populate district state
            async fetchCompanyState(companyId) {
                console.log(`Fetching company data for ID: ${companyId}`);

                try {
                    // Make API request to get company data
                    const response = await this.client.request.invokeTemplate("getCompanyDetails", {
                        context: { companyId: companyId }
                    });

                    const companyData = JSON.parse(response.response);
                    console.log("Company data:", companyData);

                    // Extract state from custom fields
                    if (companyData && companyData.custom_fields) {
                        const stateValue = companyData.custom_fields.state;

                        if (stateValue) {
                            console.log(`Found company state: ${stateValue}`);

                            // Find all district state fields and populate them
                            const districtStateFields = document.querySelectorAll('input[id="districtState"]');
                            if (districtStateFields.length > 0) {
                                districtStateFields.forEach(field => {
                                    field.value = stateValue;
                                    console.log(`Set district state field to: ${stateValue}`);
                                });
                            } else {
                                console.warn("No district state fields found to populate");
                            }
                        } else {
                            console.log("Company has no state custom field");
                        }
                    } else {
                        console.warn("Company data doesn't contain custom fields");
                    }
                } catch (error) {
                    console.error("Error fetching company state:", error);
                }
            }

            // Add this new method to your TrackerApp class
            setupSmartsheetUploader() {
                // Find the attachmentInfo field in the ATTACH SMARTSHEET section
                const smartsheetSection = document.getElementById('section-attachments');
                if (!smartsheetSection) return;

                const sectionBody = smartsheetSection.querySelector('.card-body');
                if (!sectionBody) return;

                // COMPLETELY REPLACE the content with our editor and uploader
                sectionBody.innerHTML = '';

                // First add the Quill editor container
                const quillContainer = document.createElement('div');
                quillContainer.className = 'quill-editor-container';
                quillContainer.innerHTML = `
                    <div id="smartsheetNotesEditor" style="min-height: 120px;"></div>
                    <textarea id="smartsheetNotes" name="smartsheetNotes" style="display: none;"></textarea>
                `;
                sectionBody.appendChild(quillContainer);

                // Then create a file uploader element below the editor
                const uploaderContainer = document.createElement('div');
                uploaderContainer.className = 'smartsheet-uploader';
                uploaderContainer.style.marginTop = '15px';
                uploaderContainer.innerHTML = `
                    <label for="smartsheetFile" class="file-upload-button">
                        <i class="fas fa-cloud-upload-alt"></i> Upload Smartsheet
                        <input type="file" id="smartsheetFile" name="smartsheetFile" class="hidden-file-input">
                    </label>
                    <div class="hint"><i class="fas fa-info-circle"></i> Upload the completed Benchmark eAssessments Custom Achievement Levels form</div>
                    <div id="smartsheetPreview" class="screenshot-preview"></div>
                `;
                sectionBody.appendChild(uploaderContainer);

                // Initialize the Quill editor with image support
                this.initSmartsheetQuillEditor();

                // Add event listener for file selection
                const fileInput = document.getElementById('smartsheetFile');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        this.handleSmartsheetFileChange(e);
                    });
                }
            }

            // Add this new method to initialize the Smartsheet Quill editor
            initSmartsheetQuillEditor() {
                try {
                    // Define a custom image handler for the toolbar
                    const customImageHandler = () => {
                        const input = document.createElement('input');
                        input.setAttribute('type', 'file');
                        input.setAttribute('accept', 'image/*');
                        input.click();

                        input.onchange = () => {
                            if (input.files && input.files[0]) {
                                const file = input.files[0];

                                // Show loading indicator
                                const range = editor.getSelection(true);
                                editor.insertText(range.index, "Uploading image... ", { italic: true, color: '#999' });
                                const placeholderIndex = range.index;

                                // Upload to ImgBB
                                this.uploadImageToImgBB(file).then(imageUrl => {
                                    // Delete the placeholder text
                                    editor.deleteText(placeholderIndex, "Uploading image... ".length);

                                    // Insert the image
                                    editor.insertEmbed(placeholderIndex, 'image', imageUrl);
                                    editor.setSelection(placeholderIndex + 1);
                                }).catch(error => {
                                    console.error('Error uploading image:', error);

                                    // Replace placeholder with error message
                                    editor.deleteText(placeholderIndex, "Uploading image... ".length);
                                    editor.insertText(placeholderIndex, "⚠️ Image upload failed ", { italic: true, color: 'red' });
                                });
                            }
                        };
                    };

                    // Initialize the editor
                    const editor = new Quill('#smartsheetNotesEditor', {
                        theme: 'snow',
                        placeholder: 'Add notes, paste screenshots, or add additional context...',
                        modules: {
                            toolbar: {
                                container: [
                                    ['bold', 'italic'],                      // Bold and italic
                                    [{ 'color': [] }, { 'background': [] }], // Color and highlight
                                    [{ 'align': [] }],                       // Alignment
                                    ['link', 'image']                        // Link and image
                                ],
                                handlers: {
                                    'image': customImageHandler.bind(this)
                                }
                            }
                        }
                    });

                    // Make sure the editor is enabled
                    editor.enable();

                    // Store reference to the editor
                    this.quillEditors['smartsheetNotes'] = editor;

                    // Add paste image handling
                    editor.root.addEventListener('paste', e => this.handlePasteImage(e, editor));

                    // Add drop handling for images
                    editor.root.addEventListener('drop', e => this.handleDropImage(e, editor));

                    // Update textarea when editor changes
                    editor.on('text-change', () => {
                        const textarea = document.getElementById('smartsheetNotes');
                        if (textarea) {
                            textarea.value = editor.root.innerHTML;
                        }
                    });

                    console.log('Smartsheet Quill editor initialized successfully');
                } catch (error) {
                    console.error('Error initializing Smartsheet Quill editor:', error);
                }
            }

            // Add this method to handle smartsheet file selection
            handleSmartsheetFileChange(e) {
                const file = e.target.files[0];
                if (!file) return;

                const previewContainer = document.getElementById('smartsheetPreview');
                previewContainer.innerHTML = '';

                // Create thumbnail preview
                const thumbnail = document.createElement('div');
                thumbnail.className = 'screenshot-thumbnail';

                // Create thumbnail content based on file type
                const fileTypeIcon = this.getFileTypeIcon(file.type);
                thumbnail.innerHTML = `
                    <div class="file-preview">
                        <i class="${fileTypeIcon}"></i>
                    </div>
                    <div class="screenshot-filename">${file.name}</div>
                    <div class="screenshot-remove" data-filename="${file.name}">×</div>
                `;

                previewContainer.appendChild(thumbnail);

                // Add to screenshots array to be included with other attachments
                this.aggregatedScreenshotFiles.push(file);

                // Add event listener to remove button
                thumbnail.querySelector('.screenshot-remove').addEventListener('click', (e) => {
                    const filename = e.target.getAttribute('data-filename');
                    this.removeFile(filename);
                    previewContainer.innerHTML = '';
                });
            }

            // Add this new method to the TrackerApp class
            startVipStatusMonitor() {
                // Check the VIP status in the subject line every 2 seconds
                this.vipStatusInterval = setInterval(() => {
                    const formattedSubjectField = document.getElementById('formattedSubject');
                    if (formattedSubjectField && this._cachedSubjectLine) {
                        // If the subject no longer matches our cached value, restore it
                        if (formattedSubjectField.value !== this._cachedSubjectLine) {
                            console.log("Subject line changed, restoring with VIP status",
                                "From:", formattedSubjectField.value,
                                "To:", this._cachedSubjectLine);

                            formattedSubjectField.value = this._cachedSubjectLine;

                            // Also update the hidden subject field
                            const subjectField = document.getElementById('subject');
                            if (subjectField) {
                                subjectField.value = this._cachedSubjectLine;
                            }
                        }
                    }
                }, 2000);

                // Clear the interval when the page is unloaded
                window.addEventListener('beforeunload', () => {
                    if (this.vipStatusInterval) {
                        clearInterval(this.vipStatusInterval);
                    }
                });
            }

            // Add this to the TrackerApp class near the debugDistrictFields method
            debugDistrictSubmission(ticketData) {
                console.group('District Field Submission Debug');
                console.log('Final ticket data for submission:', ticketData);

                // Check custom fields specifically
                if (ticketData.custom_fields) {
                    console.log('Custom fields being submitted:');
                    Object.keys(ticketData.custom_fields).forEach(key => {
                        console.log(`${key}: ${ticketData.custom_fields[key]} (${typeof ticketData.custom_fields[key]})`);
                    });

                    // Specifically check for the district fields
                    console.log('District field (cf_district):',
                        ticketData.custom_fields.cf_district || 'NOT SET');
                    console.log('District dropdown field (cf_district509811):',
                        ticketData.custom_fields.cf_district509811 || 'NOT SET');
                } else {
                    console.warn('No custom fields found in ticket data!');
                }

                console.groupEnd();
            }

            // Add this new method to your TrackerApp class
            async preserveDistrictFieldFormat(ticketData, sourceTicketId) {
                try {
                    // Get the exact format of the district dropdown from the source ticket
                    const response = await this.client.request.invokeTemplate("getTicketDetails", {
                        context: { ticketId: sourceTicketId }
                    });

                    const sourceTicket = JSON.parse(response.response);
                    if (sourceTicket && sourceTicket.custom_fields) {
                        // Get the district dropdown field value with its exact type/format
                        const districtDropdownValue = sourceTicket.custom_fields.cf_district509811;

                        console.log('Source ticket district dropdown field:', districtDropdownValue,
                            'Type:', typeof districtDropdownValue);

                        // Copy the exact value to preserve format
                        if (districtDropdownValue !== undefined) {
                            ticketData.custom_fields.cf_district509811 = districtDropdownValue;
                            console.log('Preserved exact format of district dropdown field');
                        }

                        // ADD THIS NEW CODE:
                        // Check VIP status and set priority accordingly
                        const vipFields = ['cf_vip', 'vip', 'cf_vip_status', 'vip_customer', 'cf_is_vip'];
                        for (const field of vipFields) {
                            if (sourceTicket.custom_fields[field] !== undefined) {
                                const fieldValue = sourceTicket.custom_fields[field];
                                const isVip = fieldValue === true ||
                                    fieldValue === "true" ||
                                    fieldValue === "Yes";

                                if (isVip) {
                                    console.log("Setting ticket priority to HIGH (3) based on VIP status");
                                    ticketData.priority = 3;
                                    break;
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error preserving district field format:', error);
                }

                return ticketData;
            }

            // Add this debugging method to investigate dropdown options
            async inspectDistrictDropdownField() {
                try {
                    // Get the ticket form fields to check dropdown options
                    const response = await this.client.request.invokeTemplate("getTicketFields", {});
                    const fields = JSON.parse(response.response);

                    // Find the district dropdown field
                    const districtField = fields.find(f => f.name === 'cf_district509811');

                    if (districtField) {
                        console.log('District dropdown field options:', districtField.choices);

                        // If this is a company value, we might need to handle it differently
                        if (districtField.type === 'company_lookup') {
                            console.log('This is a company lookup field, needs special handling!');
                        }
                    } else {
                        console.log('Could not find district dropdown field');
                    }
                } catch (error) {
                    console.error('Error inspecting district dropdown field:', error);
                }
            }

            // Add this new method
            async checkAndUpdateVIPStatus() {
                const relatedTicketsField = document.getElementById('relatedTickets');
                if (!relatedTicketsField || !relatedTicketsField.value) return false;

                try {
                    const sourceTicketId = parseInt(relatedTicketsField.value.split(',')[0], 10);
                    if (isNaN(sourceTicketId)) return false;

                    const response = await this.client.request.invokeTemplate("getTicketDetails", {
                        context: { ticketId: sourceTicketId }
                    });

                    const ticketData = JSON.parse(response.response);
                    if (!ticketData || !ticketData.custom_fields) return false;

                    // Check all possible VIP fields
                    const vipFields = ['cf_vip', 'vip', 'cf_vip_status', 'vip_customer', 'cf_is_vip'];
                    for (const field of vipFields) {
                        if (ticketData.custom_fields[field] !== undefined) {
                            const fieldValue = ticketData.custom_fields[field];
                            this.ticketData.isVip = fieldValue === true ||
                                fieldValue === "true" ||
                                fieldValue === "Yes";

                            console.log(`Direct VIP check - Found in ${field}:`, this.ticketData.isVip);
                            return true;
                        }
                    }
                    return false;
                } catch (error) {
                    console.error("Error in direct VIP status check:", error);
                    return false;
                }
            }

            // Modify updateAchievementLevelsSubject to use this
            async updateAchievementLevelsSubject() {
                try {
                    // Try to get updated VIP status
                    await this.checkAndUpdateVIPStatus();

                    // Rest of your existing code...
                    const districtNameField = document.getElementById('districtName');
                    const districtName = districtNameField ? districtNameField.value || '' : '';

                    // VIP prefix based on the ticketData property
                    const vipPrefix = this.ticketData && this.ticketData.isVip ? 'VIP* ' : '';

                    // Format the subject line
                    const subject = `${vipPrefix}${districtName} | Custom Achievement Levels`;

                    // Update the subject field directly in the DOM
                    const formattedSubjectField = document.getElementById('formattedSubject');
                    if (formattedSubjectField) {
                        formattedSubjectField.value = subject;

                        // Also update the hidden subject field if it exists
                        const subjectField = document.getElementById('subject');
                        if (subjectField) {
                            subjectField.value = subject;
                        }

                        // Store the generated subject for future reference
                        this._cachedSubjectLine = subject;
                    }

                    console.log('Updated Achievement Levels subject with VIP status:', subject);
                } catch (error) {
                    console.log('Error updating achievement levels subject:', error);
                }
            }

            // Add this method to your TrackerApp class
            debugVipPriority() {
                console.group('VIP Priority Debug');
                console.log('Current priority setting:', document.getElementById('priority')?.value);
                console.log('ticketData.isVip:', this.ticketData?.isVip);
                console.log('ticketData.priority:', this.ticketData?.priority);
                console.log('VIP checkbox value:', document.getElementById('hiddenVIPStatus')?.checked);
                console.groupEnd();
            }

            // Add this method to the TrackerApp class
            updateSimFsaSubject() {
                const isVIPField = document.querySelector('select[name="isVIP"]');
                const districtNameField = document.querySelector('input[name="districtName"]');
                const applicationField = document.querySelector('input[name="application"]');
                const specificIssueField = document.querySelector('input[name="specificIssue"]');

                // Get all checked user role checkboxes
                const userRoleCheckboxes = document.querySelectorAll('input[name="userRole"]:checked');
                const selectedRoles = Array.from(userRoleCheckboxes).map(cb => cb.value);
                const formattedUserRole = this.formatUserRoles(selectedRoles);

                // Build the subject line
                let subject = '';
                if (isVIPField && isVIPField.value === 'Yes') {
                    subject += 'VIP* ';
                }
                if (districtNameField && districtNameField.value) {
                    subject += `${districtNameField.value} | `;
                }
                if (applicationField && applicationField.value) {
                    subject += applicationField.value;
                }
                if (specificIssueField && specificIssueField.value) {
                    subject += ` - ${specificIssueField.value}`;
                }
                if (formattedUserRole) {
                    subject += ` for ${formattedUserRole}`;
                }

                // Update both the formatted and hidden subject fields
                const formattedSubjectField = document.querySelector('input[name="formattedSubject"]');
                const hiddenSubjectField = document.querySelector('input[name="subject"]');

                if (formattedSubjectField) {
                    formattedSubjectField.value = subject;
                }
                if (hiddenSubjectField) {
                    hiddenSubjectField.value = subject;
                }
            }

            updateSimLibraryViewSubject() {
                const isVIP = document.getElementById('isVIP')?.value || 'No';
                const vipPrefix = isVIP === "Yes" ? "VIP * " : "";
                const districtValue = document.getElementById('districtName')?.value || '';
                const applicationValue = document.getElementById('application')?.value || '';
                const specificIssueValue = document.getElementById('specificIssue')?.value || '';

                // Get all checked user role checkboxes
                const userRoleCheckboxes = document.querySelectorAll('input[name="userRole"]:checked');
                const selectedRoles = Array.from(userRoleCheckboxes).map(cb => cb.value);
                const formattedUserRole = this.formatUserRoles(selectedRoles);

                // Only add the "for" part if there are selected roles
                const userRolePart = formattedUserRole ? ` for ${formattedUserRole}` : '';

                const formattedSubject =
                    `${vipPrefix}${districtValue} | ${applicationValue} - ${specificIssueValue}${userRolePart}`;

                const formattedSubjectField = document.getElementById('formattedSubject');
                if (formattedSubjectField) {
                    formattedSubjectField.value = formattedSubject;

                    // Also update the hidden subject field
                    const subjectField = document.getElementById('subject');
                    if (subjectField) {
                        subjectField.value = formattedSubject;
                    }
                }
            }

            // Add this helper method to format user roles
            formatUserRoles(selectedRoles) {
                // If "All Users" is selected, return that
                if (selectedRoles.includes('allUsers')) {
                    return "All Users";
                }

                // If all three individual roles are selected, return "All Users"
                if (selectedRoles.includes('students') &&
                    selectedRoles.includes('teachers') &&
                    selectedRoles.includes('admin')) {
                    return "All Users";
                }

                // Format multiple selections
                const roleMap = {
                    'students': 'Students',
                    'teachers': 'Teachers',
                    'admin': 'Admin'
                };

                const selectedLabels = selectedRoles
                    .filter(role => role !== 'allUsers')
                    .map(role => roleMap[role]);

                // At this point, we should only have 1 or 2 roles
                // Join with & if there are 2 roles
                if (selectedLabels.length === 2) {
                    return selectedLabels.join(' & ');
                }

                // Return single role
                return selectedLabels[0] || '';
            }

            // Helper method to call the appropriate subject update method
            updateSubjectLine() {
                switch (this.trackerType) {
                    case 'sim-assignment':
                        this.updateSimAssignmentSubject();
                        break;
                    case 'sim-assessment-reports':
                        this.updateSIMAssessmentReportsSubject();
                        break;
                    case 'sim-fsa':
                        this.updateSimFsaSubject();
                        break;
                    case 'sim-library-view':
                        this.updateSimLibraryViewSubject();
                        break;
                }
            }
        }
    </script>
</body>

</html>