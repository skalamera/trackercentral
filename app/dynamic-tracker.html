<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script async src="{{{appclient}}}"></script>
    <link rel="stylesheet" type="text/css" href="styles/style.css" /> <!-- Add this line for theme variables -->
    <link rel="stylesheet" type="text/css" href="styles/dynamic-tracker.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <script src="tracker-config.js"></script>
    <style>
        div.card-header {
            background-color: var(--heading-color, #2C3E50);
            color: white;
        }

        /* ... existing styles ... */

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 5px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-input {
            margin: 0;
        }

        .checkbox-label {
            margin: 0;
            font-weight: normal;
        }

        .har-errors {
            color: #dc3545;
        }

        .har-redirects {
            color: #007bff;
        }

        .har-slow {
            color: #fd7e14;
        }

        .invalid-har {
            border-color: #ffc107;
        }

        /* Style for read-only and disabled formattedSubject fields */
        input[id="formattedSubject"][readonly][disabled] {
            background-color: var(--input-bg, #f5f5f5);
            color: var(--input-text, #666);
            border: 1px solid var(--input-border, #ddd);
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* Dark mode toggle button */
        .theme-toggle-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: transparent;
            border: none;
            color: var(--text-color, #333);
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            transition: background-color 0.3s;
            z-index: 10;
        }

        .theme-toggle-btn:hover {
            background-color: var(--hover-bg, #f8f9fa);
        }

        /* Notification animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }

            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <!-- Dark mode toggle button -->
    <button id="themeToggleBtn" class="theme-toggle-btn" title="Toggle Dark Mode">
        <i class="fas fa-sun"></i>
    </button>

    <!-- Loading overlay -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <div class="spinner-text">Creating ticket...</div>
        <div class="progress-status" style="margin-top: 10px; font-size: 12px;"></div>
    </div>
    <!-- Debug Button 
    <div class="tracker-form-container">
        <div class="debug-container">
            <button id="debugFillForm" class="debug-button">Fill Form with Demo Data</button>
        </div>-->

    <!-- Form Title -->
    <div class="form-title">
        <h2 id="trackerTitle">Dynamic Tracker</h2>
    </div>

    <!-- Back Button -->
    <div class="back-button-container">
        <fw-button id="backButton" color="secondary" size="small"
            style="cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.2s ease;"
            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)';"
            onmouseout="this.style.transform=''; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';">
            <i class="fas fa-arrow-left" style="margin-right: 8px;"></i>Back to Tracker Templates
        </fw-button>
    </div>

    <form id="trackerForm">
        <div class="cards-container" id="dynamicSections">
            <!-- Dynamic sections will be inserted here -->
        </div>

        <!-- Common ticket properties section -->
        <div class="card">
            <div class="card-header">
                <i class="fas fa-tasks fa-lg section-icon"></i>
                <h3>Ticket Properties</h3>
            </div>
            <div class="card-body">
                <div class="form-group">
                    <label for="email" class="required-field">Requester Email</label>
                    <div class="input-with-icon">
                        <input type="email" id="email" name="email" required>
                    </div>
                    <div class="hint"><i class="fas fa-info-circle"></i> This ticket will be created by you (the
                        logged-in agent)</div>
                    <div id="emailStatus" class="email-status"></div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="relatedTickets" class="required-field">Related Ticket IDs</label>
                        <div class="input-with-icon">
                            <input type="text" id="relatedTickets" name="relatedTickets" required>
                        </div>
                        <div class="hint"><i class="fas fa-info-circle"></i> <strong>Required:</strong>
                            Comma-separated ticket IDs (e.g., 1,2,3). At least one ticket ID is required to create a
                            tracker.</div>
                    </div>

                    <div class="form-group">
                        <label for="priority">Priority</label>
                        <select id="priority" name="priority">
                            <option value="1">Low</option>
                            <option value="2">Medium</option>
                            <option value="3">High</option>
                            <option value="4">Urgent</option>
                        </select>
                        <div class="hint"><i class="fas fa-info-circle"></i> Select ticket priority</div>
                    </div>

                    <div class="form-group">
                        <label for="status">Status</label>
                        <select id="status" name="status">
                            <option value="2">Open</option>
                            <option value="3">Pending</option>
                            <option value="4">Resolved</option>
                            <option value="5">Closed</option>
                        </select>
                        <div class="hint"><i class="fas fa-info-circle"></i> Select ticket status</div>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="groupField">Group</label>
                        <select id="groupField" name="groupField">
                            <option>Loading groups...</option>
                        </select>
                        <div class="hint"><i class="fas fa-info-circle"></i> Select a support group</div>
                    </div>

                    <div class="form-group">
                        <label for="agentField">Agent</label>
                        <select id="agentField" name="agentField"></select>
                        <div class="hint"><i class="fas fa-info-circle"></i> Select an agent</div>
                    </div>

                    <div class="form-group">
                        <label for="districtField">District</label>
                        <input type="text" id="districtField" name="districtField" readonly>
                        <div class="hint"><i class="fas fa-info-circle"></i> Auto-populated from source ticket</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Attachments card -->
        <div class="card">
            <div class="card-header">
                <i class="fas fa-paperclip fa-lg section-icon"></i>
                <h3>ATTACHMENTS</h3>
            </div>
            <div class="card-body">
                <div class="attachment-input-container">
                    <label for="screenshots" class="file-upload-button">
                        <i class="fas fa-cloud-upload-alt"></i> Choose files
                        <input type="file" id="screenshots" name="screenshots" multiple class="hidden-file-input">
                    </label>
                    <div class="hint"><i class="fas fa-info-circle"></i> Upload files to include in the ticket (15MB
                        total)</div>
                </div>
                <div id="screenshotPreview" class="screenshot-preview"></div>
                <div id="attachmentCounter" class="attachment-counter"></div>
            </div>
        </div>
        <div style="display: none;">
            <textarea id="description" name="description"></textarea>
            <input type="hidden" id="trackerType" name="trackerType">
        </div>

        <div class="form-actions">
            <fw-button id="cancelTracker" color="secondary" size="small">
                <i class="fas fa-times" style="margin-right: 8px;"></i>Cancel
            </fw-button>

            <fw-button id="saveAsDraft" color="warning" size="small" style="margin-left: 10px;">
                <i class="fas fa-save" style="margin-right: 8px;"></i>Save as Draft
            </fw-button>

            <fw-button id="createTracker" color="primary" type="submit" size="small" style="margin-left: 10px;">
                <i class="fas fa-check" style="margin-right: 8px;"></i>Create Tracker
            </fw-button>
        </div>
        </div>
        </div>
    </form>
    </div>

    <script>
        // Initialize dark mode theme on page load
        document.addEventListener('DOMContentLoaded', function () {
            initTheme();
        });

        // Initialize dark mode based on saved preference
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeIcon(savedTheme);

            // Add event listener for theme toggle
            const themeToggleBtn = document.getElementById('themeToggleBtn');
            if (themeToggleBtn) {
                themeToggleBtn.addEventListener('click', toggleTheme);
            }
        }

        // Toggle between light and dark mode
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);

            updateThemeIcon(newTheme);
            console.log(`Theme switched to ${newTheme} mode`);
        }

        // Update the theme toggle icon based on current theme
        function updateThemeIcon(theme) {
            const themeToggleBtn = document.getElementById('themeToggleBtn');
            if (themeToggleBtn) {
                if (theme === 'dark') {
                    themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
                    themeToggleBtn.title = 'Switch to Light Mode';
                } else {
                    themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
                    themeToggleBtn.title = 'Switch to Dark Mode';
                }
            }
        }

        // Initialize the app when page fully loads
        document.onreadystatechange = function () {
            if (document.readyState === "complete") {
                console.log("Dynamic tracker template initializing...");
                // Get the tracker type from URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const trackerType = urlParams.get('type') || 'blank';

                // Store tracker type in hidden field
                document.getElementById('trackerType').value = trackerType;

                // Log the tracker type
                console.log("Loading tracker template:", trackerType);

                // Extra logging for assembly trackers
                if (trackerType === 'assembly' || trackerType === 'assembly-rollover') {
                    console.log(`This is an ASSEMBLY tracker (${trackerType}). Source tickets will be tagged with "ESCALATED TO ASSEMBLY"`);
                }

                // Get the config for this tracker type
                const config = TRACKER_CONFIGS[trackerType] || {
                    title: "Blank Tracker",
                    icon: "fa-file",
                    description: "Generic tracker template",
                    sections: []
                };

                // If this is the SIM Assignment template, ensure there's no attachments card
                if (trackerType === 'sim-assignment') {
                    // Filter out any attachments section that might have been added
                    config.sections = config.sections.filter(section => section.id !== 'attachments');
                }

                // Set the page title
                document.getElementById('trackerTitle').innerHTML = `<i class="fas ${config.icon} mr-2"></i> ${config.title}`;
                document.title = config.title;

                // Build dynamic sections based on configuration
                buildDynamicSections(config);

                // Initialize the app
                initializeTrackerApp(trackerType, config);
            }
        };

        function buildDynamicSections(config) {
            const container = document.getElementById('dynamicSections');

            // Clear any existing content
            container.innerHTML = '';

            // Add each section defined in the config
            config.sections.forEach(section => {
                // Skip the "attachments" section for the SIM Assignment template
                if (config.title === "SIM Assignment Tracker" && section.id === "attachments") {
                    return; // Skip this section
                }

                const sectionHtml = buildSection(section);
                container.innerHTML += sectionHtml;
            });
        }

        function buildSection(section) {
            let html = `
                <div class="card" id="section-${section.id}">
                    <div class="card-header">
                        <i class="fas ${section.icon} fa-lg section-icon"></i>
                        <h3>${section.title}</h3>
                    </div>
                    <div class="card-body">
                        ${buildFields(section.fields)}
                    </div>
                </div>
            `;
            return html;
        }

        function buildFields(fields) {
            let html = '';

            fields.forEach(field => {
                // Check if this field should be hidden initially (for Report Type field)
                let initialStyle = '';
                if (field.id === 'reportType' && field.showIf) {
                    // Hide the Report Type field initially
                    initialStyle = ' style="display: none;"';
                }

                html += `<div class="form-group"${initialStyle}>`;

                // Add label if not a richtext editor with empty label
                if (!(field.type === 'richtext' && field.label === '')) {
                    html += `<label for="${field.id}" ${field.required ? 'class="required-field"' : ''}>${field.label}</label>`;
                }

                // For select fields, we'll update them after rendering if they need custom values
                let needsCustomValues = false;
                if (field.type === 'select' && (field.id === 'version' || field.id === 'versionState')) {
                    needsCustomValues = true;
                }

                // Add the appropriate input based on field type
                switch (field.type) {
                    case 'text':
                        html += `<input type="text" id="${field.id}" name="${field.id}" ${field.required ? 'required' : ''} ${field.placeholder ? `placeholder="${field.placeholder}"` : ''}>`;
                        break;

                    case 'email':
                        html += `<input type="email" id="${field.id}" name="${field.id}" ${field.required ? 'required' : ''}>`;
                        break;

                    case 'textarea':
                        html += `<textarea id="${field.id}" name="${field.id}" rows="4" ${field.required ? 'required' : ''}></textarea>`;
                        break;

                    case 'date':
                        html += `<input type="date" id="${field.id}" name="${field.id}" ${field.required ? 'required' : ''}>`;
                        break;

                    case 'select':
                        html += `
                            <select id="${field.id}" name="${field.id}" ${field.required ? 'required' : ''}>
                                ${field.options.map(option => `<option value="${option}">${option}</option>`).join('')}
                            </select>
                        `;
                        break;

                    case 'richtext':
                        html += `
                            <div class="quill-editor-container">
                                <div id="${field.id}Editor" style="min-height: 120px;"></div>
                                <textarea id="${field.id}" name="${field.id}" style="display: none;"></textarea>
                            </div>
                        `;
                        break;

                    case 'checkboxes':
                        html += `<div class="checkbox-group">`;
                        field.options.forEach(option => {
                            html += `
                                <div class="checkbox-item">
                                    <input type="checkbox" 
                                        id="${option.id}" 
                                        name="${field.id}" 
                                        value="${option.id}"
                                        class="checkbox-input">
                                    <label for="${option.id}" class="checkbox-label">${option.label}</label>
                                </div>
                            `;
                        });
                        html += `</div>`;
                        break;

                    default:
                        html += `<input type="text" id="${field.id}" name="${field.id}" ${field.required ? 'required' : ''}>`;
                }

                // Add hint if provided
                if (field.hint) {
                    html += `<div class="hint"><i class="fas fa-info-circle"></i> ${field.hint}</div>`;
                }

                html += `</div>`;

                // If this is a field that needs custom values, trigger the lookup after rendering
                if (needsCustomValues) {
                    // Use setTimeout to ensure the DOM is ready
                    setTimeout(() => {
                        getCustomDropdownValues(field.id);
                    }, 100);
                }
            });

            return html;
        }

        // Helper function to get custom dropdown values from Freshdesk storage with localStorage fallback
        function getCustomDropdownValues(fieldId) {
            // Cache for dropdown values to avoid multiple API calls
            if (!window.dropdownValuesCache) {
                window.dropdownValuesCache = {};
            }

            // If we have cached values, return them immediately
            if (window.dropdownValuesCache[fieldId]) {
                return window.dropdownValuesCache[fieldId];
            }

            try {
                // Check if we have a client available
                if (!window.trackerApp || !window.trackerApp.client) {
                    console.warn(`Client not available for loading ${fieldId} values, will try again later`);
                    // Retry after a delay when client might be available
                    setTimeout(() => {
                        getCustomDropdownValues(fieldId);
                    }, 500);
                    return null;
                }

                const client = window.trackerApp.client;

                // Map field IDs to storage keys
                const storageKey = fieldId === 'version' ? 'customVersionValues' :
                    fieldId === 'versionState' ? 'customLocationValues' : null;

                if (!storageKey) return null;

                // Start loading values from Freshdesk storage with fallback to localStorage only for connectivity issues
                client.db.get(storageKey)
                    .catch(error => {
                        console.error(`Error loading ${fieldId} values from Freshdesk DB:`, error);

                        // Try to get from localStorage as fallback only for connectivity issues
                        try {
                            const localValues = localStorage.getItem(storageKey);
                            if (localValues) {
                                console.warn(`Using cached localStorage values for ${fieldId} due to Freshdesk DB error`);
                                return JSON.parse(localValues);
                            }
                        } catch (localError) {
                            console.error(`Error reading from localStorage for ${fieldId}:`, localError);
                        }
                        return null;
                    })
                    .then(function (values) {
                        // Convert to array if it's an object with numeric keys
                        if (values && typeof values === 'object' && !Array.isArray(values)) {
                            console.log(`Converting ${fieldId} values from object to array:`, values);
                            values = Object.values(values);
                        }

                        if (values && Array.isArray(values)) {
                            console.log(`Loaded custom dropdown values for ${fieldId} from Freshdesk storage:`, values);

                            // Cache the values for future use
                            window.dropdownValuesCache[fieldId] = values;

                            // Also update localStorage as a synchronized cache
                            try {
                                localStorage.setItem(storageKey, JSON.stringify(values));
                            } catch (localError) {
                                console.warn(`Could not update localStorage cache for ${fieldId}:`, localError);
                            }

                            // Find the select element and update its options
                            const selectElement = document.getElementById(fieldId);
                            if (selectElement && selectElement.tagName === 'SELECT') {
                                // Clear existing options
                                selectElement.innerHTML = '';

                                // Add empty option first so nothing is selected by default
                                const emptyOption = document.createElement('option');
                                emptyOption.value = '';
                                emptyOption.textContent = '-- Select --';
                                selectElement.appendChild(emptyOption);

                                // Add new options
                                values.forEach(value => {
                                    const option = document.createElement('option');
                                    option.value = value;
                                    option.textContent = value;
                                    selectElement.appendChild(option);
                                });

                                // Ensure the empty option is selected
                                selectElement.value = '';
                            }
                        } else {
                            console.log(`No values found for ${fieldId}, field will remain empty`);
                        }
                    })
                    .catch(function (error) {
                        console.error(`Error processing dropdown values for ${fieldId}:`, error);
                    });

                // Return null since the actual loading is asynchronous
                // The values will be applied when they're loaded
                return null;
            } catch (error) {
                console.error(`Error in getCustomDropdownValues for ${fieldId}:`, error);
                return null;
            }
        }

        // Tracker count utility functions
        function getTodayDateString() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Function to increment tracker count (called from TrackerApp)
        function incrementTrackerCount(templateType, trackerId, subject) {
            console.log(`[TRACKER COUNT] Incrementing tracker count for template: ${templateType}, ID: ${trackerId}, Subject: ${subject}`);

            // Try to get client from multiple sources
            let client = null;

            if (window.trackerApp && window.trackerApp.client) {
                client = window.trackerApp.client;
                console.log(`[TRACKER COUNT] Using client from window.trackerApp`);
            } else if (typeof window.client !== 'undefined') {
                client = window.client;
                console.log(`[TRACKER COUNT] Using global window.client`);
            } else if (typeof app !== 'undefined') {
                console.log(`[TRACKER COUNT] Client not immediately available, will try with app.initialized()`);
                // Use app.initialized() as fallback
                app.initialized().then(function (appClient) {
                    console.log(`[TRACKER COUNT] Got client from app.initialized(), calling recursively`);
                    window.client = appClient;
                    incrementTrackerCount(templateType, trackerId, subject); // Recursive call with client now available
                }).catch(function (error) {
                    console.error(`[TRACKER COUNT] Failed to get client from app.initialized():`, error);
                });
                return; // Return early, recursive call will handle the actual work
            } else {
                console.warn(`[TRACKER COUNT] No client available for incrementing tracker count`);
                return;
            }

            if (!client) {
                console.warn(`[TRACKER COUNT] Client is null, cannot increment tracker count`);
                return;
            }

            const today = getTodayDateString();
            const storageKey = `tracker-details-${today}`;
            console.log(`[TRACKER COUNT] Using storage key: ${storageKey}`);

            // Get current tracker details
            client.db.get(storageKey)
                .then(function (data) {
                    const currentData = data || { trackers: [] };
                    const trackers = currentData.trackers || [];
                    console.log(`[TRACKER COUNT] Current trackers before adding:`, trackers);

                    // Add new tracker details
                    trackers.push({
                        id: trackerId,
                        subject: subject,
                        templateType: templateType,
                        timestamp: new Date().toISOString()
                    });

                    console.log(`[TRACKER COUNT] Updated tracker details for ${today}:`, trackers);

                    // Save back to storage
                    return client.db.set(storageKey, { trackers: trackers });
                })
                .catch(function (error) {
                    // Handle 404 error when no record exists yet (first tracker of the day)
                    if (error.status === 404) {
                        console.log(`[TRACKER COUNT] No existing record for ${today}, creating new one`);
                        const newData = {
                            trackers: [{
                                id: trackerId,
                                subject: subject,
                                templateType: templateType,
                                timestamp: new Date().toISOString()
                            }]
                        };

                        console.log(`[TRACKER COUNT] Creating new tracker details record:`, newData);

                        // Create new record
                        return client.db.set(storageKey, newData);
                    } else {
                        // Re-throw other errors
                        throw error;
                    }
                })
                .then(function () {
                    console.log(`[TRACKER COUNT] Successfully stored tracker details for ${templateType}`);

                    // Trigger a refresh of the dashboard if we're on the template selector page
                    if (window.loadAndDisplayTrackerCounts && typeof window.loadAndDisplayTrackerCounts === 'function') {
                        console.log(`[TRACKER COUNT] Refreshing dashboard`);
                        window.loadAndDisplayTrackerCounts();
                    }
                })
                .catch(function (error) {
                    console.error(`[TRACKER COUNT] Error storing tracker details:`, error);
                });
        }

        // Make increment function globally accessible
        window.incrementTrackerCount = incrementTrackerCount;

        function initializeTrackerApp(trackerType, config) {
            const trackerApp = new TrackerApp(trackerType, config);
            window.trackerApp = trackerApp;
            trackerApp.init();
        }

        class TrackerApp {
            constructor(trackerType, config) {
                this.trackerType = trackerType;
                this.selectedTemplate = trackerType; // Add this for draft saving
                this.config = config;
                this.client = null;
                this.quillEditors = {};
                this.aggregatedScreenshotFiles = [];
                this.ticketData = {
                    isVip: false,
                    districtName: '',
                    currentTicketId: null,
                    requesterEmail: '',
                    ticketRequesterEmail: ''
                };
            }

            async init() {
                try {
                    console.log('Initializing TrackerApp');
                    await this.initClient();

                    // Move debugDistrictFields to the end
                    // this.debugDistrictFields(); - REMOVE THIS LINE

                    this.initEventListeners();
                    this.initQuillEditors();
                    this.initFormData();
                    await this.loadInitialData();

                    // Add hidden description field if it doesn't exist
                    this.ensureHiddenFields();

                    // Set up custom file uploaders
                    this.setupCustomFileUploaders();

                    // Load data from localStorage based on tracker type
                    this.loadDataFromStorage();

                    // Check if we're loading a draft
                    this.loadDraftIfAvailable();

                    // Hide specified ticket property fields
                    this.hideTicketPropertyFields();

                    // Remove the Attachments card at the bottom
                    this.removeBottomAttachmentsCard();

                    // Call the onLoad function if it exists in the template config
                    if (this.config.onLoad && typeof this.config.onLoad === 'function') {
                        console.log(`Calling onLoad function for template ${this.trackerType}`);
                        try {
                            this.config.onLoad();
                        } catch (onLoadError) {
                            console.error(`Error in onLoad function for ${this.trackerType}:`, onLoadError);
                        }
                    }

                    // Move the debug to the end, after all initialization is complete
                    this.debugDistrictFields();

                    // Add this at the end of the method
                    // Special handling for Achievement Levels tracker to ensure district name is populated
                    if (this.trackerType === 'sim-achievement-levels') {
                        setTimeout(() => {
                            // Ensure district name is populated by checking multiple sources
                            const districtField = document.getElementById('districtField');
                            const districtNameField = document.getElementById('districtName');

                            if (districtField && districtField.value && districtNameField) {
                                // If districtField has value, use it
                                if (districtField && districtField.value) {
                                    districtNameField.value = districtField.value;
                                    console.log(`Set districtName from districtField: ${districtField.value}`);
                                }
                                // If not, try to get from ticket data
                                else if (this.ticketData && this.ticketData.districtName) {
                                    districtNameField.value = this.ticketData.districtName;
                                    console.log(`Set districtName from ticketData: ${this.ticketData.districtName}`);
                                }

                                // Update the formatted subject
                                this.updateAchievementLevelsSubject();
                            }
                        }, 1000); // Delay to ensure everything else is loaded
                    }

                    // Special handling for Achievement Levels tracker
                    if (this.trackerType === 'sim-achievement-levels') {
                        // Wait a bit to let other initialization processes finish
                        setTimeout(async () => {
                            try {
                                // Get VIP status directly from the source ticket
                                const relatedTicketsField = document.getElementById('relatedTickets');
                                if (relatedTicketsField && relatedTicketsField.value) {
                                    const sourceTicketId = parseInt(relatedTicketsField.value.split(',')[0], 10);
                                    if (!isNaN(sourceTicketId)) {
                                        console.log("Getting VIP status from ticket", sourceTicketId);

                                        try {
                                            const response = await this.client.request.invokeTemplate("getTicketDetails", {
                                                context: { ticketId: sourceTicketId }
                                            });

                                            const ticketData = JSON.parse(response.response);
                                            if (ticketData && ticketData.custom_fields) {
                                                // Check for VIP status in custom fields
                                                const vipFields = ['cf_vip', 'vip', 'cf_vip_status', 'vip_customer', 'cf_is_vip'];
                                                for (const field of vipFields) {
                                                    if (ticketData.custom_fields[field] !== undefined) {
                                                        const fieldValue = ticketData.custom_fields[field];
                                                        const isVip = fieldValue === true ||
                                                            fieldValue === "true" ||
                                                            fieldValue === "Yes";

                                                        console.log(`VIP status found in ${field}:`, isVip);
                                                        this.ticketData.isVip = isVip;

                                                        // Also set the checkbox
                                                        const vipCheckbox = document.getElementById('hiddenVIPStatus');
                                                        if (vipCheckbox) {
                                                            vipCheckbox.checked = isVip;
                                                            console.log('Set hidden VIP checkbox to:', isVip);
                                                        }

                                                        // If VIP, set priority to HIGH (priority 3)
                                                        if (isVip) {
                                                            console.log("Setting priority to HIGH (3) based on VIP status");
                                                            // Set the priority in the form
                                                            const priorityField = document.getElementById('priority');
                                                            if (priorityField) {
                                                                priorityField.value = "3"; // 3 = HIGH priority
                                                            }
                                                            // Also store in ticketData for when we create the ticket
                                                            this.ticketData.priority = 3;

                                                            // Make sure the VIP status is reflected in the subject
                                                            this.updateAchievementLevelsSubject();
                                                        }

                                                        break;
                                                    }
                                                }
                                            }
                                        } catch (error) {
                                            console.error("Error getting source ticket VIP status:", error);
                                        }
                                    }
                                }

                                // After all data gathering, update the subject with proper VIP status
                                this.updateAchievementLevelsSubject();

                            } catch (error) {
                                console.error("Error in Achievement Levels special handling:", error);
                            }
                        }, 1000);
                    }

                    console.log('TrackerApp initialized successfully');

                    // Add this to your init method
                    await this.inspectDistrictDropdownField();
                } catch (error) {
                    console.error('Failed to initialize TrackerApp:', error);
                    this.showError('Failed to initialize app. Please try again.');
                }
            }

            // Add this new method
            removeBottomAttachmentsCard() {
                // Find the Attachments card at the bottom
                const cards = document.querySelectorAll('.card');
                cards.forEach(card => {
                    const header = card.querySelector('.card-header h3');
                    if (header && header.textContent.trim() === 'ATTACHMENTS') {
                        // This is the bottom attachments card, remove it
                        card.remove();
                        console.log('Removed bottom Attachments card');
                    }
                });
            }

            // Add this new method to hide ticket property fields
            hideTicketPropertyFields() {
                // Fields to hide: status, priority, group, related ticket IDs, requester email
                const fieldsToHide = [
                    { id: 'status', parent: 'form-group' },
                    { id: 'priority', parent: 'form-group' },
                    { id: 'groupField', parent: 'form-group' },
                    { id: 'relatedTickets', parent: 'form-group' },
                    { id: 'email', parent: 'form-group' }
                ];

                fieldsToHide.forEach(field => {
                    const element = document.getElementById(field.id);
                    if (element) {
                        // Find the parent container to hide the entire field including label
                        const parent = this.findParentWithClass(element, field.parent);
                        if (parent) {
                            parent.style.display = 'none';
                            console.log(`Hid ${field.id} field`);
                        } else {
                            // If parent not found, just hide the element itself
                            element.style.display = 'none';
                            console.log(`Hid ${field.id} element (parent not found)`);
                        }
                    } else {
                        console.warn(`Could not find element with id: ${field.id}`);
                    }
                });
            }

            initFormData() {
                console.log('Initializing form data');
                // This can be empty, but must exist as a function
            }

            async initClient() {
                // Initialize client code (same as in existing app)
                return new Promise((resolve, reject) => {
                    let attempts = 0;
                    const maxAttempts = 10;

                    const tryInit = () => {
                        attempts++;
                        console.log(`Attempt ${attempts} to initialize Freshworks client`);

                        if (typeof client !== 'undefined') {
                            this.client = client;
                            resolve(client);
                        } else if (typeof app !== 'undefined') {
                            app.initialized().then(clientObj => {
                                this.client = clientObj;
                                resolve(clientObj);
                            }).catch(reject);
                        } else if (typeof window.frsh !== 'undefined' && window.frsh.init) {
                            window.frsh.init().then(clientObj => {
                                this.client = clientObj;
                                resolve(clientObj);
                            }).catch(reject);
                        } else if (attempts < maxAttempts) {
                            setTimeout(tryInit, 100);
                        } else {
                            reject(new Error('Could not initialize client after multiple attempts'));
                        }
                    };

                    tryInit();
                });
            }

            initQuillEditors() {
                console.log('Initializing Quill editors');
                // Clear any previous editors
                this.quillEditors = {};

                // Initialize Quill editors based on config
                this.config.sections.forEach(section => {
                    section.fields.forEach(field => {
                        if (field.type === 'richtext') {
                            const editorId = `${field.id}Editor`;
                            const editorElement = document.getElementById(editorId);

                            if (editorElement) {
                                // Make sure to set min-height directly on the element
                                editorElement.style.minHeight = '120px';

                                try {
                                    // Define a custom image handler for the toolbar
                                    const customImageHandler = () => {
                                        const input = document.createElement('input');
                                        input.setAttribute('type', 'file');
                                        input.setAttribute('accept', 'image/*');
                                        input.click();

                                        input.onchange = () => {
                                            if (input.files && input.files[0]) {
                                                const file = input.files[0];

                                                // Show loading indicator
                                                const range = editor.getSelection(true);
                                                editor.insertText(range.index, "Uploading image... ", { italic: true, color: '#999' });
                                                const placeholderIndex = range.index;

                                                // Upload to ImgBB
                                                this.uploadImageToImgBB(file).then(imageUrl => {
                                                    // Delete the placeholder text
                                                    editor.deleteText(placeholderIndex, "Uploading image... ".length);

                                                    // Insert the image
                                                    editor.insertEmbed(placeholderIndex, 'image', imageUrl);
                                                    editor.setSelection(placeholderIndex + 1);
                                                }).catch(error => {
                                                    console.error('Error uploading image:', error);

                                                    // Replace placeholder with error message
                                                    editor.deleteText(placeholderIndex, "Uploading image... ".length);
                                                    editor.insertText(placeholderIndex, "⚠️ Image upload failed ", { italic: true, color: 'red' });
                                                });
                                            }
                                        };
                                    };

                                    // Initialize Quill with simplified toolbar
                                    const editor = new Quill(`#${editorId}`, {
                                        theme: 'snow',
                                        placeholder: field.id === 'stepsToReproduce' ?
                                            "EX:\n1. Log in as Teacher\n2. On Dashboard Click ORR" :
                                            `Enter ${field.id.replace(/([A-Z])/g, ' $1').toLowerCase()}...`,
                                        modules: {
                                            toolbar: {
                                                container: [
                                                    ['bold', 'italic'],                        // Bold and italic
                                                    [{ 'color': [] }, { 'background': [] }],   // Color and highlight
                                                    [{ 'align': [] }],                         // Alignment
                                                    ['link', 'image', 'clean']                 // Link, image, and clean formatting
                                                ],
                                                handlers: {
                                                    'image': customImageHandler.bind(this)
                                                }
                                            }
                                        }
                                    });

                                    // Ensure the editor is properly enabled
                                    editor.enable();

                                    // Store reference in our global map
                                    this.quillEditors[field.id] = editor;

                                    // Add paste image handling
                                    editor.root.addEventListener('paste', e => this.handlePasteImage(e, editor));

                                    // Add drop handling for images
                                    editor.root.addEventListener('drop', e => this.handleDropImage(e, editor));

                                    console.log(`Initialized Quill editor for ${field.id}`);
                                } catch (error) {
                                    console.error(`Error initializing Quill editor for ${field.id}:`, error);
                                }
                            } else {
                                console.warn(`Editor element not found for ${field.id}`);
                            }
                        }
                    });
                });

                // Convert textareas to Quill editors
                this.convertTextareasToQuill();
            }

            // Add this new method to convert textareas to Quill editors
            convertTextareasToQuill() {
                // Find all textareas that aren't already hidden or part of a Quill editor
                const textareas = document.querySelectorAll('textarea:not([style*="display: none"]):not([id$="Editor"])');

                textareas.forEach(textarea => {
                    // Skip if already processed or if the ID is "description"
                    if (textarea.id === 'description' || this.quillEditors[textarea.id]) {
                        return;
                    }

                    console.log(`Converting textarea ${textarea.id} to Quill editor`);

                    // Create container for the editor
                    const container = document.createElement('div');
                    container.className = 'quill-editor-container';

                    // Create the editor div
                    const editorDiv = document.createElement('div');
                    editorDiv.id = `${textarea.id}Editor`;
                    editorDiv.style.minHeight = '120px';

                    // Add the editor div to the container
                    container.appendChild(editorDiv);

                    // Replace the textarea with the container
                    textarea.parentNode.replaceChild(container, textarea);

                    // Move the textarea into the container (hidden)
                    textarea.style.display = 'none';
                    container.appendChild(textarea);

                    // Initialize the Quill editor
                    try {
                        const editor = new Quill(`#${textarea.id}Editor`, {
                            theme: 'snow',
                            placeholder: textarea.id === 'stepsToReproduce' ?
                                "EX:\n1. Log in as Teacher\n2. On Dashboard Click ORR" :
                                (textarea.placeholder || `Enter ${textarea.id.replace(/([A-Z])/g, ' $1').toLowerCase()}...`),
                            modules: {
                                toolbar: {
                                    container: [
                                        ['bold', 'italic'],                      // Bold and italic
                                        [{ 'color': [] }, { 'background': [] }], // Color and highlight
                                        [{ 'align': [] }],                       // Alignment
                                        ['link', 'image', 'clean']               // Link, image, and clean formatting
                                    ]
                                }
                            }
                        });

                        // Set initial content if textarea had value
                        if (textarea.value) {
                            editor.root.innerHTML = textarea.value;
                        }

                        // Store reference to the editor
                        this.quillEditors[textarea.id] = editor;

                        // Update textarea when editor changes
                        editor.on('text-change', () => {
                            textarea.value = editor.root.innerHTML;
                        });
                    } catch (error) {
                        console.error(`Error converting textarea ${textarea.id} to Quill:`, error);
                    }
                });
            }

            initEventListeners() {
                console.log('Setting up event listeners');

                // Back button
                const backButton = document.getElementById('backButton');
                if (backButton) {
                    backButton.addEventListener('click', () => {
                        window.location.href = 'template-selector.html';
                    });
                }

                // Cancel button
                const cancelButton = document.getElementById('cancelTracker');
                if (cancelButton) {
                    cancelButton.addEventListener('click', () => {
                        window.location.href = 'template-selector.html';
                    });
                }

                // Submit form - Fix for Create Tracker button
                const form = document.getElementById('trackerForm');
                if (form) {
                    form.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleFormSubmit();
                    });
                }

                // Also add direct event handler to the createTracker button
                const createTrackerButton = document.getElementById('createTracker');
                if (createTrackerButton) {
                    createTrackerButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        console.log('Create Tracker button clicked');
                        this.handleFormSubmit();
                    });
                }

                // Save as Draft button
                const saveAsDraftButton = document.getElementById('saveAsDraft');
                if (saveAsDraftButton) {
                    saveAsDraftButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        console.log('Save as Draft button clicked');
                        this.handleSaveAsDraft();
                    });
                }

                // File input change
                const fileInput = document.getElementById('screenshots');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        this.handleFileInputChange(e);
                    });
                }

                // Debug button
                const debugButton = document.getElementById('debugFillForm');
                if (debugButton) {
                    debugButton.addEventListener('click', () => {
                        this.fillFormWithDemoData();
                    });
                }

                // Add a debugging button to the debug-container to show user data
                const debugContainer = document.querySelector('.debug-container');
                if (debugContainer) {
                    // First button - Check User Data
                    const checkUserButton = document.createElement('button');
                    checkUserButton.className = 'debug-button';
                    checkUserButton.textContent = 'Check User Data';
                    checkUserButton.style.marginLeft = '10px';
                    checkUserButton.addEventListener('click', async () => {
                        try {
                            const userData = await this.client.data.get("loggedInUser");
                            console.log("Current user data:", userData);

                            // Show more detailed info in an alert
                            let emailInfo = "No email found";
                            if (userData && userData.loggedInUser && userData.loggedInUser.email) {
                                emailInfo = userData.loggedInUser.email;
                            }

                            alert(`User email: ${emailInfo}\n\nSee console for full user data`);
                        } catch (error) {
                            console.error("Error checking user data:", error);
                            alert("Error checking user data. See console for details.");
                        }
                    });

                    debugContainer.appendChild(checkUserButton);

                    // Second button - Check District Data
                    // REMOVED: const debugContainer = document.querySelector('.debug-container');
                    // Just use the existing debugContainer variable
                    const checkDistrictButton = document.createElement('button');
                    checkDistrictButton.className = 'debug-button';
                    checkDistrictButton.textContent = 'Check District Data';
                    checkDistrictButton.style.marginLeft = '10px';
                    checkDistrictButton.addEventListener('click', () => {
                        // Get current ticket data to check district field
                        this.client.data.get("ticket").then(ticketData => {
                            console.group("District Field Debugging");
                            console.log("Current ticket data:", ticketData);

                            // Check custom fields for district
                            if (ticketData && ticketData.ticket && ticketData.ticket.custom_fields) {
                                console.log("Custom fields:", ticketData.ticket.custom_fields);

                                // Log any field that might contain district information
                                Object.keys(ticketData.ticket.custom_fields).forEach(key => {
                                    if (key.toLowerCase().includes('district')) {
                                        console.log(`Potential district field: ${key} = ${ticketData.ticket.custom_fields[key]}`);
                                    }
                                });
                            }

                            // Check if district field in DOM is populated
                            const districtField = document.getElementById('districtField');
                            console.log("District field element:", districtField);
                            console.log("District field value:", districtField ? districtField.value : "Element not found");

                            console.groupEnd();

                            alert("District data check complete. See console for details.");
                        }).catch(error => {
                            console.error("Error checking district data:", error);
                            alert("Error checking district data. See console for details.");
                        });
                    });

                    debugContainer.appendChild(checkDistrictButton);
                }

                // Add a "Use My Email" button next to the email field
                const emailField = document.getElementById('email');
                if (emailField) {
                    const emailFieldParent = emailField.parentElement;

                    // Create a button container
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.marginTop = '8px';

                    // Create the button
                    const useMyEmailButton = document.createElement('button');
                    useMyEmailButton.type = 'button';
                    useMyEmailButton.className = 'email-input-button';
                    useMyEmailButton.innerHTML = '<i class="fas fa-user"></i> Use My Email';
                    useMyEmailButton.style.backgroundColor = '#f0f0f0';
                    useMyEmailButton.style.border = '1px solid #ddd';
                    useMyEmailButton.style.borderRadius = '4px';
                    useMyEmailButton.style.padding = '5px 10px';
                    useMyEmailButton.style.cursor = 'pointer';
                    useMyEmailButton.style.marginRight = '8px';

                    // Add click handler
                    useMyEmailButton.addEventListener('click', () => {
                        const emailInput = prompt("Enter your email address:", emailField.value || "");
                        if (emailInput && emailInput.trim()) {
                            emailField.value = emailInput.trim();
                        }
                    });

                    buttonContainer.appendChild(useMyEmailButton);

                    // Insert after email field
                    emailFieldParent.appendChild(buttonContainer);
                }

                // Add dynamic subject line builder for Assembly template
                if (this.trackerType === 'assembly') {
                    const subjectFields = ['xcode', 'application', 'specificIssue', 'gradesImpacted'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateFormattedSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateFormattedSubject();
                    }
                }

                // Add dynamic subject line builder for SEDCUST template
                if (this.trackerType === 'sedcust') {
                    const subjectFields = ['xcode', 'application', 'version', 'versionState', 'resourcePath', 'specificIssue'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateSedcustSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateSedcustSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateSedcustSubject();
                    }
                }

                // Add dynamic subject line builder for SIM Assignment template
                if (this.trackerType === 'sim-assignment') {
                    const subjectFields = ['isVIP', 'districtName', 'districtState', 'application', 'version', 'versionState', 'resource', 'specificIssue', 'userRole'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateSimAssignmentSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateSimAssignmentSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateSimAssignmentSubject();
                    }
                }

                // Add dynamic subject line builder for SIM Assessment Reports template
                if (this.trackerType === 'sim-assessment-reports') {
                    const subjectFields = ['isVIP', 'districtName', 'application', 'resource', 'specificIssue', 'userRole'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateSIMAssessmentReportsSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateSIMAssessmentReportsSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateSIMAssessmentReportsSubject();
                    }
                }

                // Add dynamic subject line builder for SIM Achievement Levels template
                if (this.trackerType === 'sim-achievement-levels') {
                    const subjectFields = ['isVIP', 'districtName'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateAchievementLevelsSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateAchievementLevelsSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateAchievementLevelsSubject();
                    }
                }

                // Set up conditional fields
                this.setupConditionalFields();

                // Initialize HAR file attached dropdown behavior for both templates
                if (this.trackerType === 'sim-assignment' || this.trackerType === 'sim-assessment-reports') {
                    const harFileAttached = document.getElementById('harFileAttached');
                    const harFileReason = document.getElementById('harFileReason');

                    if (harFileAttached && harFileReason) {
                        // Set initial state
                        const harFileReasonContainer = this.findParentWithClass(harFileReason, 'form-group');

                        if (harFileAttached.value === 'No') {
                            if (harFileReasonContainer) {
                                harFileReasonContainer.style.display = 'block';

                                // Add visual indication that the field is now required
                                const label = harFileReasonContainer.querySelector('label');
                                if (label) {
                                    label.classList.add('required-field');
                                }
                            }
                        } else {
                            if (harFileReasonContainer) {
                                harFileReasonContainer.style.display = 'none';
                            }
                        }

                        // Add change listener
                        harFileAttached.addEventListener('change', function () {
                            // Get the container again inside this scope
                            const reasonContainer = document.getElementById('harFileReason') ?
                                window.trackerApp.findParentWithClass(document.getElementById('harFileReason'), 'form-group') : null;

                            if (this.value === 'No') {
                                if (reasonContainer) {
                                    reasonContainer.style.display = 'block';

                                    // Add visual indication that the field is now required
                                    const label = reasonContainer.querySelector('label');
                                    if (label) {
                                        label.classList.add('required-field');
                                    }
                                }

                                // Hide the uploader container
                                const harUploaderContainer = document.getElementById('harUploaderContainer');
                                if (harUploaderContainer) harUploaderContainer.style.display = 'none';
                            } else {
                                if (reasonContainer) {
                                    reasonContainer.style.display = 'none';

                                    // Remove the required indication
                                    const label = reasonContainer.querySelector('label');
                                    if (label) {
                                        label.classList.remove('required-field');
                                    }
                                }

                                // Show the uploader container 
                                const harUploaderContainer = document.getElementById('harUploaderContainer');
                                if (harUploaderContainer) harUploaderContainer.style.display = 'block';
                            }
                        });
                    }
                }

                // Update hint for related tickets
                const relatedTicketsField = document.getElementById('relatedTickets');
                if (relatedTicketsField) {
                    const hintDiv = relatedTicketsField.parentElement.nextElementSibling;
                    if (hintDiv && hintDiv.classList.contains('hint')) {
                        hintDiv.innerHTML = '<i class="fas fa-info-circle"></i> <strong>Required:</strong> ' +
                            'Currently includes the source ticket ID. Add more ticket IDs separated by commas if needed.';
                    }
                }

                // Add Achievement Levels specific handlers
                if (this.trackerType === 'sim-achievement-levels') {
                    // Ensure formattedSubject is updated with the hidden fields
                    this.updateAchievementLevelsSubject();

                    // Set up the smartsheet file uploader
                    this.setupSmartsheetUploader();

                    // Hide the isVIP field (stored in localStorage for subject formatting)
                    const hiddenFields = ['isVIP'];
                    hiddenFields.forEach(fieldId => {
                        const field = document.getElementById(fieldId);
                        if (field) {
                            const parent = this.findParentWithClass(field, 'form-group');
                            if (parent) parent.style.display = 'none';
                        }
                    });

                    // Add a periodic check to ensure VIP status remains in the subject line
                    this.startVipStatusMonitor();
                }

                // In your initEventListeners method, add this to create a hidden VIP status checkbox
                const hiddenContainer = document.querySelector('div[style="display: none;"]') ||
                    document.createElement('div');

                if (!hiddenContainer.parentNode) {
                    hiddenContainer.style.display = 'none';
                    document.body.appendChild(hiddenContainer);
                }

                // Create hidden VIP checkbox if it doesn't exist
                if (!document.getElementById('hiddenVIPStatus')) {
                    const vipCheckbox = document.createElement('input');
                    vipCheckbox.type = 'checkbox';
                    vipCheckbox.id = 'hiddenVIPStatus';
                    vipCheckbox.name = 'hiddenVIPStatus';
                    hiddenContainer.appendChild(vipCheckbox);
                }

                // Add dynamic subject line builder for SIM Library View template
                if (this.trackerType === 'sim-library-view') {
                    const subjectFields = ['isVIP', 'districtName', 'application', 'specificIssue', 'userRole'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateSimLibraryViewSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateSimLibraryViewSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateSimLibraryViewSubject();
                    }
                }

                // Add this to the initEventListeners method, where the other template-specific subject handlers are
                if (this.trackerType === 'sim-fsa') {
                    const subjectFields = ['isVIP', 'districtName', 'application', 'specificIssue', 'userRole'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateSimFsaSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateSimFsaSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateSimFsaSubject();
                    }
                }

                // Add dynamic subject line builder for SIM ORR template
                if (this.trackerType === 'sim-orr') {
                    const subjectFields = ['isVIP', 'districtName', 'districtState', 'application', 'version', 'versionState', 'resource', 'specificIssue'];
                    const formattedSubjectField = document.getElementById('formattedSubject');

                    if (formattedSubjectField) {
                        // Make it read-only
                        formattedSubjectField.readOnly = true;

                        // Update the formatted subject when any of the subject fields change
                        subjectFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (field) {
                                field.addEventListener('input', () => {
                                    this.updateSimOrrSubject();
                                });
                                field.addEventListener('change', () => {
                                    this.updateSimOrrSubject();
                                });
                            }
                        });

                        // Initial update
                        this.updateSimOrrSubject();
                    }
                }

                // Add to the initEventListeners method
                if (this.trackerType === 'sim-assignment' ||
                    this.trackerType === 'sim-assessment-reports' ||
                    this.trackerType === 'sim-fsa' ||
                    this.trackerType === 'sim-library-view' ||
                    this.trackerType === 'sim-orr') {

                    // Handle "All Users" checkbox
                    const allUsersCheckbox = document.querySelector('input[value="allUsers"]');
                    const individualRoleCheckboxes = document.querySelectorAll('input[name="userRole"]:not([value="allUsers"])');

                    if (allUsersCheckbox) {
                        allUsersCheckbox.addEventListener('change', (e) => {
                            // If "All Users" is checked, uncheck other options
                            if (e.target.checked) {
                                individualRoleCheckboxes.forEach(cb => {
                                    cb.checked = false;
                                    cb.disabled = true;
                                });
                            } else {
                                individualRoleCheckboxes.forEach(cb => {
                                    cb.disabled = false;
                                });
                            }
                            this.updateSubjectLine();
                        });
                    }

                    // Handle individual role checkboxes
                    individualRoleCheckboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', () => {
                            // If all individual roles are selected, check "All Users" instead
                            const allIndividualSelected = Array.from(individualRoleCheckboxes)
                                .every(cb => cb.checked);

                            if (allIndividualSelected && allUsersCheckbox) {
                                allUsersCheckbox.checked = true;
                                individualRoleCheckboxes.forEach(cb => {
                                    cb.checked = false;
                                    cb.disabled = true;
                                });
                            }
                            this.updateSubjectLine();
                        });
                    });
                }
            }

            updateFormattedSubject() {
                const xcodeValue = document.getElementById('xcode')?.value || '';
                const applicationValue = document.getElementById('application')?.value || '';
                const specificIssueValue = document.getElementById('specificIssue')?.value || '';
                const gradesImpactedValue = document.getElementById('gradesImpacted')?.value || '';

                const formattedSubject =
                    `${xcodeValue} | ${applicationValue} | ${specificIssueValue} : ${gradesImpactedValue}`;

                const formattedSubjectField = document.getElementById('formattedSubject');
                if (formattedSubjectField) {
                    formattedSubjectField.value = formattedSubject;

                    // Also update the hidden subject field to ensure it's submitted correctly
                    const subjectField = document.getElementById('subject');
                    if (subjectField) {
                        subjectField.value = formattedSubject;
                    }
                }
            }

            updateSedcustSubject() {
                const xcodeValue = document.getElementById('xcode')?.value || '';
                const applicationValue = document.getElementById('application')?.value || '';
                const versionValue = document.getElementById('version')?.value || '';
                const stateNationalValue = document.getElementById('versionState')?.value || '';
                const resourcePathValue = document.getElementById('resourcePath')?.value || '';
                const specificIssueValue = document.getElementById('specificIssue')?.value || '';
                const isVIP = document.getElementById('isVIP')?.value || 'No';


                console.log('SEDCUST Subject Update (HTML) - Field Values:', {
                    xcode: xcodeValue,
                    application: applicationValue,
                    version: versionValue,
                    stateNational: stateNationalValue,
                    resourcePath: resourcePathValue,
                    specificIssue: specificIssueValue,
                    isVIP: isVIP
                });

                // Build the subject line dynamically, only including parts that have values
                const subjectParts = [];

                // First part: XCODE
                if (xcodeValue.trim()) {
                    subjectParts.push(xcodeValue.trim());
                }

                // Third part: VIP or Standard
                const vipStatus = isVIP === 'Yes' ? 'VIP' : 'Standard';
                subjectParts.push(vipStatus);

                // Second part: Application • Version State/National
                let applicationPart = '';
                if (applicationValue.trim()) {
                    applicationPart = applicationValue.trim();

                    // Add version and state/national if they exist
                    const versionParts = [];
                    if (versionValue.trim()) {
                        versionParts.push(versionValue.trim());
                    }
                    if (stateNationalValue.trim()) {
                        versionParts.push(stateNationalValue.trim());
                    }

                    if (versionParts.length > 0) {
                        applicationPart += ` • ${versionParts.join(' ')}`;
                    }
                }
                if (applicationPart) {
                    subjectParts.push(applicationPart);
                }

                // Fourth part: Resource Path - Specific Issue
                let resourceIssuePart = '';
                if (resourcePathValue.trim() && specificIssueValue.trim()) {
                    resourceIssuePart = `${resourcePathValue.trim()} - ${specificIssueValue.trim()}`;
                } else if (resourcePathValue.trim()) {
                    resourceIssuePart = resourcePathValue.trim();
                } else if (specificIssueValue.trim()) {
                    resourceIssuePart = specificIssueValue.trim();
                }
                if (resourceIssuePart) {
                    subjectParts.push(resourceIssuePart);
                }

                // Join all parts with " | " separator
                const formattedSubject = subjectParts.join(' | ');

                console.log('SEDCUST Subject Update (HTML) - Generated Subject:', formattedSubject);

                const formattedSubjectField = document.getElementById('formattedSubject');
                if (formattedSubjectField) {
                    formattedSubjectField.value = formattedSubject;

                    // Also update the hidden subject field to ensure it's submitted correctly
                    const subjectField = document.getElementById('subject');
                    if (subjectField) {
                        subjectField.value = formattedSubject;
                    }
                }
            }

            // Replace the existing formatUserRoles method with this updated version
            formatUserRoles(selectedRoles) {
                // If "All Users" is selected, return that
                if (selectedRoles.includes('allUsers')) {
                    return "All Users";
                }

                // If all three individual roles are selected, return "All Users"
                if (selectedRoles.includes('students') &&
                    selectedRoles.includes('teachers') &&
                    selectedRoles.includes('admin')) {
                    return "All Users";
                }

                // Format multiple selections
                const roleMap = {
                    'students': 'Students',
                    'teachers': 'Teachers',
                    'admin': 'Admin'
                };

                const selectedLabels = selectedRoles
                    .filter(role => role !== 'allUsers')
                    .map(role => roleMap[role]);

                // At this point, we should only have 1 or 2 roles
                // Join with & if there are 2 roles
                if (selectedLabels.length === 2) {
                    return selectedLabels.join(' & ');
                }

                // Return single role
                return selectedLabels[0] || '';
            }

            // Helper to get version value (custom or selected)
            getVersionValue(versionField) {
                if (versionField && versionField.value === "Other" && versionField.hasAttribute('data-custom-value')) {
                    return versionField.getAttribute('data-custom-value');
                }
                return versionField ? versionField.value : '';
            }

            // Helper to get version state value (custom or selected)
            getVersionStateValue(versionStateField) {
                if (versionStateField && versionStateField.value === "Other" && versionStateField.hasAttribute('data-custom-value')) {
                    return versionStateField.getAttribute('data-custom-value');
                }
                return versionStateField ? versionStateField.value : '';
            }

            // Update the subject line methods for each template
            updateSimAssignmentSubject() {
                const isVipField = document.getElementById('isVIP');
                const districtNameField = document.getElementById('districtName');
                const districtStateField = document.getElementById('districtState');
                const applicationField = document.getElementById('application');
                const versionField = document.getElementById('version');
                const versionStateField = document.getElementById('versionState');
                const resourceField = document.getElementById('resource');
                const reportTypeField = document.getElementById('reportType');
                const specificIssueField = document.getElementById('specificIssue');
                const formattedSubjectField = document.getElementById('formattedSubject');

                if (!isVipField || !districtNameField || !districtStateField || !applicationField ||
                    !specificIssueField || !formattedSubjectField || !resourceField) {
                    console.log("Missing required fields for subject formatting");
                    return;
                }

                // Get user roles
                const userRoles = [];
                const roleCheckboxes = document.querySelectorAll('input[type="checkbox"][name^="userRole"]:checked');
                roleCheckboxes.forEach(cb => {
                    if (cb.id === 'allUsers') {
                        userRoles.push('All Users');
                    } else {
                        const label = cb.parentElement.textContent.trim();
                        if (label) userRoles.push(label);
                    }
                });

                const isVip = isVipField.value === 'Yes';
                const districtName = districtNameField.value || '';
                const districtState = districtStateField.value || '';
                const application = applicationField.value || '';
                const version = this.getVersionValue(versionField) || '';
                const versionState = versionStateField ? this.getVersionStateValue(versionStateField) : '';
                const resource = resourceField.value || '';
                const reportType = reportTypeField?.value || '';
                const specificIssue = specificIssueField.value || '';
                const userRoleText = userRoles.length > 0 ? userRoles.join(' & ') : '';

                // Build the subject line dynamically, only including parts that have values
                const subjectParts = [];

                // First part: VIP or Standard District Name • District State
                let districtPart = '';
                if (districtName.trim() && districtState.trim()) {
                    if (isVip) {
                        districtPart = `VIP * ${districtName.trim()} • ${districtState.trim()}`;
                    } else {
                        districtPart = `${districtName.trim()} • ${districtState.trim()}`;
                    }
                } else if (districtName.trim()) {
                    if (isVip) {
                        districtPart = `VIP * ${districtName.trim()}`;
                    } else {
                        districtPart = districtName.trim();
                    }
                } else if (districtState.trim()) {
                    if (isVip) {
                        districtPart = `VIP * ${districtState.trim()}`;
                    } else {
                        districtPart = districtState.trim();
                    }
                }
                if (districtPart) {
                    subjectParts.push(districtPart);
                }

                // Second part: Application Name • Version State/National
                let applicationPart = '';
                if (application.trim()) {
                    applicationPart = application.trim();

                    // Add version and state/national if they exist
                    const versionParts = [];
                    if (version.trim()) {
                        versionParts.push(version.trim());
                    }
                    if (versionState.trim()) {
                        versionParts.push(versionState.trim());
                    }

                    if (versionParts.length > 0) {
                        applicationPart += ` • ${versionParts.join(' ')}`;
                    }
                }
                if (applicationPart) {
                    subjectParts.push(applicationPart);
                }

                // Third part: Resource (with Report Type if applicable)
                let resourcePart = '';
                if (resource.trim()) {
                    resourcePart = resource.trim();

                    // Add Report Type if Resource is "Reports" and Report Type is selected
                    if (resource === 'Reports' && reportType.trim()) {
                        resourcePart += `: ${reportType.trim()}`;
                    }
                }
                if (resourcePart) {
                    subjectParts.push(resourcePart);
                }

                // Fourth part: Specific issue for user role
                let issuePart = '';
                if (specificIssue.trim()) {
                    issuePart = specificIssue.trim();
                    if (userRoleText) {
                        issuePart += ` for ${userRoleText}`;
                    }
                }
                if (issuePart) {
                    subjectParts.push(issuePart);
                }

                // Join all parts with " | " separator
                const subject = subjectParts.join(' | ');

                formattedSubjectField.value = subject;
                console.log("Updated SIM Assignment subject line:", subject);

                // Also update the hidden subject field
                const subjectField = document.getElementById('subject');
                if (subjectField) {
                    subjectField.value = subject;
                }
            }

            // Update the other template methods similarly
            updateSIMAssessmentReportsSubject() {
                const isVipField = document.getElementById('isVIP');
                const districtNameField = document.getElementById('districtName');
                const districtStateField = document.getElementById('districtState');
                const applicationField = document.getElementById('application');
                const versionField = document.getElementById('version');
                const versionStateField = document.getElementById('versionState');
                const specificIssueField = document.getElementById('specificIssue');
                const formattedSubjectField = document.getElementById('formattedSubject');

                if (!isVipField || !districtNameField || !districtStateField || !applicationField ||
                    !versionField || !specificIssueField || !formattedSubjectField) {
                    console.log("Missing required fields for subject formatting");
                    return;
                }

                // Get user roles
                const userRoles = [];
                const roleCheckboxes = document.querySelectorAll('input[type="checkbox"][name^="userRole"]:checked');
                roleCheckboxes.forEach(cb => {
                    if (cb.id === 'allUsers') {
                        userRoles.push('All Users');
                    } else {
                        const label = cb.parentElement.textContent.trim();
                        if (label) userRoles.push(label);
                    }
                });

                const isVip = isVipField.value === 'Yes';
                const districtName = districtNameField.value || '';
                const districtState = districtStateField.value || '';
                const application = applicationField.value || '';
                const version = this.getVersionValue(versionField) || '';
                const versionState = versionStateField ? this.getVersionStateValue(versionStateField) : '';
                const specificIssue = specificIssueField.value || '';
                const userRoleText = userRoles.length > 0 ? userRoles.join(' & ') : '';

                // Build the subject line dynamically, only including parts that have values
                const subjectParts = [];

                // First part: VIP or Standard District Name • District State
                let districtPart = '';
                if (districtName.trim() && districtState.trim()) {
                    if (isVip) {
                        districtPart = `VIP * ${districtName.trim()} • ${districtState.trim()}`;
                    } else {
                        districtPart = `${districtName.trim()} • ${districtState.trim()}`;
                    }
                } else if (districtName.trim()) {
                    if (isVip) {
                        districtPart = `VIP * ${districtName.trim()}`;
                    } else {
                        districtPart = districtName.trim();
                    }
                } else if (districtState.trim()) {
                    if (isVip) {
                        districtPart = `VIP * ${districtState.trim()}`;
                    } else {
                        districtPart = districtState.trim();
                    }
                }
                if (districtPart) {
                    subjectParts.push(districtPart);
                }

                // Second part: Application Name • Version State/National
                let applicationPart = '';
                if (application.trim()) {
                    applicationPart = application.trim();

                    // Add version and state/national if they exist
                    const versionParts = [];
                    if (version.trim()) {
                        versionParts.push(version.trim());
                    }
                    if (versionState.trim()) {
                        versionParts.push(versionState.trim());
                    }

                    if (versionParts.length > 0) {
                        applicationPart += ` • ${versionParts.join(' ')}`;
                    }
                }
                if (applicationPart) {
                    subjectParts.push(applicationPart);
                }

                // Third part: Specific issue for user role
                let issuePart = '';
                if (specificIssue.trim()) {
                    issuePart = specificIssue.trim();
                    if (userRoleText) {
                        issuePart += ` for ${userRoleText}`;
                    }
                }
                if (issuePart) {
                    subjectParts.push(issuePart);
                }

                // Join all parts with " | " separator
                const subject = subjectParts.join(' | ');

                formattedSubjectField.value = subject;
                console.log("Updated subject line:", subject);

                // Also update the hidden subject field
                const subjectField = document.getElementById('subject');
                if (subjectField) {
                    subjectField.value = subject;
                }
            }

            updateSimLibraryViewSubject() {
                const isVipField = document.getElementById('isVIP');
                const districtNameField = document.getElementById('districtName');
                const districtStateField = document.getElementById('districtState');
                const applicationField = document.getElementById('application');
                const versionField = document.getElementById('version');
                const versionStateField = document.getElementById('versionState');
                const specificIssueField = document.getElementById('specificIssue');
                const formattedSubjectField = document.getElementById('formattedSubject');

                if (!isVipField || !districtNameField || !districtStateField || !applicationField ||
                    !versionField || !specificIssueField || !formattedSubjectField) {
                    console.log("Missing required fields for subject formatting");
                    return;
                }

                // Get user roles
                const userRoles = [];
                const roleCheckboxes = document.querySelectorAll('input[type="checkbox"][name^="userRole"]:checked');
                roleCheckboxes.forEach(cb => {
                    if (cb.id === 'allUsers') {
                        userRoles.push('All Users');
                    } else {
                        const label = cb.parentElement.textContent.trim();
                        if (label) userRoles.push(label);
                    }
                });

                const isVip = isVipField.value === 'Yes';
                const districtName = districtNameField.value || '';
                const districtState = districtStateField.value || '';
                const application = applicationField.value || '';
                const version = this.getVersionValue(versionField) || '';
                const versionState = versionStateField ? this.getVersionStateValue(versionStateField) : '';
                const specificIssue = specificIssueField.value || '';
                const userRoleText = userRoles.length > 0 ? userRoles.join(' & ') : '';

                // Build the subject line dynamically, only including parts that have values
                const subjectParts = [];

                // First part: VIP status and district info
                let districtPart = '';
                if (isVip) {
                    districtPart = `VIP * ${districtName} • ${districtState}`;
                } else {
                    districtPart = `${districtName} • ${districtState}`;
                }
                if (districtPart.trim() && districtPart !== ' • ') {
                    subjectParts.push(districtPart);
                }

                // Second part: Application, version, and version state
                let appPart = application;
                if (version) {
                    appPart += ` • ${version}`;
                }
                if (versionState) {
                    appPart += ` ${versionState}`;
                }
                if (appPart.trim()) {
                    subjectParts.push(appPart);
                }

                // Third part: Specific issue and user role
                let issuePart = specificIssue;
                if (userRoleText) {
                    issuePart += ` for ${userRoleText}`;
                }
                if (issuePart.trim()) {
                    subjectParts.push(issuePart);
                }

                // Join all parts with " | "
                const subject = subjectParts.join(' | ');

                formattedSubjectField.value = subject;
                console.log("Updated subject line:", subject);

                // Also update the hidden subject field
                const subjectField = document.getElementById('subject');
                if (subjectField) {
                    subjectField.value = subject;
                }
            }

            updateSimFsaSubject() {
                const isVipField = document.getElementById('isVIP');
                const districtNameField = document.getElementById('districtName');
                const districtStateField = document.getElementById('districtState');
                const applicationField = document.getElementById('application');
                const versionField = document.getElementById('version');
                const versionStateField = document.getElementById('versionState');
                const specificIssueField = document.getElementById('specificIssue');
                const formattedSubjectField = document.getElementById('formattedSubject');

                if (!isVipField || !districtNameField || !districtStateField || !applicationField ||
                    !versionField || !specificIssueField || !formattedSubjectField) {
                    console.log("Missing required fields for subject formatting");
                    return;
                }

                // Get user roles
                const userRoles = [];
                const roleCheckboxes = document.querySelectorAll('input[type="checkbox"][name^="userRole"]:checked');
                roleCheckboxes.forEach(cb => {
                    if (cb.id === 'allUsers') {
                        userRoles.push('All Users');
                    } else {
                        const label = cb.parentElement.textContent.trim();
                        if (label) userRoles.push(label);
                    }
                });

                const isVip = isVipField.value === 'Yes';
                const districtName = districtNameField.value || '';
                const districtState = districtStateField.value || '';
                const application = applicationField.value || '';
                const version = this.getVersionValue(versionField) || '';
                const versionState = versionStateField ? this.getVersionStateValue(versionStateField) : '';
                const specificIssue = specificIssueField.value || '';
                const userRoleText = userRoles.length > 0 ? userRoles.join(' & ') : '';

                // Build the subject line dynamically, only including parts that have values
                const subjectParts = [];

                // First part: VIP or Standard District Name • District State
                let districtPart = '';
                if (isVip) {
                    districtPart = `VIP * ${districtName} • ${districtState}`;
                } else {
                    districtPart = `${districtName} • ${districtState}`;
                }
                if (districtPart.trim() && districtPart !== ' • ') {
                    subjectParts.push(districtPart);
                }

                // Second part: Application Name • Version State/National
                let applicationPart = '';
                if (application.trim()) {
                    applicationPart = application.trim();

                    // Add version and state/national if they exist
                    const versionParts = [];
                    if (version.trim()) {
                        versionParts.push(version.trim());
                    }
                    if (versionState.trim()) {
                        versionParts.push(versionState.trim());
                    }

                    if (versionParts.length > 0) {
                        applicationPart += ` • ${versionParts.join(' ')}`;
                    }
                }
                if (applicationPart) {
                    subjectParts.push(applicationPart);
                }

                // Third part: Specific issue for user role
                let issuePart = '';
                if (specificIssue.trim()) {
                    issuePart = specificIssue.trim();
                    if (userRoleText) {
                        issuePart += ` for ${userRoleText}`;
                    }
                }
                if (issuePart) {
                    subjectParts.push(issuePart);
                }

                // Join all parts with " | " separator
                const subject = subjectParts.join(' | ');

                formattedSubjectField.value = subject;
                console.log("Updated subject line:", subject);

                // Also update the hidden subject field
                const subjectField = document.getElementById('subject');
                if (subjectField) {
                    subjectField.value = subject;
                }
            }

            updateSimOrrSubject() {
                const isVipField = document.getElementById('isVIP');
                const districtNameField = document.getElementById('districtName');
                const districtStateField = document.getElementById('districtState');
                const applicationField = document.getElementById('application');
                const versionField = document.getElementById('version');
                const versionStateField = document.getElementById('versionState');
                const resourceField = document.getElementById('resource');
                const specificIssueField = document.getElementById('specificIssue');
                const formattedSubjectField = document.getElementById('formattedSubject');

                if (!isVipField || !districtNameField || !districtStateField || !applicationField ||
                    !versionField || !specificIssueField || !formattedSubjectField) {
                    console.log("Missing required fields for SIM ORR subject formatting");
                    return;
                }

                // Get user roles
                const userRoles = [];
                const roleCheckboxes = document.querySelectorAll('input[type="checkbox"][name^="userRole"]:checked');
                roleCheckboxes.forEach(cb => {
                    if (cb.id === 'allUsers') {
                        userRoles.push('All Users');
                    } else {
                        const label = cb.parentElement.textContent.trim();
                        if (label) userRoles.push(label);
                    }
                });

                const isVip = isVipField.value === 'Yes';
                const districtName = districtNameField.value || '';
                const districtState = districtStateField.value || '';
                const application = applicationField.value || '';
                const version = this.getVersionValue(versionField) || '';
                const versionState = versionStateField ? this.getVersionStateValue(versionStateField) : '';
                const resource = resourceField ? resourceField.value : '';
                const specificIssue = specificIssueField.value || '';
                const formattedUserRole = userRoles.length > 0 ? userRoles.join(' & ') : '';

                // Build the subject line dynamically
                const subjectParts = [];

                // First part: VIP status and district information
                let districtPart = '';
                if (isVip) {
                    districtPart = `VIP * ${districtName}`;
                } else {
                    districtPart = districtName;
                }
                if (districtState) {
                    districtPart += ` • ${districtState}`;
                }

                if (districtPart.trim() && districtPart !== ' • ') {
                    subjectParts.push(districtPart);
                }

                // Second part: Application, version, and version state
                let appPart = application;
                if (version) {
                    appPart += ` • ${version}`;
                }
                if (versionState) {
                    appPart += ` ${versionState}`;
                }
                if (appPart.trim()) {
                    subjectParts.push(appPart);
                }

                // Third part: Resource and specific issue with custom separator
                let issuePart = '';
                if (resource) {
                    issuePart = `Resource: ${resource}`;
                    if (specificIssue) {
                        issuePart += ` • ${specificIssue}`;
                    }
                } else if (specificIssue) {
                    issuePart = specificIssue;
                }

                if (formattedUserRole) {
                    issuePart += ` for ${formattedUserRole}`;
                }
                if (issuePart.trim()) {
                    subjectParts.push(issuePart);
                }

                // Join all parts with " | "
                const subject = subjectParts.join(' | ');

                // Update both the formatted and hidden subject fields
                formattedSubjectField.value = subject;

                const hiddenSubjectField = document.getElementById('subject');
                if (hiddenSubjectField) {
                    hiddenSubjectField.value = subject;
                }

                console.log("Updated SIM ORR subject line:", subject);
            }

            // Create a new non-async method for immediate subject updates
            updateAchievementLevelsSubjectSync() {
                try {
                    // First check if we already have a pre-formatted subject from template-selector
                    if (this.ticketData && this.ticketData.formattedSubject) {
                        const subject = this.ticketData.formattedSubject;

                        // Update DOM fields with the pre-formatted subject
                        const formattedSubjectField = document.getElementById('formattedSubject');
                        if (formattedSubjectField) {
                            formattedSubjectField.value = subject;

                            // Also update the hidden subject field
                            const subjectField = document.getElementById('subject');
                            if (subjectField) {
                                subjectField.value = subject;
                            }

                            // Cache for comparison
                            this._cachedSubjectLine = subject;
                        }

                        console.log('Using pre-formatted subject with VIP status:', subject);
                        return;
                    }

                    // If no pre-formatted subject, fall back to existing logic
                    const districtNameField = document.getElementById('districtName');
                    const districtName = districtNameField ? districtNameField.value || '' : '';

                    // SIMPLIFY VIP logic - use multiple sources
                    let isVip = false;

                    // Check all possible sources for VIP status
                    const vipCheckbox = document.getElementById('hiddenVIPStatus');
                    if (vipCheckbox && vipCheckbox.checked) {
                        isVip = true;
                    } else if (this.ticketData && this.ticketData.isVip === true) {
                        isVip = true;
                    }

                    // Hardcode VIP prefix based on the determined status  
                    const vipPrefix = isVip ? 'VIP* ' : '';

                    // Format the subject line
                    const subject = `${vipPrefix}${districtName} | Custom Achievement Levels`;

                    // Update DOM fields
                    const formattedSubjectField = document.getElementById('formattedSubject');
                    if (formattedSubjectField) {
                        formattedSubjectField.value = subject;

                        // Also update the hidden subject field
                        const subjectField = document.getElementById('subject');
                        if (subjectField) {
                            subjectField.value = subject;
                        }

                        // Cache for comparison
                        this._cachedSubjectLine = subject;
                    }

                    console.log('Updated Achievement Levels subject line:', subject, 'isVip:', isVip);
                } catch (error) {
                    console.log('Error in sync subject update:', error);
                }
            }

            // Keep the async method for background updates
            async updateAchievementLevelsSubject() {
                try {
                    // Fetch latest VIP status
                    await this.checkAndUpdateVIPStatus();

                    // Update the subject with latest data
                    this.updateAchievementLevelsSubjectSync();
                } catch (error) {
                    console.log('Error in async subject update:', error);
                }
            }

            loadDataFromStorage() {
                // Try to load data from localStorage based on tracker type
                const storageKey = `${this.trackerType}Data`;
                const storedData = localStorage.getItem(storageKey);

                if (storedData) {
                    try {
                        const parsedData = JSON.parse(storedData);
                        console.log(`Found stored data for ${this.trackerType}:`, parsedData);

                        // Populate fields from stored data
                        if (parsedData.currentTicketId) {
                            // Set the related tickets field to include the source ticket ID
                            const relatedTicketsField = document.getElementById('relatedTickets');
                            if (relatedTicketsField && !relatedTicketsField.value) {
                                relatedTicketsField.value = parsedData.currentTicketId;
                                console.log(`Set related tickets field to source ticket: ${parsedData.currentTicketId}`);
                            }
                        }

                        // Add explicit check and debug for district field and districtName
                        if (parsedData.districtName) {
                            const districtField = document.getElementById('districtField');
                            const districtNameField = document.getElementById('districtName');

                            if (districtField) {
                                districtField.value = parsedData.districtName;
                                // Style it as non-editable
                                districtField.style.backgroundColor = '#f0f0f0';
                                districtField.style.color = '#666';
                                districtField.style.border = '1px solid #ddd';
                                districtField.style.cursor = 'not-allowed';
                                console.log(`Set district field to: ${parsedData.districtName}`);

                                // Ensure this value is stored for ticket creation
                                this.districtDropdownValue = parsedData.districtName;
                                this.districtField = parsedData.districtName;
                            }

                            if (districtNameField) {
                                districtNameField.value = parsedData.districtName;
                                // Make it read-only
                                districtNameField.readOnly = true;
                                districtNameField.style.backgroundColor = '#f0f0f0';
                                districtNameField.style.color = '#666';
                                districtNameField.style.border = '1px solid #ddd';
                                districtNameField.style.cursor = 'not-allowed';
                                console.log(`Set districtName field to: ${parsedData.districtName}`);
                            }
                        } else {
                            console.warn('No district name found in stored data');
                        }

                        // IMPORTANT - Set email field directly
                        if (parsedData.requesterEmail) {
                            const emailField = document.getElementById('email');
                            emailField.value = parsedData.requesterEmail;
                            console.log(`Set email to: ${parsedData.requesterEmail}`);
                        }

                        // IMPORTANT - Make sure priority is set with the right value
                        if (parsedData.priority) {
                            const priorityField = document.getElementById('priority');
                            priorityField.value = parsedData.priority.toString();
                            console.log(`Set priority to: ${parsedData.priority}`);
                        }

                        if (parsedData.isVip !== undefined) {
                            // Find and set VIP field if it exists in this tracker
                            const vipField = document.getElementById('isVIP');
                            if (vipField) {
                                vipField.value = parsedData.isVip ? 'Yes' : 'No';
                            }

                            // Also set hidden VIP checkbox
                            const vipCheckbox = document.getElementById('hiddenVIPStatus');
                            if (vipCheckbox) {
                                vipCheckbox.checked = !!parsedData.isVip;
                                console.log('Set VIP checkbox from stored data:', !!parsedData.isVip);
                            }

                            // Store in ticketData
                            this.ticketData.isVip = !!parsedData.isVip;
                            console.log('Set ticketData.isVip from stored data:', !!parsedData.isVip);
                        }

                        // Clear localStorage to avoid reusing stale data
                        localStorage.removeItem(storageKey);

                        // Add support for product type field
                        if (parsedData.productType) {
                            this.ticketData.productType = parsedData.productType;
                            console.log(`Retrieved product type from stored data:`, this.ticketData.productType);
                        }

                        // Add support for product field
                        if (parsedData.product) {
                            this.ticketData.product = parsedData.product;
                            console.log(`Retrieved product from stored data:`, this.ticketData.product);
                        }

                        // Add support for product subsection field
                        if (parsedData.productSubsection) {
                            this.ticketData.productSubsection = parsedData.productSubsection;
                            console.log(`Retrieved product subsection from stored data:`, this.ticketData.productSubsection);
                        }
                    } catch (error) {
                        console.error("Error parsing stored data:", error);
                    }
                } else {
                    console.warn(`No stored data found for ${this.trackerType}`);
                }

                // Special handling for Achievement Levels tracker
                if (this.trackerType === 'sim-achievement-levels') {
                    // Ensure the district name is populated
                    setTimeout(() => {
                        const districtField = document.getElementById('districtField');
                        const districtNameField = document.getElementById('districtName');

                        if (districtField && districtField.value && districtNameField) {
                            console.log(`Setting districtName to ${districtField.value} from districtField`);
                            districtNameField.value = districtField.value;

                            // Update the subject
                            this.updateAchievementLevelsSubject();
                        }
                    }, 500); // Short delay to ensure fields are available
                }

                // Add this to the loadDataFromStorage method instead
                if (this.trackerType === 'sim-fsa') {
                    const subjectDistrictField = document.querySelector('#section-subject #districtName');
                    const issueDistrictField = document.querySelector('#section-issueDescription #districtName');

                    if (subjectDistrictField && issueDistrictField) {
                        // If we have stored data, use that
                        if (storedData) {
                            try {
                                const parsedData = JSON.parse(storedData);
                                if (parsedData.districtName) {
                                    subjectDistrictField.value = parsedData.districtName;
                                    issueDistrictField.value = parsedData.districtName;
                                    console.log(`Set both district fields to: ${parsedData.districtName}`);
                                }
                            } catch (error) {
                                console.error('Error parsing stored data for district fields:', error);
                            }
                        }

                        // Make the issue description district field read-only
                        issueDistrictField.readOnly = true;
                        issueDistrictField.style.backgroundColor = '#f0f0f0';
                        issueDistrictField.style.color = '#666';
                        issueDistrictField.style.border = '1px solid #ddd';
                        issueDistrictField.style.cursor = 'not-allowed';

                        // Add event listener to keep fields in sync
                        subjectDistrictField.addEventListener('input', () => {
                            issueDistrictField.value = subjectDistrictField.value;
                        });
                    }
                }
            }

            async loadInitialData() {
                try {
                    console.log('Loading initial data');

                    // Get the current ticket ID first
                    let currentTicketId = null;
                    try {
                        const ticketData = await this.client.data.get("ticket");
                        if (ticketData && ticketData.ticket && ticketData.ticket.id) {
                            currentTicketId = ticketData.ticket.id;
                            console.log("Got current ticket ID:", currentTicketId);

                            // Store it for future use
                            this.ticketData.currentTicketId = currentTicketId;

                            // Get product type if available
                            if (ticketData.ticket.custom_fields && ticketData.ticket.custom_fields.cf_product_type) {
                                this.ticketData.productType = ticketData.ticket.custom_fields.cf_product_type;
                                console.log("Retrieved product type from ticket:", this.ticketData.productType);
                            }

                            // Get product if available
                            if (ticketData.ticket.custom_fields && ticketData.ticket.custom_fields.cf_product) {
                                this.ticketData.product = ticketData.ticket.custom_fields.cf_product;
                                console.log("Retrieved product from ticket:", this.ticketData.product);
                            }

                            // Get product subsection if available
                            if (ticketData.ticket.custom_fields && ticketData.ticket.custom_fields.cf_product_subsection) {
                                this.ticketData.productSubsection = ticketData.ticket.custom_fields.cf_product_subsection;
                                console.log("Retrieved product subsection from ticket:", this.ticketData.productSubsection);
                            }

                            // Populate the related tickets field with the current ticket ID
                            const relatedTicketsField = document.getElementById('relatedTickets');
                            if (relatedTicketsField && !relatedTicketsField.value) {
                                relatedTicketsField.value = currentTicketId.toString();
                                console.log("Prepopulated related tickets field with current ticket ID");
                            }

                            // Get the priority from the current ticket and use it for the new ticket
                            if (ticketData.ticket.priority) {
                                const priorityField = document.getElementById('priority');
                                if (priorityField) {
                                    priorityField.value = ticketData.ticket.priority.toString();
                                    console.log(`Set priority from source ticket: ${ticketData.ticket.priority}`);

                                    // Store for later use
                                    this.ticketData.priority = ticketData.ticket.priority;
                                }
                            }

                            // Handle district field synchronization for specific templates
                            if (this.trackerType === 'assembly' || this.trackerType === 'assembly-rollover' || this.trackerType === 'sim-assignment') {
                                const districtField = document.getElementById('districtField');
                                const districtNameField = document.getElementById('districtName');

                                if (districtField && districtNameField) {
                                    console.log("District field value:", districtField.value);
                                    // Copy the district value to district name field
                                    districtNameField.value = districtField.value;

                                    // Make it read-only and style it as non-editable
                                    districtNameField.readOnly = true;
                                    districtNameField.style.backgroundColor = '#f0f0f0';
                                    districtNameField.style.color = '#666';
                                    districtNameField.style.border = '1px solid #ddd';
                                    districtNameField.style.cursor = 'not-allowed';
                                } else {
                                    console.warn("Could not find districtField or districtNameField");
                                }
                            }

                            // Only apply readonly to districtName fields, NOT districtState
                            document.querySelectorAll('input[id="districtName"]').forEach(field => {
                                field.readOnly = true;
                                field.style.backgroundColor = '#f0f0f0';
                                field.style.color = '#666';
                                field.style.border = '1px solid #ddd';
                                field.style.cursor = 'not-allowed';
                            });

                            // Remove any styling that might have been applied to districtState
                            document.querySelectorAll('input[id="districtState"]').forEach(field => {
                                field.readOnly = false;
                                field.style.backgroundColor = '';
                                field.style.color = '';
                                field.style.border = '';
                                field.style.cursor = '';
                            });

                            // Check if this is one of the templates that needs company state data
                            if (this.trackerType === 'sedcust' ||
                                this.trackerType === 'assembly' ||       // Added assembly template
                                this.trackerType === 'assembly-rollover' || // Added assembly-rollover
                                this.trackerType === 'sim-achievement-levels' ||
                                this.trackerType === 'timeout-extension') {

                                // Get company ID from ticket data
                                const companyId = ticketData.ticket.company_id;
                                if (companyId) {
                                    console.log("Found company ID:", companyId);
                                    // Fetch company data to get state
                                    try {
                                        this.fetchCompanyState(companyId);
                                    } catch (companyError) {
                                        console.error("Error fetching company data:", companyError);
                                    }
                                } else {
                                    console.log("No company ID found in ticket data");
                                }
                            }
                        }
                    } catch (ticketError) {
                        console.warn("Could not get current ticket ID:", ticketError);
                    }

                    // Rest of your existing loadInitialData code...
                    // FIRST PRIORITY: Get agent email directly from API
                    try {
                        const userData = await this.client.data.get("loggedInUser");
                        console.log("Direct API user data:", userData);

                        // Try to extract email from various possible locations
                        let agentEmail = '';
                        if (userData && userData.loggedInUser) {
                            // Log the full structure to understand where the email might be
                            console.log("Full userData.loggedInUser:", JSON.stringify(userData.loggedInUser));

                            // Try different possible locations for the email
                            if (userData.loggedInUser.email) {
                                agentEmail = userData.loggedInUser.email;
                            } else if (userData.loggedInUser.contact && userData.loggedInUser.contact.email) {
                                agentEmail = userData.loggedInUser.contact.email;
                            } else if (userData.loggedInUser.primary_email) {
                                agentEmail = userData.loggedInUser.primary_email;
                            } else if (userData.loggedInUser.user && userData.loggedInUser.user.email) {
                                agentEmail = userData.loggedInUser.user.email;
                            }

                            // If we find the email, use it
                            if (agentEmail) {
                                const emailField = document.getElementById('email');
                                emailField.value = agentEmail;
                                console.log("Set email directly from agent data:", agentEmail);
                            } else {
                                // Last resort: try to get email from another API call
                                try {
                                    // Try to get current agent ID
                                    if (userData.loggedInUser.id) {
                                        const agentId = userData.loggedInUser.id;
                                        const agentResponse = await this.client.request.invokeTemplate("getAgentDetails", {
                                            context: {
                                                agentId: agentId
                                            }
                                        });
                                        const agentData = JSON.parse(agentResponse.response);

                                        if (agentData && agentData.contact && agentData.contact.email) {
                                            const emailField = document.getElementById('email');
                                            emailField.value = agentData.contact.email;
                                            console.log("Set email from agent details API:", agentData.contact.email);
                                        }
                                    }
                                } catch (error) {
                                    console.warn("Error getting agent details:", error);
                                }
                            }
                        } else {
                            console.warn("Could not get agent email from userData:", userData);
                        }
                    } catch (agentError) {
                        console.error("Error getting agent email:", agentError);
                    }

                    // Fall back to a hardcoded email if we still don't have one
                    const emailField = document.getElementById('email');
                    if (!emailField.value) {
                        // Try to get the ticket requester's email as a last resort
                        try {
                            const ticketData = await this.client.data.get("ticket");
                            if (ticketData && ticketData.ticket && ticketData.ticket.requester && ticketData.ticket.requester.email) {
                                emailField.value = ticketData.ticket.requester.email;
                                console.log("Set email from ticket requester:", ticketData.ticket.requester.email);
                            }
                        } catch (error) {
                            console.warn("Could not get ticket data:", error);
                        }
                    }

                    // Rest of the method continues as before
                    const today = new Date().toISOString().split('T')[0];
                    document.querySelectorAll('input[type="date"]').forEach(dateField => {
                        dateField.value = today;
                    });

                    await this.loadTicketContext();
                    await this.loadGroups();
                } catch (error) {
                    console.error('Error loading initial data:', error);
                }
            }

            async loadTicketContext() {
                // Simple stub implementation
                console.log('Loading ticket context');
                return Promise.resolve();
            }

            async loadGroups() {
                console.log('Loading groups');

                try {
                    // Show loading state
                    const groupField = document.getElementById('groupField');
                    groupField.innerHTML = '<option value="">Loading groups...</option>';

                    // Fetch groups from API
                    const response = await this.client.request.invokeTemplate("getGroups", {});
                    const groups = JSON.parse(response.response);

                    if (Array.isArray(groups) && groups.length > 0) {
                        // Build options
                        let options = '<option value="">-- Select Group --</option>';
                        let escalationsGroupId = null;

                        groups.forEach(group => {
                            // Check if this is the Escalations group
                            const isEscalations = group.name.toLowerCase() === 'escalations';
                            if (isEscalations) {
                                escalationsGroupId = group.id;
                            }

                            // Add the group to the dropdown
                            options += `<option value="${group.id}" ${isEscalations ? 'selected' : ''}>${group.name}</option>`;
                        });

                        // Set options
                        groupField.innerHTML = options;
                        console.log(`Loaded ${groups.length} groups`);

                        // Load only the specific agents - not all agents
                        await this.loadSpecificAgents();
                    } else {
                        groupField.innerHTML = '<option value="">No groups available</option>';

                        // Set default to Escalations anyway
                        groupField.innerHTML = `
                            <option value="">-- Select Group --</option>
                            <option value="escalations" selected>Escalations</option>
                            <option value="1">Support</option>
                            <option value="2">Engineering</option>
                        `;

                        // Also load the specific agents
                        await this.loadSpecificAgents();
                    }
                } catch (error) {
                    console.error('Error loading groups:', error);

                    // Fallback with Escalations selected
                    document.getElementById('groupField').innerHTML = `
                        <option value="">-- Select Group --</option>
                        <option value="escalations" selected>Escalations</option>
                        <option value="1">Support</option>
                        <option value="2">Engineering</option>
                    `;

                    // Load the specific agents
                    await this.loadSpecificAgents();
                }
            }

            async loadSpecificAgents() {
                console.log('Loading specific agents');

                const agentField = document.getElementById('agentField');
                if (!agentField) {
                    console.error('Agent field not found');
                    return;
                }

                try {
                    // Show loading state
                    agentField.innerHTML = '<option value="">Loading agents...</option>';

                    // Load selected agents from admin settings
                    const selectedAgentIds = await this.client.db.get('selectedAgentIds').catch(error => {
                        console.error("Error loading selected agent IDs from Freshdesk DB:", error);
                        // Fall back to localStorage if needed
                        const localAgents = localStorage.getItem('selectedAgentIds');
                        if (localAgents) {
                            return JSON.parse(localAgents);
                        }
                        return null;
                    });

                    if (selectedAgentIds) {
                        // Define all available agents with their IDs and names (same as in admin-settings.html)
                        const ALL_AGENTS = [
                            { id: '67064466505', name: 'Brad Sheng' },
                            { id: '67054610590', name: 'Dayna Clarke' },
                            { id: '67051499418', name: 'Drita Lulgjuraj' },
                            { id: '67046816271', name: 'Felicia Wold' },
                            { id: '67030529218', name: 'Jordan Fields' },
                            { id: '67025130684', name: 'Katrina Papaj' },
                            { id: '67062102069', name: 'Kristi Garcia' },
                            { id: '67063081184', name: 'Kristina Boga' },
                            { id: '67062322271', name: 'Lisa Morgan' },
                            { id: '67025683491', name: 'Mohammad Azeem' },
                            { id: '67025131090', name: 'Shaima Mannino' },
                            { id: '67029732378', name: 'Shanto Kapali' },
                            { id: '67036373043', name: 'Steve Skalamera' },
                            { id: '67031011668', name: 'Suriya Iqbal' }
                        ];

                        // Convert selectedAgentIds to array if it's an object
                        let agentIdsArray = selectedAgentIds;
                        if (typeof selectedAgentIds === 'object' && !Array.isArray(selectedAgentIds)) {
                            agentIdsArray = Object.values(selectedAgentIds);
                        }

                        // Filter to only include selected agents
                        const selectedAgents = ALL_AGENTS.filter(agent =>
                            agentIdsArray.includes(agent.id)
                        );

                        // Build options
                        let options = '<option value="">-- Select Agent --</option>';
                        selectedAgents.forEach(agent => {
                            options += `<option value="${agent.id}">${agent.name}</option>`;
                        });

                        // Set options
                        agentField.innerHTML = options;
                        console.log(`Loaded ${selectedAgents.length} agents from admin settings`);
                    } else {
                        // Default: show all agents if no selection has been made
                        agentField.innerHTML = `
                            <option value="">-- Select Agent --</option>
                            <option value="67064466505">Brad Sheng</option>
                            <option value="67054610590">Dayna Clarke</option>
                            <option value="67051499418">Drita Lulgjuraj</option>
                            <option value="67046816271">Felicia Wold</option>
                            <option value="67030529218">Jordan Fields</option>
                            <option value="67025130684">Katrina Papaj</option>
                            <option value="67062102069">Kristi Garcia</option>
                            <option value="67063081184">Kristina Boga</option>
                            <option value="67062322271">Lisa Morgan</option>
                            <option value="67025683491">Mohammad Azeem</option>
                            <option value="67025131090">Shaima Mannino</option>
                            <option value="67029732378">Shanto Kapali</option>
                            <option value="67036373043">Steve Skalamera</option>
                            <option value="67031011668">Suriya Iqbal</option>
                        `;
                        console.log('No agent selection found in settings, showing all agents');
                    }
                    return;

                    // The code below is kept for reference but will be skipped due to the return above
                    agentField.innerHTML = '<option value="">Loading agents...</option>';

                    // Fetch all agents from API
                    const response = await this.client.request.invokeTemplate("getAllAgents", {});
                    const allAgents = JSON.parse(response.response);
                    console.log('All agents from API:', allAgents);

                    if (Array.isArray(allAgents) && allAgents.length > 0) {
                        // Filter to only include specific agents
                        const specificAgents = allAgents.filter(agent =>
                            specificAgentIds.includes(agent.id)
                        );

                        console.log('Filtered specificAgents:', specificAgents);

                        // Build options
                        let options = '<option value="">-- Select Agent --</option>';

                        specificAgents.forEach(agent => {
                            // Get agent name
                            let agentName = 'Unknown Agent';
                            let agentId = agent.id;

                            if (agent.contact && agent.contact.name) {
                                agentName = agent.contact.name;
                            } else if (agent.name) {
                                agentName = agent.name;
                            } else if (agent.email) {
                                agentName = agent.email.split('@')[0]; // Use part of email as name
                            }

                            console.log(`Adding agent option: ${agentName} (${agentId})`);
                            options += `<option value="${agentId}">${agentName}</option>`;
                        });

                        // Set options
                        agentField.innerHTML = options;
                        console.log(`Loaded ${specificAgents.length} specific agents`);
                    } else {
                        agentField.innerHTML = '<option value="">No agents available</option>';
                    }
                } catch (error) {
                    console.error('Error loading specific agents:', error);

                    // Fallback hardcoded agents - show the four that were previously hardcoded
                    agentField.innerHTML = `
                        <option value="">-- Select Agent --</option>
                        <option value="67025683491">Mohammad Azeem</option>
                        <option value="67031011668">Suriya Iqbal</option>
                        <option value="67025131090">Shaima Mannino</option>
                        <option value="67051499418">Drita Lulgjuraj</option>
                    `;
                }
            }

            handleFormSubmit() {
                console.log('Form submitted');

                // Show the loading overlay
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'flex';
                }

                // Add error handler for 413 errors
                const handle413Error = (error) => {
                    console.error('Checking for 413 error:', error);

                    // Hide loading overlay
                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'none';
                    }

                    // Check if this is a 413 error
                    if ((error && error.message && error.message.includes('413')) ||
                        (error && error.status === 413) ||
                        (window.lastErrorStatus === 413)) {

                        this.showError("Your form submission exceeds the maximum allowed size. Please reduce the number of pasted screenshots and consider using file attachments instead.");
                        return true;
                    }
                    return false;
                };

                // Try to intercept the form submission to catch 413 errors
                try {
                    const form = document.getElementById('trackerForm');
                    const originalSubmit = form.submit;

                    form.submit = function () {
                        try {
                            return originalSubmit.apply(this, arguments);
                        } catch (error) {
                            if (!handle413Error(error)) {
                                throw error; // re-throw if not a 413
                            }
                        }
                    };
                } catch (e) {
                    console.error('Error setting up form intercept:', e);
                }

                // Set default values for hidden required fields
                this.setDefaultValuesForHiddenFields();

                // Reset previous errors
                document.querySelectorAll('.validation-error').forEach(el => el.remove());
                document.querySelectorAll('.field-error').forEach(el => el.classList.remove('field-error'));

                // Validate the form first
                if (!this.validateForm()) {
                    // Hide loading overlay if validation fails
                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'none';
                    }
                    return;
                }

                // Get all form data and update hidden description field
                try {
                    // Get the data and sanitize it
                    let formData = this.getFormData();
                    formData = this.sanitizeFormData(formData);

                    console.log('Form data:', formData);

                    // Generate description using the configured template
                    const description = this.generateDescription();
                    document.getElementById('description').value = description;
                    console.log('Generated description:', description);

                    // Create the ticket in Freshdesk
                    this.createTicket(formData);
                } catch (error) {
                    console.error('Error submitting form:', error);
                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'none';
                    }
                    this.showError('Error submitting form: ' + (error.message || 'Unknown error'));
                }
            }

            // Add this new method to set default values for hidden required fields
            setDefaultValuesForHiddenFields() {
                // Set default status if hidden
                const statusField = document.getElementById('status');
                if (statusField && statusField.style.display === 'none' && !statusField.value) {
                    statusField.value = '2'; // Default to Open
                }

                // Set default priority if hidden
                const priorityField = document.getElementById('priority');
                if (priorityField && priorityField.style.display === 'none' && !priorityField.value) {
                    priorityField.value = '2'; // Default to Medium
                }

                // Ensure email has a value
                const emailField = document.getElementById('email');
                if (emailField && emailField.style.display === 'none' && !emailField.value) {
                    // Try to get from the window variable if available
                    if (this.client && this.client.data) {
                        this.client.data.get("loggedInUser").then(userData => {
                            if (userData && userData.loggedInUser && userData.loggedInUser.email) {
                                emailField.value = userData.loggedInUser.email;
                            }
                        }).catch(err => console.error("Error getting logged-in user email:", err));
                    }
                }
            }

            validateForm() {
                // Reset any previous validation errors
                document.querySelectorAll('.validation-error').forEach(el => el.remove());
                document.querySelectorAll('.field-error').forEach(el => el.classList.remove('field-error'));

                let isValid = true;

                // Check required fields (but skip hidden ones)
                const requiredFields = document.querySelectorAll('[required]');
                for (let field of requiredFields) {
                    // Skip validation for hidden fields
                    const parent = this.findParentWithClass(field, 'form-group');
                    if (parent && parent.style.display === 'none') {
                        continue;
                    }

                    if (!field.value.trim()) {
                        isValid = false;
                        this.showFieldError(field, 'This field is required');
                    }
                }

                // Add conditional required validation for HAR file reason
                if (this.trackerType === 'sim-assignment' || this.trackerType === 'sim-assessment-reports') {
                    const harFileAttached = document.getElementById('harFileAttached');
                    const harFileReason = document.getElementById('harFileReason');

                    if (harFileAttached && harFileReason && harFileAttached.value === 'No') {
                        // If HAR file is not attached, reason is required
                        if (!harFileReason.value.trim()) {
                            isValid = false;
                            this.showFieldError(harFileReason, 'Please provide a reason for not attaching a HAR file');
                        }
                    }
                }

                // Rest of validation code remains the same...

                // Email validation for email fields
                const emailFields = document.querySelectorAll('input[type="email"]');
                for (let field of emailFields) {
                    if (field.value && !this.isValidEmail(field.value)) {
                        isValid = false;
                        this.showFieldError(field, 'Please enter a valid email address');
                    }
                }

                // Check the Quill editors for required content
                Object.keys(this.quillEditors).forEach(id => {
                    const editor = this.quillEditors[id];
                    const textareaElement = document.getElementById(id);

                    if (textareaElement && textareaElement.hasAttribute('required')) {
                        const content = editor.getText().trim();
                        if (!content) {
                            isValid = false;
                            const editorElement = editor.container;
                            this.showFieldError(editorElement, 'This field is required');
                            editor.container.classList.add('field-error');
                        }
                    }
                });

                // Check if related tickets field is filled
                const relatedTicketsField = document.getElementById('relatedTickets');
                if (!relatedTicketsField.value.trim()) {
                    isValid = false;
                    this.showFieldError(relatedTicketsField, 'At least one related ticket ID is required to create a tracker');
                }

                if (!isValid) {
                    this.showError('Please correct the errors in the form');
                }

                // Add this to your validateForm method
                // Ensure VIP tickets always get priority 3
                if (this.ticketData && this.ticketData.isVip) {
                    console.log("Form validation: Ensuring HIGH priority (3) for VIP ticket");
                    const priorityField = document.getElementById('priority');
                    if (priorityField) {
                        // Only increase priority if it's currently lower than HIGH (3)
                        // This preserves URGENT (4) if it was intentionally set
                        if (parseInt(priorityField.value) < 3) {
                            priorityField.value = "3";
                            console.log("Increased priority to HIGH (3) for VIP ticket");
                        } else {
                            console.log(`Keeping existing priority (${priorityField.value}) as it's already HIGH or URGENT`);
                        }
                    }
                }

                return isValid;
            }

            showFieldError(field, message) {
                // Add error class to the field
                field.classList.add('field-error');

                // Create and append the error message
                const errorElement = document.createElement('div');
                errorElement.className = 'validation-error';
                errorElement.textContent = message;

                // Insert after the field
                if (field.parentNode) {
                    field.parentNode.appendChild(errorElement);
                }
            }

            isValidEmail(email) {
                const re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
                return re.test(String(email).toLowerCase());
            }

            generateDescription() {
                // Get values from all form fields
                const formData = this.getFormData();

                // Log all keys in formData to help debug
                console.log("Form data keys:", Object.keys(formData));
                console.log("Screenshots description:", formData.screenshotsDescription);
                console.log("Steps to reproduce:", formData.stepsToReproduce);

                // Make sure we have all necessary fields for assemblyTracker
                if (this.trackerType === 'assembly') {
                    // Ensure pathField, actualResults, and expectedResults are available
                    console.log("Assembly tracker - ensuring all fields are available for description generation:");
                    console.log("  pathField:", formData.pathField);
                    console.log("  actualResults:", formData.actualResults);
                    console.log("  expectedResults:", formData.expectedResults);
                }

                // Use the description generator from the config
                let description = '';
                if (this.config.descriptionGenerator && typeof this.config.descriptionGenerator === 'function') {
                    try {
                        description = this.config.descriptionGenerator(formData);
                        console.log("Successfully generated description using template's descriptionGenerator function");
                    } catch (error) {
                        console.error("Error using template's descriptionGenerator:", error);
                        // Fallback to default description
                        description = `<div>${formData.subject || 'No subject'}</div>`;
                    }
                } else {
                    // Default description generator for blank template
                    description = `<div>${formData.subject || 'No subject'}</div>`;
                }

                return description;
            }

            getFormData() {
                // Get values from all form fields
                const formData = {};

                // Get values from Quill editors
                Object.keys(this.quillEditors).forEach(id => {
                    const editor = this.quillEditors[id];
                    const textareaElement = document.getElementById(id);
                    if (textareaElement) {
                        const content = editor.root.innerHTML;
                        textareaElement.value = content;
                        formData[id] = content;
                    }
                });

                // Get values from regular form fields
                const formElements = document.getElementById('trackerForm').elements;
                for (let i = 0; i < formElements.length; i++) {
                    const element = formElements[i];
                    if (element.name && element.name !== '') {
                        formData[element.name] = element.value;
                    }
                }

                // Special handling for assembly tracker - explicitly check for the required fields
                if (this.trackerType === 'assembly') {
                    // Check for pathField
                    const pathField = document.getElementById('pathField');
                    if (pathField) {
                        formData.pathField = pathField.value;
                        console.log("Explicitly adding pathField to formData:", pathField.value);
                    }

                    // Double-check that the Quill editors for actualResults and expectedResults got added
                    if (!formData.actualResults) {
                        const actualResultsEditor = this.quillEditors['actualResults'];
                        if (actualResultsEditor) {
                            formData.actualResults = actualResultsEditor.root.innerHTML;
                            console.log("Explicitly adding actualResults to formData:", formData.actualResults);
                        }
                    }

                    if (!formData.expectedResults) {
                        const expectedResultsEditor = this.quillEditors['expectedResults'];
                        if (expectedResultsEditor) {
                            formData.expectedResults = expectedResultsEditor.root.innerHTML;
                            console.log("Explicitly adding expectedResults to formData:", formData.expectedResults);
                        }
                    }
                }

                // Add district dropdown field explicitly
                if (this.districtDropdownValue) {
                    formData.districtDropdownValue = this.districtDropdownValue;
                } else if (formData.districtField) {
                    // If districtDropdownValue is not available, use districtField
                    formData.districtDropdownValue = formData.districtField;
                }

                return formData;
            }

            showError(message) {
                console.error(message);
                // Display error in UI
                if (typeof client !== 'undefined') {
                    client.interface.trigger("showNotify", {
                        type: "danger",
                        message: message
                    }).catch(err => console.error("Error showing notification:", err));
                } else {
                    alert('Error: ' + message);
                }
            }

            handleFileInputChange(e) {
                const files = Array.from(e.target.files);
                const previewContainer = document.getElementById('screenshotPreview');
                const counter = document.getElementById('attachmentCounter');

                if (!files.length) return;

                // Append to existing files instead of replacing them
                this.aggregatedScreenshotFiles = [...this.aggregatedScreenshotFiles, ...files];

                // Create previews for the newly added files
                files.forEach(file => {
                    const thumbnail = document.createElement('div');
                    thumbnail.className = 'screenshot-thumbnail';

                    // Create thumbnail content
                    const fileTypeIcon = this.getFileTypeIcon(file.type);
                    thumbnail.innerHTML = `
                        <div class="file-preview">
                            <i class="${fileTypeIcon}"></i>
                        </div>
                        <div class="screenshot-filename">${file.name}</div>
                        <div class="screenshot-remove" data-filename="${file.name}">×</div>
                    `;

                    previewContainer.appendChild(thumbnail);
                });

                // Update counter
                if (this.aggregatedScreenshotFiles.length > 0) {
                    counter.textContent = `${this.aggregatedScreenshotFiles.length} file(s) selected (${this.formatFileSize(this.aggregatedScreenshotFiles.reduce((total, file) => total + file.size, 0))})`;
                } else {
                    counter.textContent = '';
                }

                // Add event listeners to remove buttons
                document.querySelectorAll('.screenshot-remove').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const filename = e.target.getAttribute('data-filename');
                        this.removeFile(filename);
                    });
                });

                // Reset the file input to allow selecting the same files again
                e.target.value = '';
            }

            getFileTypeIcon(mimeType) {
                if (mimeType.startsWith('image/')) return 'fas fa-image';
                if (mimeType.startsWith('video/')) return 'fas fa-video';
                if (mimeType.startsWith('audio/')) return 'fas fa-music';
                if (mimeType.includes('pdf')) return 'fas fa-file-pdf';
                if (mimeType.includes('word') || mimeType.includes('document')) return 'fas fa-file-word';
                if (mimeType.includes('excel') || mimeType.includes('sheet')) return 'fas fa-file-excel';
                if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return 'fas fa-file-powerpoint';
                if (mimeType.includes('zip') || mimeType.includes('compressed')) return 'fas fa-file-archive';
                return 'fas fa-file';
            }

            formatFileSize(bytes) {
                if (bytes < 1024) return bytes + ' bytes';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
            }

            removeFile(filename) {
                // Remove from stored files array
                this.aggregatedScreenshotFiles = this.aggregatedScreenshotFiles.filter(file => file.name !== filename);

                // Remove thumbnail from UI
                const thumbnails = document.querySelectorAll('.screenshot-thumbnail');
                thumbnails.forEach(thumbnail => {
                    const filenameElement = thumbnail.querySelector('.screenshot-filename');
                    if (filenameElement && filenameElement.textContent === filename) {
                        thumbnail.remove();
                    }
                });

                // Update counter
                const counter = document.getElementById('attachmentCounter');
                if (this.aggregatedScreenshotFiles.length > 0) {
                    counter.textContent = `${this.aggregatedScreenshotFiles.length} file(s) selected (${this.formatFileSize(this.aggregatedScreenshotFiles.reduce((total, file) => total + file.size, 0))})`;
                } else {
                    counter.textContent = '';
                }
            }

            fillFormWithDemoData() {
                console.log("Filling form with demo data...");

                // KEEP the related tickets field (don't overwrite it)
                // const relatedTicketsField = document.getElementById('relatedTickets');
                // if (relatedTicketsField && !relatedTicketsField.value) {
                //     relatedTicketsField.value = "123456"; // Sample ticket ID for testing
                // }

                // Set priority
                document.getElementById('priority').value = '2';

                // Set status
                document.getElementById('status').value = '2'; // Open

                // Set subject if it exists
                const subjectField = document.getElementById('subject');
                if (subjectField) {
                    subjectField.value = `Test ${this.config.title}`;
                }

                // Set values in quill editors
                Object.keys(this.quillEditors).forEach(id => {
                    this.quillEditors[id].root.innerHTML = '<p>This is sample content for testing.</p>';
                });

                // Set ALL text fields that aren't special fields
                document.querySelectorAll('input[type="text"]').forEach(input => {
                    const fieldId = input.id.toLowerCase();

                    // Skip these special fields
                    if (fieldId !== 'subject' &&
                        fieldId !== 'relatedtickets' &&
                        fieldId !== 'districtfield') {

                        // Use a sensible default value based on the field's ID
                        input.value = `Sample ${input.id.replace(/([A-Z])/g, ' $1').toLowerCase()}`;

                        // For common fields, provide more realistic values
                        if (fieldId === 'districtname') {
                            input.value = 'Demo School District';
                        } else if (fieldId === 'xcode') {
                            input.value = 'X12345';
                        } else if (fieldId === 'application') {
                            input.value = 'Demo Application';
                        } else if (fieldId === 'specificissue') {
                            input.value = 'Sample Issue';
                        } else if (fieldId.includes('email')) {
                            input.value = 'demo@example.com';
                        }
                    }
                });

                // Set select fields to their first option if not already set (except group/agent fields)
                document.querySelectorAll('select').forEach(select => {
                    const selectId = select.id.toLowerCase();
                    if (selectId !== 'groupfield' &&
                        selectId !== 'agentfield' &&
                        !select.value &&
                        select.options.length > 0) {

                        // For selects, choose the first or second option to avoid blank values
                        select.value = select.options[Math.min(1, select.options.length - 1)].value;
                    }
                });

                // Ensure date fields have a value
                document.querySelectorAll('input[type="date"]').forEach(dateField => {
                    if (!dateField.value) {
                        const today = new Date();
                        dateField.value = today.toISOString().split('T')[0];
                    }
                });

                // If this is one of the templates with a formatted subject, update it
                if (this.trackerType === 'assembly') {
                    this.updateFormattedSubject();
                } else if (this.trackerType === 'sedcust') {
                    this.updateSedcustSubject();
                } else if (this.trackerType === 'sim-assignment') {
                    this.updateSimAssignmentSubject();
                } else if (this.trackerType === 'sim-assessment-reports') {
                    this.updateSIMAssessmentReportsSubject();
                }

                console.log("Form filled with demo data");
            }

            handlePasteImage(e, editor) {
                const clipboardData = e.clipboardData;
                if (!clipboardData || !clipboardData.items) return;

                const items = clipboardData.items;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') !== -1) {
                        e.preventDefault(); // Prevent default paste behavior

                        // Show loading indicator in editor
                        const range = editor.getSelection(true);
                        editor.insertText(range.index, "Uploading image... ", { italic: true, color: '#999' });
                        const placeholderIndex = range.index;

                        // Get the file from clipboard
                        const file = items[i].getAsFile();
                        console.log('Image pasted into editor:', file.name);

                        // Upload to ImgBB
                        this.uploadImageToImgBB(file).then(imageUrl => {
                            // Delete the placeholder text
                            editor.deleteText(placeholderIndex, "Uploading image... ".length);

                            // Insert the image at original paste position
                            editor.insertEmbed(placeholderIndex, 'image', imageUrl);
                            editor.setSelection(placeholderIndex + 1);
                        }).catch(error => {
                            console.error('Error uploading pasted image:', error);

                            // Replace placeholder with error message
                            editor.deleteText(placeholderIndex, "Uploading image... ".length);
                            editor.insertText(placeholderIndex, "⚠️ Image upload failed ", { italic: true, color: 'red' });
                        });

                        // Only handle the first image in the clipboard
                        break;
                    }
                }
            }

            handleDropImage(e, editor) {
                e.preventDefault();

                if (e.dataTransfer.files && e.dataTransfer.files.length) {
                    const file = e.dataTransfer.files[0];

                    // Check if it's an image
                    if (file.type.match(/^image\/(gif|jpe?g|png|webp|bmp)$/i)) {
                        // Show loading indicator
                        const range = editor.getSelection(true);
                        editor.insertText(range.index, "Uploading image... ", { italic: true, color: '#999' });
                        const placeholderIndex = range.index;

                        // Upload to ImgBB
                        this.uploadImageToImgBB(file).then(imageUrl => {
                            // Delete the placeholder text
                            editor.deleteText(placeholderIndex, "Uploading image... ".length);

                            // Insert the image at drop position
                            editor.insertEmbed(placeholderIndex, 'image', imageUrl);
                            editor.setSelection(placeholderIndex + 1);
                        }).catch(error => {
                            console.error('Error uploading dropped image:', error);

                            // Replace placeholder with error message
                            editor.deleteText(placeholderIndex, "Uploading image... ".length);
                            editor.insertText(placeholderIndex, "⚠️ Image upload failed ", { italic: true, color: 'red' });
                        });
                    }
                }
            }

            async uploadImageToImgBB(imageFile) {
                console.log(`Uploading image to ImgBB: ${imageFile.name} (${this.formatFileSize(imageFile.size)})`);

                try {
                    // Convert the image to base64
                    const base64Image = await this.readFileAsBase64(imageFile);

                    // Create form data for the API request
                    const formData = new FormData();
                    formData.append('key', 'b3da8c974bc40dd87d896d84436dd76e'); // Your ImgBB API key
                    formData.append('image', base64Image);
                    formData.append('name', imageFile.name);

                    // Make the API request
                    const response = await fetch('https://api.imgbb.com/1/upload', {
                        method: 'POST',
                        body: formData
                    });

                    // Parse the response
                    const result = await response.json();

                    if (result.success) {
                        console.log('Image uploaded successfully:', result.data.url);
                        // Return the display URL (medium size) for better quality
                        return result.data.display_url;
                    } else {
                        throw new Error(result.error?.message || 'Upload failed');
                    }
                } catch (error) {
                    console.error('Error uploading to ImgBB:', error);
                    throw error;
                }
            }

            readFileAsBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        // Get the base64 part without the prefix
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            handleTicketCreationSuccess(ticketData) {
                console.log('Ticket created successfully:', ticketData);

                // Hide loading overlay only after all operations (including attachments) are done
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'flex'; // Keep showing until attachments are processed
                    loadingOverlay.querySelector('.spinner-text').textContent = "Processing attachments...";
                }

                // Show success message
                const successMessage = document.createElement('div');
                successMessage.className = 'success-message';
                successMessage.innerHTML = `
                    <i class="fas fa-check-circle"></i>
                    Tracker ticket #${ticketData.id} created successfully!
                `;

                // Insert at the top of the form
                const form = document.getElementById('trackerForm');
                form.insertBefore(successMessage, form.firstChild);

                // Increment the daily tracker count
                try {
                    console.log(`[TRACKER COUNT] Attempting to increment count for tracker type: ${this.trackerType}`);
                    if (window.incrementTrackerCount && typeof window.incrementTrackerCount === 'function') {
                        window.incrementTrackerCount(this.trackerType, ticketData.id, ticketData.subject);
                        console.log(`[TRACKER COUNT] Successfully called incrementTrackerCount for template: ${this.trackerType}, ID: ${ticketData.id}, Subject: ${ticketData.subject}`);
                    } else {
                        console.warn('[TRACKER COUNT] incrementTrackerCount function not available on window object');
                        console.log('[TRACKER COUNT] Available functions on window:', Object.keys(window).filter(key => key.includes('tracker') || key.includes('Count')));
                    }
                } catch (error) {
                    console.error('[TRACKER COUNT] Error incrementing tracker count:', error);
                }

                // We'll use Promise.all to make sure we process all async operations
                const processingTasks = [];

                // Upload any attachments as a separate note
                const hasScreenshots = this.aggregatedScreenshotFiles && this.aggregatedScreenshotFiles.length > 0;
                // Check for HAR file in all SIM templates
                const hasHarFile = this.trackerType.startsWith('sim-') && this.harFile;

                if (hasScreenshots || hasHarFile) {
                    processingTasks.push(this.addAttachmentsAsNote(ticketData.id));
                }

                // Wait for all processing to complete
                Promise.all(processingTasks)
                    .then(() => {
                        console.log('All post-creation tasks completed successfully');

                        // Hide loading overlay
                        if (loadingOverlay) {
                            loadingOverlay.style.display = 'none';
                        }

                        // Disable submit button
                        const submitButton = document.getElementById('createTracker');
                        if (submitButton) {
                            submitButton.disabled = true;
                        }

                        // Show notification
                        this.client.interface.trigger("showNotify", {
                            type: "success",
                            message: `Tracker ticket #${ticketData.id} created successfully!`
                        }).catch(err => console.error("Error showing notification:", err));

                        // Get the Freshdesk subdomain and automatically open the ticket in a new tab
                        this.client.iparams.get("freshdesk_subdomain").then(iparams => {
                            const subdomain = iparams.freshdesk_subdomain.replace(/\.freshdesk\.com$/i, '');
                            const ticketUrl = `https://${subdomain}.freshdesk.com/a/tickets/${ticketData.id}`;

                            // Open in a new tab
                            window.open(ticketUrl, '_blank');

                            // Return to template selector after a short delay
                            setTimeout(() => {
                                window.location.href = 'template-selector.html';
                            }, 1500);
                        }).catch((error) => {
                            console.error("Error getting subdomain:", error);
                            // Fallback to generic URL
                            window.open(`https://freshdesk.com/a/tickets/${ticketData.id}`, '_blank');

                            // Return to template selector after a short delay
                            setTimeout(() => {
                                window.location.href = 'template-selector.html';
                            }, 1500);
                        });
                    })
                    .catch(error => {
                        console.error('Error during post-creation tasks:', error);

                        // Hide loading overlay
                        if (loadingOverlay) {
                            loadingOverlay.style.display = 'none';
                        }

                        // Show a more helpful error message
                        this.showError('Ticket created, but there was an error uploading attachments. You may need to manually add files to the ticket.');

                        // Still open the ticket
                        this.client.iparams.get("freshdesk_subdomain").then(iparams => {
                            const subdomain = iparams.freshdesk_subdomain.replace(/\.freshdesk\.com$/i, '');
                            const ticketUrl = `https://${subdomain}.freshdesk.com/a/tickets/${ticketData.id}`;
                            window.open(ticketUrl, '_blank');

                            // Return to template selector after a short delay
                            setTimeout(() => {
                                window.location.href = 'template-selector.html';
                            }, 1500);
                        }).catch(() => {
                            window.open(`https://freshdesk.com/a/tickets/${ticketData.id}`, '_blank');
                            setTimeout(() => window.location.href = 'template-selector.html', 1500);
                        });
                    });
            }

            async associateWithRelatedTickets(ticketId) {
                // Skip if no related tickets
                if (!this.relatedTicketIds || this.relatedTicketIds.length === 0) {
                    return;
                }

                console.log(`Associating ticket #${ticketId} with related tickets:`, this.relatedTicketIds);

                // Process each related ticket
                for (const relatedId of this.relatedTicketIds) {
                    try {
                        await this.client.request.invokeTemplate("associateTickets", {
                            context: {
                                primaryTicketId: ticketId,
                                secondaryTicketId: relatedId
                            }
                        });
                        console.log(`Successfully associated with ticket #${relatedId}`);
                    } catch (error) {
                        console.error(`Failed to associate with ticket #${relatedId}:`, error);
                        // Continue with other tickets even if one fails
                    }
                }
            }

            async createTicket(formData) {
                try {
                    const loadingOverlay = document.getElementById('loadingOverlay');

                    // Get the formatted subject from the form
                    const formattedSubjectField = document.getElementById('formattedSubject');
                    let subject = formattedSubjectField ? formattedSubjectField.value : formData.subject;

                    // If no formatted subject, fall back to regular subject
                    if (!subject) {
                        subject = formData.subject || `${this.config.title} - ${new Date().toLocaleDateString()}`;
                    }

                    // Parse and validate related tickets
                    let relatedTicketIds = [];
                    if (formData.relatedTickets) {
                        relatedTicketIds = formData.relatedTickets.split(',')
                            .map(id => id.trim())
                            .filter(id => id !== '')
                            .map(id => parseInt(id, 10))
                            .filter(id => !isNaN(id));
                    }

                    // Get source ticket data from the first related ticket
                    let sourceTicketData = null;
                    if (relatedTicketIds.length > 0) {
                        try {
                            const sourceTicketId = relatedTicketIds[0];
                            const response = await this.client.request.invokeTemplate("getTicketDetails", {
                                context: { ticketId: sourceTicketId }
                            });
                            sourceTicketData = JSON.parse(response.response);
                            console.log("Retrieved source ticket data:", sourceTicketData);
                        } catch (error) {
                            console.error("Error getting source ticket data:", error);
                        }
                    }

                    // Add validation to check if related tickets exist
                    try {
                        for (const ticketId of relatedTicketIds) {
                            const response = await this.client.request.invokeTemplate("getTicketDetails", {
                                context: { ticketId: ticketId }
                            });
                            // If we get here, the ticket exists
                            console.log(`Verified related ticket ${ticketId} exists`);
                        }
                    } catch (error) {
                        console.error("Error validating related tickets:", error);
                        throw new Error("One or more related ticket IDs are invalid or inaccessible. Please verify the ticket numbers.");
                    }

                    // Generate description BEFORE creating ticketData
                    const description = this.generateDescription();
                    document.getElementById('description').value = description;

                    // Instead of cleaning by excluding fields, let's only include fields that are valid for the API
                    // Create the ticket data object with only valid Freshdesk API fields
                    let ticketData = {
                        email: formData.email,
                        subject: subject,
                        description: description,
                        status: parseInt(formData.status || 2),
                        priority: parseInt(formData.priority || 2),
                        tags: [`tracker-${this.trackerType}`],
                        related_ticket_ids: relatedTicketIds,
                        source: 101,
                        custom_fields: {},
                        type: "Incident" // Set ticket type to Incident by default
                    };

                    // Add VIP tag if applicable, but DO NOT add district name as tag
                    // (Freshdesk has a 32-character limit for tags, and district names can exceed this)
                    // VIP tag is no longer added to prevent confusion with VIP custom field

                    // IMPORTANT: District name is NOT added as a tag to prevent validation errors
                    // Freshdesk has a 32-character limit for tags, and district names can exceed this
                    console.log("Tags set (without district name):", ticketData.tags);

                    // Store related tickets to create associations after ticket creation
                    this.relatedTicketIds = relatedTicketIds;

                    // Use source ticket priority if available
                    if (sourceTicketData && sourceTicketData.priority) {
                        console.log(`Using source ticket priority: ${sourceTicketData.priority}`);
                        ticketData.priority = sourceTicketData.priority;

                        // Also update the priority field in the form for consistency
                        const priorityField = document.getElementById('priority');
                        if (priorityField) {
                            priorityField.value = sourceTicketData.priority.toString();
                        }
                    }

                    // Copy custom fields from source ticket if available
                    if (sourceTicketData && sourceTicketData.custom_fields) {
                        // List of custom fields to include from source ticket
                        const customFieldsToPreserve = [
                            'cf_account_manager',
                            'cf_rvp',
                            'cf_categorization',
                            'cf_subcategory',
                            'cf_issue_detail',
                            'cf_product_type',
                            'cf_product',
                            'cf_product_subsection',
                            'cf_vip'
                        ];

                        // Copy the custom fields
                        customFieldsToPreserve.forEach(field => {
                            if (sourceTicketData.custom_fields[field] !== undefined) {
                                ticketData.custom_fields[field] = sourceTicketData.custom_fields[field];
                                console.log(`Copied custom field ${field} from source ticket:`, ticketData.custom_fields[field]);
                            }
                        });
                    }

                    // Set district field
                    if (formData.districtField) {
                        ticketData.custom_fields.cf_district509811 = String(formData.districtField);
                        console.log(`Set district field - cf_district509811: ${formData.districtField}`);
                    }
                    // Use fallback methods if district field not available
                    else if (formData.districtName) {
                        ticketData.custom_fields.cf_district509811 = String(formData.districtName);
                        console.log(`Using districtName as fallback for district field: ${formData.districtName}`);
                    }
                    else if (formData.districtDropdownValue) {
                        ticketData.custom_fields.cf_district509811 = String(formData.districtDropdownValue);
                        console.log(`Using districtDropdownValue as fallback for district field: ${formData.districtDropdownValue}`);
                    }

                    // Add group if selected
                    if (formData.groupField && formData.groupField !== '') {
                        const groupId = parseInt(formData.groupField, 10);
                        if (!isNaN(groupId)) {
                            ticketData.group_id = groupId;
                        }
                    }

                    // Add agent if selected
                    if (formData.agentField && formData.agentField !== '') {
                        const responderId = parseInt(formData.agentField, 10);
                        if (!isNaN(responderId)) {
                            ticketData.responder_id = responderId;
                        }
                    }

                    // Final check for VIP status and priority
                    if (this.ticketData && this.ticketData.isVip) {
                        console.log("Final check: Setting priority to HIGH (3) for VIP ticket");
                        // Only increase priority if it's currently lower than HIGH (3)
                        // This preserves URGENT (4) if it was intentionally set
                        if (parseInt(ticketData.priority) < 3) {
                            ticketData.priority = 3;
                            console.log("Increased priority to HIGH (3) for VIP ticket");
                        } else {
                            console.log(`Keeping existing priority (${ticketData.priority}) as it's already HIGH or URGENT`);
                        }
                    }

                    // Debug log the final ticket data
                    console.log('Final ticket data to be sent:', JSON.stringify(ticketData, null, 2));

                    // NEW: Log the exact JSON string that will be sent to the API
                    const jsonBody = JSON.stringify(ticketData);
                    console.log('Raw JSON body being sent to API:', jsonBody);

                    // For assembly trackers, ensure we have the right tag format
                    if (this.trackerType === 'assembly') {
                        // Make sure we have the right tag 
                        if (!ticketData.tags.includes('tracker-assembly')) {
                            ticketData.tags.push('tracker-assembly');
                        }
                        // Add custom field for assembly tracker if available in the API
                        if (ticketData.custom_fields) {
                            ticketData.custom_fields.cf_assembly_tracker = true;
                        }
                    }

                    // Create a very basic ticket data object with only core fields
                    const basicTicketData = {
                        email: formData.email,
                        subject: subject,
                        description: description,
                        status: parseInt(formData.status || 2),
                        priority: parseInt(formData.priority || 2),
                        source: 101,
                        type: "Incident"
                    };

                    // Add related tickets if available
                    if (relatedTicketIds.length > 0) {
                        basicTicketData.related_ticket_ids = relatedTicketIds;
                    }

                    // Add group ID if available
                    if (formData.groupField) {
                        let groupId = parseInt(formData.groupField);
                        if (!isNaN(groupId)) {
                            basicTicketData.group_id = groupId;
                        }
                    }

                    // Add agent ID if available
                    if (formData.agentField) {
                        let agentId = parseInt(formData.agentField);
                        if (!isNaN(agentId)) {
                            basicTicketData.responder_id = agentId;
                        }
                    }

                    // Add tags
                    basicTicketData.tags = [`tracker-${this.trackerType}`];

                    // VIP tag handling removed as per requirements

                    // Add custom fields if we have them in the source ticket
                    if (sourceTicketData && sourceTicketData.custom_fields) {
                        basicTicketData.custom_fields = {};

                        // Copy specific custom fields from source ticket
                        const customFieldsToPreserve = [
                            'cf_account_manager',
                            'cf_rvp',
                            'cf_categorization',
                            'cf_subcategory',
                            'cf_issue_detail',
                            'cf_product_type',
                            'cf_product',
                            'cf_product_subsection',
                            'cf_vip'
                        ];

                        customFieldsToPreserve.forEach(field => {
                            if (sourceTicketData.custom_fields[field] !== undefined) {
                                basicTicketData.custom_fields[field] = sourceTicketData.custom_fields[field];
                            }
                        });

                        // Add district field if available
                        if (formData.districtField) {
                            basicTicketData.custom_fields.cf_district509811 = String(formData.districtField);
                        }
                        else if (formData.districtName) {
                            basicTicketData.custom_fields.cf_district509811 = String(formData.districtName);
                        }
                    }

                    // Log the basic ticket data
                    console.log('Basic ticket data to send:', JSON.stringify(basicTicketData, null, 2));

                    // Create the ticket with basic data
                    const response = await this.client.request.invokeTemplate("createfdTicket", {
                        body: JSON.stringify(basicTicketData)
                    });

                    console.log('Ticket created successfully, raw response:', response.response);
                    const responseData = JSON.parse(response.response);
                    console.log('Parsed ticket data:', responseData);

                    // Tag source ticket with ESCALATED TO ASSEMBLY if this is an assembly-related tracker
                    console.log("Checking conditions for tagging source ticket:", {
                        trackerType: this.trackerType,
                        isAssembly: this.trackerType === 'assembly',
                        isAssemblyRollover: this.trackerType === 'assembly-rollover',
                        relatedTicketIds: relatedTicketIds,
                        hasRelatedTickets: relatedTicketIds.length > 0
                    });

                    // Force this to run for tracker-type assembly regardless of how trackerType is stored internally
                    const isAssemblyType = this.trackerType === 'assembly' ||
                        this.trackerType === 'assembly-rollover' ||
                        ticketData.tags.includes('tracker-assembly');

                    if (isAssemblyType && relatedTicketIds.length > 0) {
                        // Add tag to source ticket
                        try {
                            const sourceTicketId = relatedTicketIds[0];
                            console.log(`Will attempt to add ESCALATED TO ASSEMBLY tag to source ticket ${sourceTicketId}`);
                            await this.addEscalatedToAssemblyTag(sourceTicketId);
                        } catch (tagError) {
                            console.error("Error tagging source ticket:", tagError);
                            // Continue with success flow even if tagging fails
                        }
                    } else {
                        console.log("Conditions not met for adding ESCALATED TO ASSEMBLY tag to source ticket");
                    }

                    this.handleTicketCreationSuccess(responseData);
                } catch (error) {
                    console.error('Error creating ticket:', error);
                    // Try to extract the specific field causing the error
                    let errorMessage = 'Unknown error';
                    try {
                        if (error.response) {
                            const errorResponse = JSON.parse(error.response);
                            console.error('Detailed API error response:', errorResponse);
                            if (errorResponse.errors && errorResponse.errors.length > 0) {
                                // Log each error in the response
                                errorResponse.errors.forEach((err, index) => {
                                    console.error(`API Error ${index + 1}:`, err);
                                });
                                // Try to extract the invalid field name
                                const invalidFieldError = errorResponse.errors.find(err => err.code === 'invalid_field');
                                if (invalidFieldError && invalidFieldError.field) {
                                    errorMessage = `Invalid field: ${invalidFieldError.field}`;
                                } else if (errorResponse.description) {
                                    errorMessage = errorResponse.description;
                                }
                            }
                        }
                    } catch (parseError) {
                        console.error('Error parsing error response:', parseError);
                    }

                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'none';
                    }
                    this.showError('Failed to create ticket: ' + errorMessage);
                }
            }

            // Add this new method to fix image URLs
            fixImageUrls(html) {
                if (!html) return html;

                try {
                    // Create a temporary div to parse the HTML
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;

                    // Find all image tags
                    const images = tempDiv.querySelectorAll('img');

                    // Fix each image URL
                    images.forEach(img => {
                        const src = img.getAttribute('src');
                        if (src) {
                            // Make sure the URL has a protocol
                            if (!src.startsWith('http://') && !src.startsWith('https://')) {
                                img.setAttribute('src', 'https://' + src);
                            }

                            // Make sure the URL is properly encoded
                            const fixedUrl = encodeURI(decodeURI(src));
                            if (fixedUrl !== src) {
                                img.setAttribute('src', fixedUrl);
                            }
                        }
                    });

                    return tempDiv.innerHTML;
                } catch (error) {
                    console.error('Error fixing image URLs:', error);
                    return html; // Return the original HTML if there's an error
                }
            }

            debugLogRequest(req, title = 'API Request') {
                console.group(title);
                console.log('URL:', req.url);
                console.log('Method:', req.method);
                console.log('Headers:', req.headers);
                console.log('Body:', req.body);
                console.groupEnd();
            }

            // Add this method to your TrackerApp class to upload attachments after ticket creation
            async uploadAttachmentsToTicket(ticketId) {
                const hasScreenshots = this.aggregatedScreenshotFiles && this.aggregatedScreenshotFiles.length > 0;
                // Check for HAR file in all SIM templates
                const hasHarFile = this.trackerType.startsWith('sim-') && this.harFile;

                if (!hasScreenshots && !hasHarFile) {
                    return;
                }

                try {
                    // Process screenshots first
                    if (hasScreenshots) {
                        console.log(`Uploading ${this.aggregatedScreenshotFiles.length} attachments to ticket #${ticketId}...`);

                        // Process one attachment at a time
                        for (const file of this.aggregatedScreenshotFiles) {
                            try {
                                // Convert file to base64
                                const base64Data = await this.readFileAsBase64(file);

                                // Create note with attachment
                                const noteData = {
                                    ticketId: ticketId,
                                    noteBody: `Attachment: ${file.name}`,
                                    isPrivate: false,
                                    fileContent: base64Data,
                                    fileName: file.name,
                                    fileType: file.type
                                };

                                // Use the server component to upload the attachment
                                const response = await this.client.request.invoke('handle_attachments', {
                                    data: noteData
                                });

                                if (response.status >= 200 && response.status < 300) {
                                    console.log(`Successfully uploaded attachment: ${file.name}`);
                                } else {
                                    console.error(`Failed to upload attachment: ${file.name}`, response);
                                }
                            } catch (attachmentError) {
                                console.error(`Error uploading attachment ${file.name}:`, attachmentError);
                                // Continue with other attachments even if one fails
                            }
                        }
                    }

                    // Process HAR file if exists
                    if (hasHarFile) {
                        try {
                            console.log(`Uploading HAR file to ticket #${ticketId}...`);

                            // Convert file to base64
                            const base64Data = await this.readFileAsBase64(this.harFile);

                            // Create note with HAR file
                            const noteData = {
                                ticketId: ticketId,
                                noteBody: `HAR File: ${this.harFile.name}`,
                                isPrivate: false,
                                fileContent: base64Data,
                                fileName: this.harFile.name,
                                fileType: this.harFile.type
                            };

                            // Use the server component to upload the HAR file
                            const response = await this.client.request.invoke('handle_attachments', {
                                data: noteData
                            });

                            if (response.status >= 200 && response.status < 300) {
                                console.log(`Successfully uploaded HAR file: ${this.harFile.name}`);
                            } else {
                                console.error(`Failed to upload HAR file: ${this.harFile.name}`, response);
                            }
                        } catch (harError) {
                            console.error(`Error uploading HAR file ${this.harFile.name}:`, harError);
                        }
                    }
                } catch (error) {
                    console.error('Error uploading attachments:', error);
                    this.showError('Note: Some attachments may not have been uploaded correctly.');
                }
            }

            sanitizeFormData(formData) {
                // Make sure group_id is a number
                if (formData.groupField) {
                    try {
                        // If it's a string like "escalations", replace with appropriate ID
                        if (formData.groupField === "escalations") {
                            formData.groupField = "67000570680"; // Replace with actual Escalations group ID
                        }

                        // Try to convert to number
                        const groupId = parseInt(formData.groupField, 10);
                        if (isNaN(groupId)) {
                            console.warn(`Invalid group ID: ${formData.groupField}, removing`);
                            delete formData.groupField;
                        }
                    } catch (e) {
                        console.warn(`Error processing group ID: ${e.message}`);
                        delete formData.groupField;
                    }
                }

                // Also sanitize agent ID
                if (formData.agentField) {
                    try {
                        const agentId = parseInt(formData.agentField, 10);
                        if (isNaN(agentId)) {
                            console.warn(`Invalid agent ID: ${formData.agentField}, removing`);
                            delete formData.agentField;
                        }
                    } catch (e) {
                        console.warn(`Error processing agent ID: ${e.message}`);
                        delete formData.agentField;
                    }
                }

                return formData;
            }

            // Add this method to handle HAR file uploads
            handleHarFileUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                const previewContainer = document.getElementById('harFilePreview');
                if (!previewContainer) {
                    console.error('HAR file preview container not found');
                    return;
                }

                // Clear previous preview
                previewContainer.innerHTML = '';

                // Create preview element
                const thumbnail = document.createElement('div');
                thumbnail.className = 'screenshot-thumbnail';

                // Create thumbnail content
                thumbnail.innerHTML = `
                    <div class="file-preview">
                        <i class="fas fa-file-code"></i>
                    </div>
                    <div class="screenshot-filename">${file.name}</div>
                    <div class="har-remove" data-filename="${file.name}">×</div>
                `;

                previewContainer.appendChild(thumbnail);

                // Store file for later use
                this.harFile = file;

                // Add event listener to remove button
                document.querySelector('#harFilePreview .har-remove').addEventListener('click', () => {
                    previewContainer.innerHTML = '';
                    this.harFile = null;

                    // Reset file input
                    document.getElementById('harFile').value = '';
                });
            }

            // Add this method to your TrackerApp class
            setupConditionalFields() {
                // Look for fields with conditions and set up their display logic
                this.config.sections.forEach(section => {
                    section.fields.forEach(field => {
                        if (field.condition) {
                            const targetField = document.getElementById(field.id);

                            if (!targetField) {
                                console.warn(`Conditional field ${field.id} not found in DOM`);
                                return;
                            }

                            // Find the container for the entire field group
                            const fieldContainer = this.findParentWithClass(targetField, 'form-group');
                            if (!fieldContainer) {
                                console.warn(`Could not find form-group container for ${field.id}`);
                                return;
                            }

                            // Find the controlling field and set up a change listener
                            const controlField = document.getElementById(field.condition.field);
                            if (!controlField) {
                                console.warn(`Control field ${field.condition.field} not found for conditional field ${field.id}`);
                                return;
                            }

                            // Initial setup - hide/show based on current value
                            this.updateConditionalField(controlField, fieldContainer, field.condition.value);

                            // Add event listener to control field
                            controlField.addEventListener('change', () => {
                                this.updateConditionalField(controlField, fieldContainer, field.condition.value);
                            });
                        }
                    });
                });
            }

            // Helper method to find parent element with a specific class
            findParentWithClass(element, className) {
                while (element && !element.classList.contains(className)) {
                    element = element.parentElement;
                }
                return element;
            }

            // Helper method to update the display of a conditional field
            updateConditionalField(controlField, targetContainer, conditionValue) {
                if (controlField.value === conditionValue) {
                    targetContainer.style.display = '';
                } else {
                    targetContainer.style.display = 'none';
                }
            }

            // Add this method to your TrackerApp class
            setupCustomFileUploaders() {
                try {
                    console.log('Setting up custom file uploaders');

                    // Track if we've found a screenshots section
                    let hasScreenshotsSection = false;

                    // Look for sections with id 'screenshots'
                    document.querySelectorAll('.card').forEach(section => {
                        if (section.id === 'section-screenshots') {
                            hasScreenshotsSection = true;
                            console.log('Found screenshots section, adding file uploader');

                            const sectionBody = section.querySelector('.card-body');
                            if (!sectionBody) {
                                console.warn('Section body not found in screenshots section');
                                return;
                            }

                            // Check if there's already a Quill editor
                            let hasEditor = sectionBody.querySelector('.quill-editor-container');

                            // If no editor, add one first
                            if (!hasEditor) {
                                console.log('Adding Quill editor to screenshots section');
                                const quillContainer = document.createElement('div');
                                quillContainer.className = 'quill-editor-container';
                                quillContainer.innerHTML = `
                                    <div id="screenshotsDescriptionEditor" style="min-height: 120px;"></div>
                                    <textarea id="screenshotsDescription" name="screenshotsDescription" style="display: none;"></textarea>
                                    <div class="hint"><i class="fas fa-info-circle"></i> Add description for your screenshots and videos</div>
                                `;
                                sectionBody.appendChild(quillContainer);

                                // Initialize the Quill editor
                                this.initializeQuillEditor('screenshotsDescription', 'screenshotsDescriptionEditor');
                            }

                            // Check if uploader already exists
                            const existingUploader = sectionBody.querySelector('.attachment-input-container');
                            if (existingUploader) {
                                console.log('File uploader already exists, skipping');
                                return;
                            }

                            // Add file uploader
                            console.log('Adding file uploader to screenshots section');
                            const uploaderContainer = document.createElement('div');
                            uploaderContainer.className = 'attachment-input-container';
                            uploaderContainer.style.marginTop = '15px';
                            uploaderContainer.innerHTML = `
                                <label for="screenshots" class="file-upload-button">
                                    <i class="fas fa-cloud-upload-alt"></i> Upload Files
                                    <input type="file" id="screenshots" name="screenshots" multiple class="hidden-file-input">
                                </label>
                                <div class="file-size-warning" style="margin-top: 10px; background-color: #f4c42f4d; color: #d3932ffc;">
                                    <strong>⚠️ IMPORTANT:</strong> Maximum total attachment size is 20MB. Files exceeding this limit will NOT be attached to the ticket.
                                </div>
                                <div id="screenshotPreview" class="screenshot-preview"></div>
                                <div id="attachmentCounter" class="attachment-counter"></div>
                            `;
                            sectionBody.appendChild(uploaderContainer);

                            // Add event listener to the file input
                            const fileInput = sectionBody.querySelector('#screenshots');
                            if (fileInput) {
                                fileInput.addEventListener('change', (e) => {
                                    this.handleFileInputChange(e);
                                });
                            }
                        }
                    });

                    // If we didn't find a screenshots section, add one
                    if (!hasScreenshotsSection) {
                        console.log('Adding screenshots section as it was not found in the template');
                        const dynamicSections = document.getElementById('dynamicSections');
                        if (dynamicSections) {
                            // Create new screenshots section
                            const newScreenshotsSection = document.createElement('div');
                            newScreenshotsSection.className = 'card';
                            newScreenshotsSection.id = 'section-screenshots';

                            // Create header
                            newScreenshotsSection.innerHTML = `
                                <div class="card-header">
                                    <i class="fas fa-images fa-lg section-icon"></i>
                                    <h3>SCREENSHOTS, VIDEOS, & OTHER SUPPORTING FILE ATTACHMENTS</h3>
                                </div>
                                <div class="card-body">
                                </div>
                            `;

                            // Add to DOM
                            dynamicSections.appendChild(newScreenshotsSection);

                            // Now add content to the body
                            const sectionBody = newScreenshotsSection.querySelector('.card-body');

                            // Add a Quill editor first
                            const quillContainer = document.createElement('div');
                            quillContainer.className = 'quill-editor-container';
                            quillContainer.innerHTML = `
                                <div id="screenshotsDescriptionEditor" style="min-height: 120px;"></div>
                                <textarea id="screenshotsDescription" name="screenshotsDescription" style="display: none;"></textarea>
                            `;
                            sectionBody.appendChild(quillContainer);

                            // Initialize Quill editor
                            this.initializeQuillEditor('screenshotsDescription', 'screenshotsDescriptionEditor');

                            // Then add file uploader
                            const uploaderContainer = document.createElement('div');
                            uploaderContainer.className = 'attachment-input-container';
                            uploaderContainer.style.marginTop = '15px';
                            uploaderContainer.innerHTML = `
                                <label for="screenshots" class="file-upload-button">
                                    <i class="fas fa-cloud-upload-alt"></i> Upload Files
                                    <input type="file" id="screenshots" name="screenshots" multiple class="hidden-file-input">
                                </label>
                                <div class="file-size-warning" style="margin-top: 10px; background-color: #f4c42f4d; color: #d3932ffc;">
                                    <strong>⚠️ IMPORTANT:</strong> Maximum total attachment size is 20MB. Files exceeding this limit will NOT be attached to the ticket.
                                </div>
                                <div id="screenshotPreview" class="screenshot-preview"></div>
                                <div id="attachmentCounter" class="attachment-counter"></div>
                            `;
                            sectionBody.appendChild(uploaderContainer);

                            // Add event listener to the file input
                            const fileInput = sectionBody.querySelector('#screenshots');
                            if (fileInput) {
                                fileInput.addEventListener('change', (e) => {
                                    this.handleFileInputChange(e);
                                });
                            }
                        }
                    }

                    // Setup HAR file uploader
                    this.setupHarFileUploader();

                } catch (error) {
                    console.error('Error setting up custom file uploaders:', error);
                }
            }

            // Add this helper method to initialize Quill editors
            initializeQuillEditor(id, editorId) {
                try {
                    const editor = new Quill(`#${editorId}`, {
                        theme: 'snow',
                        placeholder: 'Add screenshots, videos or other supporting files to help illustrate the issue',
                        modules: {
                            toolbar: {
                                container: [
                                    ['bold', 'italic'],
                                    [{ 'color': [] }, { 'background': [] }],
                                    [{ 'align': [] }],
                                    ['link', 'image', 'clean'] // Added 'clean' format button
                                ]
                            }
                        }
                    });

                    // Store reference to the editor
                    this.quillEditors[id] = editor;

                    // Add paste and drop handlers
                    editor.root.addEventListener('paste', e => this.handlePasteImage(e, editor));
                    editor.root.addEventListener('drop', e => this.handleDropImage(e, editor));

                    console.log(`Initialized Quill editor for ${id}`);
                } catch (error) {
                    console.error(`Error initializing Quill editor for ${id}:`, error);
                }
            }

            // Add a method to set up the HAR file uploader
            setupHarFileUploader() {
                console.log('Setting up HAR file uploader for template type:', this.trackerType);

                // Apply to all SIM templates that need HAR file uploader
                if (!(this.trackerType.startsWith('sim-') || this.trackerType === 'help-article')) {
                    console.log('Template type not eligible for HAR file uploader');
                    return;
                }

                // Find the HAR file attached dropdown
                const harFileAttached = document.getElementById('harFileAttached');
                if (!harFileAttached) {
                    console.warn('HAR file attached dropdown not found');
                    return;
                }

                console.log('Found HAR file attached dropdown with value:', harFileAttached.value);

                // Find the harFileReason field and its container
                const harFileReason = document.getElementById('harFileReason');
                const harFileReasonContainer = harFileReason ? this.findParentWithClass(harFileReason, 'form-group') : null;

                if (harFileReasonContainer) {
                    console.log('Found HAR file reason container');

                    // Check if we already created a HAR uploader container
                    let uploaderContainer = document.getElementById('harUploaderContainer');
                    if (uploaderContainer) {
                        console.log('HAR uploader container already exists, updating visibility');
                    } else {
                        console.log('Creating new HAR uploader container');

                        // Create and add the HAR file uploader container
                        const harUploaderHTML = `
                            <div class="form-group" id="harUploaderContainer" style="display: none; margin-top: 15px; background-color: var(--card-bg, #f8f9fa); border-radius: 5px; padding: 15px; border: 1px solid var(--card-border, #dee2e6); box-shadow: 0 1px 3px var(--shadow-color, rgba(0,0,0,0.1));">
                                <label for="harFileInput" style="font-weight: bold; color: var(--heading-color, #2C3E50); margin-bottom: 10px; display: block;">Upload HAR File</label>
                                <div class="attachment-input-container" style="display: flex; flex-direction: column; gap: 10px;">
                                    <div style="display: flex; align-items: center;">
                                        <label for="harFileInput" class="file-upload-button">
                                            <i class="fas fa-cloud-upload-alt"></i> Choose HAR File
                                            <input type="file" id="harFileInput" name="harFileInput" accept=".har" class="hidden-file-input">
                                        </label>
                                        <div class="hint" style="margin-left: 15px;"><i class="fas fa-info-circle"></i> HAR files contain detailed network information for troubleshooting</div>
                                    </div>
                                    <div class="file-size-warning" style="background-color: var(--hover-bg, #f8f9fa); padding: 8px 12px; border-radius: 4px; color: var(--text-color, #664d03); border-left: 3px solid #ffc107; font-size: 12px;">
                                        <strong><i class="fas fa-exclamation-triangle" style="margin-right: 5px;"></i> IMPORTANT:</strong> Maximum file size is 20MB. The HAR file will be analyzed and a detailed report will be included with your ticket.
                                    </div>
                                    <div id="harFilePreviewContainer" class="screenshot-preview" style="margin-top: 10px;"></div>
                                </div>
                            </div>
                        `;

                        // Insert the HAR uploader before the reason field container
                        harFileReasonContainer.insertAdjacentHTML('beforebegin', harUploaderHTML);
                        uploaderContainer = document.getElementById('harUploaderContainer');
                    }

                    // Make sure initial state is correct
                    if (harFileAttached.value === 'Yes') {
                        if (uploaderContainer) {
                            uploaderContainer.style.display = 'block';
                            console.log('Showing HAR uploader container');
                        }
                        harFileReasonContainer.style.display = 'none';
                        console.log('Hiding HAR file reason container');
                    } else {
                        if (uploaderContainer) {
                            uploaderContainer.style.display = 'none';
                            console.log('Hiding HAR uploader container');
                        }
                        harFileReasonContainer.style.display = 'block';
                        console.log('Showing HAR file reason container');
                    }

                    // Add event listener to the HAR file input
                    const harFileInput = document.getElementById('harFileInput');
                    if (harFileInput) {
                        // Remove existing event listeners to avoid duplicates
                        const newHarFileInput = harFileInput.cloneNode(true);
                        harFileInput.parentNode.replaceChild(newHarFileInput, harFileInput);

                        newHarFileInput.addEventListener('change', (e) => {
                            console.log('HAR file input changed');
                            this.handleHarFileInputChange(e);
                        });
                    }

                    // Remove existing event listeners to avoid duplicates
                    const newHarFileAttached = harFileAttached.cloneNode(true);
                    harFileAttached.parentNode.replaceChild(newHarFileAttached, harFileAttached);

                    // Add change listener to harFileAttached dropdown
                    newHarFileAttached.addEventListener('change', function () {
                        console.log('HAR file attached dropdown changed to:', this.value);
                        const uploaderContainer = document.getElementById('harUploaderContainer');
                        const reasonContainer = document.getElementById('harFileReason') ?
                            window.trackerApp.findParentWithClass(document.getElementById('harFileReason'), 'form-group') : null;

                        if (this.value === 'Yes') {
                            if (uploaderContainer) {
                                uploaderContainer.style.display = 'block';
                                console.log('Showing HAR uploader container after dropdown change');
                            }
                            if (reasonContainer) {
                                reasonContainer.style.display = 'none';
                                // Remove the required indication
                                const label = reasonContainer.querySelector('label');
                                if (label) label.classList.remove('required-field');
                                console.log('Hiding HAR file reason container after dropdown change');
                            }
                        } else {
                            if (uploaderContainer) {
                                uploaderContainer.style.display = 'none';
                                console.log('Hiding HAR uploader container after dropdown change');
                            }
                            if (reasonContainer) {
                                reasonContainer.style.display = 'block';
                                // Add visual indication that the field is now required
                                const label = reasonContainer.querySelector('label');
                                if (label) label.classList.add('required-field');
                                console.log('Showing HAR file reason container after dropdown change');
                            }
                        }
                    });

                    // Trigger the change event to ensure correct initial state
                    const event = new Event('change');
                    newHarFileAttached.dispatchEvent(event);
                } else {
                    console.warn('Could not find HAR file reason container');
                }
            }

            // Add a new method specifically for handling HAR file inputs
            handleHarFileInputChange(e) {
                const file = e.target.files[0];
                if (!file) return;

                // Use the unique preview container ID
                const previewContainer = document.getElementById('harFilePreviewContainer');
                if (!previewContainer) {
                    console.error('HAR file preview container not found');
                    return;
                }

                // Clear previous preview
                previewContainer.innerHTML = '';

                // Read the file contents to validate and extract information
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        let isValidHar = true;
                        let analysisHtml = '';
                        let harAnalysis = {};

                        // Try to parse the HAR file as JSON
                        try {
                            const harContent = JSON.parse(event.target.result);

                            // Basic validation - check if it has expected HAR structure
                            if (!harContent.log || !Array.isArray(harContent.log.entries)) {
                                isValidHar = false;
                                analysisHtml = `<div class="har-warning">⚠️ This file doesn't appear to be a valid HAR file. It's missing the expected structure.</div>`;
                            } else {
                                // It's a valid HAR file - analyze it
                                harAnalysis = this.analyzeHarFile(harContent);

                                // Check if it's empty (no entries)
                                if (harContent.log.entries.length === 0) {
                                    isValidHar = false;
                                    analysisHtml = `<div class="har-warning">⚠️ This HAR file contains no network requests. It may not be useful for troubleshooting.</div>`;
                                } else {
                                    // Create summary information
                                    analysisHtml = `
                                        <div class="har-analysis">
                                            <div class="har-summary"><strong>HAR File Summary:</strong> ${harContent.log.entries.length} requests, ${harAnalysis.errorCount} errors</div>
                                            ${harAnalysis.errorCount > 0 ? `<div class="har-errors"><strong>Error requests:</strong> ${harAnalysis.errorCount}</div>` : ''}
                                            ${harAnalysis.browserErrors && harAnalysis.browserErrors.count > 0 ? `<div class="har-errors"><strong>Browser-level errors:</strong> ${harAnalysis.browserErrors.count}</div>` : ''}
                                            ${harAnalysis.redirectCount > 0 ? `<div class="har-redirects"><strong>Redirects:</strong> ${harAnalysis.redirectCount}</div>` : ''}
                                            ${harAnalysis.slowRequests.length > 0 ? `<div class="har-slow"><strong>Slow requests:</strong> ${harAnalysis.slowRequests.length}</div>` : ''}
                                            <div class="har-browser"><strong>Browser:</strong> ${harAnalysis.browser}</div>
                                        </div>
                                    `;
                                }
                            }
                        } catch (error) {
                            isValidHar = false;
                            console.error('Error parsing HAR file:', error);
                            analysisHtml = `<div class="har-warning">⚠️ This file doesn't appear to be a valid HAR file. JSON parsing error: ${error.message}</div>`;
                        }

                        // Store the analysis for later use
                        this.harFileAnalysis = harAnalysis;

                        // Create preview element with the analysis
                        const thumbnail = document.createElement('div');
                        thumbnail.className = 'screenshot-thumbnail har-preview-container' + (!isValidHar ? ' invalid-har' : '');
                        thumbnail.style.width = '100%';
                        thumbnail.style.maxWidth = '100%';
                        thumbnail.style.backgroundColor = '#f8f9fa';
                        thumbnail.style.borderRadius = '5px';
                        thumbnail.style.padding = '15px';
                        thumbnail.style.border = '1px solid #dee2e6';
                        thumbnail.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';

                        // Create thumbnail content with enhanced styling
                        if (isValidHar) {
                            thumbnail.innerHTML = `
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <div style="display: flex; align-items: center; max-width: 85%;">
                                        <div class="file-preview" style="margin-right: 10px; background-color: #e9ecef; padding: 10px; border-radius: 5px; display: flex; justify-content: center; align-items: center; width: 40px; height: 40px;">
                                            <i class="fas fa-file-code" style="font-size: 20px; color: #2C3E50;"></i>
                                        </div>
                                        <div style="overflow: hidden;">
                                            <div class="screenshot-filename" style="font-weight: bold; font-size: 16px; overflow: hidden; text-overflow: ellipsis; white-space: initial; word-break: break-word;">${file.name}</div>
                                            <div style="font-size: 12px; color: #666; text-align: center;">${harAnalysis.date || 'Unknown date'} · ${this.formatFileSize(file.size)}</div>
                                        </div>
                                    </div>
                                    <div class="har-remove" data-filename="${file.name}" style="cursor: pointer; font-size: 20px; color: #dc3545; width: 30px; height: 30px; display: flex; justify-content: center; align-items: center; border-radius: 50%; background-color: #f8d7da; margin-left: 10px;">×</div>
                                </div>

                                <div style="background-color: white; border-radius: 4px; padding: 15px; border: 1px solid #eee; margin-bottom: 15px;">
                                    <h4 style="margin-top: 0; margin-bottom: 10px; color: #2C3E50; font-size: 16px; border-bottom: 1px solid #eee; padding-bottom: 5px;">HAR File Overview</h4>
                                    
                                    <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px;">
                                        <div style="flex: 1; background-color: #f8f9fa; border-radius: 4px; padding: 10px; min-width: 80px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05);">
                                            <div style="font-size: 18px; font-weight: bold;">${harAnalysis.totalRequests}</div>
                                            <div style="font-size: 11px; color: #666;">Total Requests</div>
                                        </div>
                                        
                                        <div style="flex: 1; background-color: #f8f9fa; border-radius: 4px; padding: 10px; min-width: 80px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05);">
                                            <div style="font-size: 18px; font-weight: bold; color: ${harAnalysis.errorCount > 0 ? '#dc3545' : '#333'};">${harAnalysis.errorCount}</div>
                                            <div style="font-size: 11px; color: #666;">Errors</div>
                                        </div>
                                        
                                        <div style="flex: 1; background-color: #f8f9fa; border-radius: 4px; padding: 10px; min-width: 80px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05);">
                                            <div style="font-size: 18px; font-weight: bold; color: ${harAnalysis.redirectCount > 0 ? '#007bff' : '#333'};">${harAnalysis.redirectCount}</div>
                                            <div style="font-size: 11px; color: #666;">Redirects</div>
                                        </div>
                                        
                                        <div style="flex: 1; background-color: #f8f9fa; border-radius: 4px; padding: 10px; min-width: 80px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05);">
                                            <div style="font-size: 18px; font-weight: bold; color: ${harAnalysis.slowRequests && harAnalysis.slowRequests.length > 0 ? '#fd7e14' : '#333'};">${harAnalysis.slowRequests ? harAnalysis.slowRequests.length : 0}</div>
                                            <div style="font-size: 11px; color: #666;">Slow Requests</div>
                                        </div>
                                        
                                        ${harAnalysis.whitelistIssues && harAnalysis.whitelistIssues.count > 0 ? `
                                        <div style="flex: 1; background-color: #f8f9fa; border-radius: 4px; padding: 10px; min-width: 80px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05);">
                                            <div style="font-size: 18px; font-weight: bold; color: #dc3545;">${harAnalysis.whitelistIssues.count}</div>
                                            <div style="font-size: 11px; color: #666;">Possible Whitelist Issues</div>
                                        </div>
                                        ` : ''}
                                        
                                        ${harAnalysis.browserErrors && harAnalysis.browserErrors.count > 0 ? `
                                        <div style="flex: 1; background-color: #f8f9fa; border-radius: 4px; padding: 10px; min-width: 80px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05);">
                                            <div style="font-size: 18px; font-weight: bold; color: #dc3545;">${harAnalysis.browserErrors.count}</div>
                                            <div style="font-size: 11px; color: #666;">Browser Errors</div>
                                        </div>
                                        ` : ''}
                                    </div>
                                    
                                    <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                                        <div style="flex: 1; min-width: 120px;">
                                            <div style="font-size: 12px;"><strong>Browser:</strong> ${harAnalysis.browser}</div>
                                            <div style="font-size: 12px;"><strong>Avg Response:</strong> ${Math.round(harAnalysis.avgResponseTime)}ms</div>
                                        </div>
                                        <div style="flex: 1; min-width: 120px;">
                                            <div style="font-size: 12px;"><strong>Total Size:</strong> ${this.formatFileSize(harAnalysis.totalSize)}</div>
                                            <div style="font-size: 12px;"><strong>Total Time:</strong> ${Math.round(harAnalysis.totalRequestTime)}ms</div>
                                        </div>
                                    </div>
                                </div>

                                <div style="font-size: 12px; color: #666; text-align: center;">
                                    <i class="fas fa-info-circle"></i> A detailed HAR analysis report will be included with the ticket
                                </div>
                            `;
                        } else {
                            // Error state
                            thumbnail.innerHTML = `
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <div style="display: flex; align-items: center; max-width: 85%;">
                                        <div class="file-preview" style="margin-right: 10px; background-color: #e9ecef; padding: 10px; border-radius: 5px; display: flex; justify-content: center; align-items: center; width: 40px; height: 40px;">
                                            <i class="fas fa-file-code" style="font-size: 20px; color: #2C3E50;"></i>
                                        </div>
                                        <div style="overflow: hidden;">
                                            <div class="screenshot-filename" style="font-weight: bold; font-size: 16px; overflow: hidden; text-overflow: ellipsis; white-space: initial; word-break: break-word;">${file.name}</div>
                                            <div style="font-size: 12px; color: #666; text-align: center;">${this.formatFileSize(file.size)}</div>
                                        </div>
                                    </div>
                                    <div class="har-remove" data-filename="${file.name}" style="cursor: pointer; font-size: 20px; color: #dc3545; width: 30px; height: 30px; display: flex; justify-content: center; align-items: center; border-radius: 50%; background-color: #f8d7da; margin-left: 10px;">×</div>
                                </div>
                                ${analysisHtml}
                            `;
                        }

                        previewContainer.appendChild(thumbnail);

                        // Add CSS for HAR analysis
                        if (!document.getElementById('har-analysis-styles')) {
                            const style = document.createElement('style');
                            style.id = 'har-analysis-styles';
                            style.textContent = `
                                .har-preview-container {
                                    margin-bottom: 15px;
                                }
                                .har-analysis {
                                    margin-top: 10px;
                                    padding: 8px;
                                    background-color: #f8f9fa;
                                    border-radius: 4px;
                                    font-size: 12px;
                                }
                                .har-warning {
                                    margin-top: 10px;
                                    padding: 15px;
                                    background-color: #fff3cd;
                                    border: 1px solid #ffeeba;
                                    color: #856404;
                                    border-radius: 4px;
                                    font-size: 13px;
                                }
                                .har-errors {
                                    color: #dc3545;
                                }
                                .har-redirects {
                                    color: #007bff;
                                }
                                .har-slow {
                                    color: #fd7e14;
                                }
                                .invalid-har {
                                    border-color: #ffc107 !important;
                                }
                            `;
                            document.head.appendChild(style);
                        }

                        // Store file for later use
                        this.harFile = file;

                        // Add event listener to remove button
                        document.querySelector('#harFilePreviewContainer .har-remove').addEventListener('click', () => {
                            previewContainer.innerHTML = '';
                            this.harFile = null;
                            this.harFileAnalysis = null;

                            // Reset file input
                            document.getElementById('harFileInput').value = '';
                        });

                    } catch (e) {
                        console.error('Error processing HAR file:', e);
                        // Show error but still allow upload
                        const thumbnail = document.createElement('div');
                        thumbnail.className = 'screenshot-thumbnail invalid-har';
                        thumbnail.innerHTML = `
                            <div class="file-preview">
                                <i class="fas fa-file-code"></i>
                            </div>
                            <div class="screenshot-filename">${file.name}</div>
                            <div class="har-remove" data-filename="${file.name}">×</div>
                            <div class="har-warning">⚠️ Error processing HAR file. The file may still be attached.</div>
                        `;
                        previewContainer.appendChild(thumbnail);

                        // Store file for later use anyway
                        this.harFile = file;

                        // Add event listener to remove button
                        document.querySelector('#harFilePreviewContainer .har-remove').addEventListener('click', () => {
                            previewContainer.innerHTML = '';
                            this.harFile = null;
                            this.harFileAnalysis = null;

                            // Reset file input
                            document.getElementById('harFileInput').value = '';
                        });
                    }
                };

                reader.onerror = (error) => {
                    console.error('Error reading HAR file:', error);
                    // Show an error but still allow upload
                    const thumbnail = document.createElement('div');
                    thumbnail.className = 'screenshot-thumbnail invalid-har';
                    thumbnail.innerHTML = `
                        <div class="file-preview">
                            <i class="fas fa-file-code"></i>
                        </div>
                        <div class="screenshot-filename">${file.name}</div>
                        <div class="har-remove" data-filename="${file.name}">×</div>
                        <div class="har-warning">⚠️ Error reading HAR file: ${error.message || 'Unknown error'}. The file may still be attached.</div>
                    `;
                    previewContainer.appendChild(thumbnail);

                    // Store file for later use anyway
                    this.harFile = file;

                    // Add event listener to remove button
                    document.querySelector('#harFilePreviewContainer .har-remove').addEventListener('click', () => {
                        previewContainer.innerHTML = '';
                        this.harFile = null;
                        this.harFileAnalysis = null;

                        // Reset file input
                        document.getElementById('harFileInput').value = '';
                    });
                };

                // Read the file as text
                reader.readAsText(file);
            }

            // New method to analyze HAR files and extract useful information
            analyzeHarFile(harContent) {
                try {
                    const analysis = {
                        errorCount: 0,
                        errorUrls: [],
                        slowRequests: [],
                        totalRequests: 0,
                        browser: 'Unknown',
                        serverIssues: [],
                        clientIssues: [],
                        redirectCount: 0,
                        redirectUrls: [],
                        // Add new metrics
                        fileName: '',
                        date: '',
                        avgResponseTime: 0,
                        maxResponseTime: { time: 0, url: '' },
                        totalRequestTime: 0,
                        totalSize: 0,
                        statusCodes: {
                            success: { count: 0, items: [] },  // 2xx
                            redirect: { count: 0, items: [] }, // 3xx
                            clientError: { count: 0, items: [] }, // 4xx
                            serverError: { count: 0, items: [] }  // 5xx
                        },
                        contentTypes: {},
                        largeResponses: [],
                        // Add new field for browser level errors
                        browserErrors: { count: 0, items: [] },
                        // Add new field for whitelist issues
                        whitelistIssues: { count: 0, items: [] }
                    };

                    // Define the whitelist patterns
                    const whitelistPatterns = [
                        // Benchmark Universe
                        '*.benchmarkuniverse.com',
                        // Benchmark Education Assessment
                        'bec-assessment-resources.s3.us-west-2.amazonaws.com',
                        // Benchmark Education CDN
                        'd1u7vijijbxikz.cloudfront.net',
                        'bec-rsrc-private-prod.s3.amazonaws.com',
                        // Benchmark Universe Video Hosting
                        'benchmark.wistia.com',
                        'embedwistia-a.akamaihd.net',
                        'distillery.wistia.com',
                        'pipedream.wistia.com',
                        '*.litix.io',
                        // Google Fonts
                        'fonts.googleapis.com',
                        'fonts.gstatic.com',
                        // Additional URLs
                        'bubba-production.benchmarkuniverse.com',
                        'appserver-production.benchmarkuniverse.com',
                        'resources.benchmarkuniverse.com',
                        'supervisor-production.benchmarkuniverse.com',
                        'maple-production.benchmarkuniverse.com',
                        's3.amazonaws.com',
                        's3.amazonaws.com/bec-rsrc-private-prod/*',
                        's3.amazonaws.com/bec-rsrc-public-prod/*'
                    ];

                    // Helper function to check if a URL matches a whitelist pattern
                    const isWhitelisted = (url) => {
                        try {
                            if (!url) return false;

                            const urlObj = new URL(url);
                            const hostname = urlObj.hostname;
                            const fullPath = urlObj.hostname + urlObj.pathname;

                            return whitelistPatterns.some(pattern => {
                                // Handle wildcards at start of domain (*.example.com)
                                if (pattern.startsWith('*.')) {
                                    const domain = pattern.substring(2);
                                    return hostname.endsWith(domain);
                                }
                                // Handle path wildcards (example.com/path/*)
                                else if (pattern.endsWith('/*')) {
                                    const prefix = pattern.substring(0, pattern.length - 1);
                                    return fullPath.startsWith(prefix);
                                }
                                // Exact match
                                else {
                                    return hostname === pattern || fullPath.includes(pattern);
                                }
                            });
                        } catch (e) {
                            console.error('Error checking whitelist for URL:', url, e);
                            return false;
                        }
                    };

                    // Extract file name and date if available
                    if (harContent.log && harContent.log.pages && harContent.log.pages.length > 0) {
                        analysis.date = new Date(harContent.log.pages[0].startedDateTime).toLocaleString();
                    } else if (harContent.log && harContent.log.entries && harContent.log.entries.length > 0) {
                        analysis.date = new Date(harContent.log.entries[0].startedDateTime).toLocaleString();
                    }

                    // Extract browser information
                    if (harContent.log && harContent.log.browser) {
                        analysis.browser = `${harContent.log.browser.name || 'Unknown'} ${harContent.log.browser.version || ''}`;
                    }

                    // No entries check
                    if (!harContent.log || !harContent.log.entries) {
                        return analysis;
                    }

                    analysis.totalRequests = harContent.log.entries.length;

                    // Track total response times for average calculation
                    let totalResponseTime = 0;

                    // Analyze each request
                    harContent.log.entries.forEach(entry => {
                        try {
                            const response = entry.response;
                            const request = entry.request;

                            // Skip if no request
                            if (!request) return;

                            // Check for browser-level errors (like net::ERR_FAILED)
                            if (response && response._error) {
                                analysis.errorCount++;
                                analysis.browserErrors.count++;

                                // Check if this is a whitelisted URL with an error
                                if (isWhitelisted(request.url)) {
                                    analysis.whitelistIssues.count++;
                                    if (analysis.whitelistIssues.items.length < 20) {
                                        try {
                                            const urlObj = new URL(request.url);
                                            analysis.whitelistIssues.items.push({
                                                url: urlObj.hostname + urlObj.pathname,
                                                method: request.method,
                                                error: response._error || 'Browser Error',
                                                status: 0
                                            });
                                        } catch (e) {
                                            analysis.whitelistIssues.items.push({
                                                url: request.url,
                                                method: request.method,
                                                error: response._error || 'Browser Error',
                                                status: 0
                                            });
                                        }
                                    }
                                }

                                // Add to browser errors list (up to 5)
                                if (analysis.browserErrors.items.length < 5) {
                                    try {
                                        const urlObj = new URL(request.url);
                                        analysis.browserErrors.items.push({
                                            url: urlObj.pathname + urlObj.search,
                                            error: response._error,
                                            method: request.method
                                        });
                                    } catch (e) {
                                        analysis.browserErrors.items.push({
                                            url: request.url,
                                            error: response._error,
                                            method: request.method
                                        });
                                    }
                                }

                                // Also add to errorUrls for compatibility with existing code
                                if (analysis.errorUrls.length < 5) {
                                    try {
                                        const urlParts = new URL(request.url);
                                        const shortUrl = urlParts.pathname;
                                        analysis.errorUrls.push(`${request.method} ${shortUrl} (${response._error})`);
                                    } catch (e) {
                                        analysis.errorUrls.push(`${request.method} ${request.url} (${response._error})`);
                                    }
                                }

                                // Skip further processing for this entry if there's no valid response
                                if (!response.status) return;
                            }

                            // Skip if no response
                            if (!response) return;

                            // Calculate response time and update metrics
                            if (entry.time) {
                                totalResponseTime += entry.time;
                                analysis.totalRequestTime += entry.time;

                                // Track max response time
                                if (entry.time > analysis.maxResponseTime.time) {
                                    analysis.maxResponseTime = {
                                        time: entry.time,
                                        url: request.url
                                    };
                                }
                            }

                            // Calculate response size
                            const contentSize = response.content && response.content.size ? response.content.size : 0;
                            analysis.totalSize += contentSize;

                            // Track large responses (> 1MB)
                            if (contentSize > 1024 * 1024) {
                                try {
                                    const urlObj = new URL(request.url);
                                    analysis.largeResponses.push({
                                        url: urlObj.pathname + urlObj.search,
                                        size: contentSize,
                                        method: request.method
                                    });
                                } catch (e) {
                                    analysis.largeResponses.push({
                                        url: request.url,
                                        size: contentSize,
                                        method: request.method
                                    });
                                }
                            }

                            // Track content types
                            if (response.content && response.content.mimeType) {
                                const mimeType = response.content.mimeType.split(';')[0];
                                let simplifiedType = mimeType;

                                // Simplify mime types for better grouping
                                if (mimeType.includes('javascript')) {
                                    simplifiedType = 'text/javascript';
                                } else if (mimeType.includes('json')) {
                                    simplifiedType = 'application/json';
                                } else if (mimeType.includes('html')) {
                                    simplifiedType = 'text/html';
                                } else if (mimeType.includes('css')) {
                                    simplifiedType = 'text/css';
                                } else if (mimeType.includes('image/')) {
                                    simplifiedType = 'image/png';
                                }

                                if (!analysis.contentTypes[simplifiedType]) {
                                    analysis.contentTypes[simplifiedType] = 0;
                                }
                                analysis.contentTypes[simplifiedType]++;
                            }

                            // Track status codes
                            const status = response.status;
                            if (status >= 200 && status < 300) {
                                // Success (2xx)
                                analysis.statusCodes.success.count++;
                                analysis.statusCodes.success.items.push({
                                    url: request.url,
                                    status: status,
                                    method: request.method
                                });
                            } else if (status >= 300 && status < 400) {
                                // Redirect (3xx)
                                analysis.redirectCount++;
                                analysis.statusCodes.redirect.count++;

                                // Add to redirect details
                                if (analysis.redirectUrls.length < 5) {
                                    try {
                                        const urlParts = new URL(request.url);
                                        const shortUrl = urlParts.pathname;
                                        const redirectTarget = response.redirectURL || 'Unknown destination';
                                        analysis.redirectUrls.push({
                                            url: shortUrl,
                                            status: status,
                                            method: request.method,
                                            target: redirectTarget
                                        });
                                    } catch (e) {
                                        // Fallback if URL parsing fails
                                        analysis.redirectUrls.push({
                                            url: request.url,
                                            status: status,
                                            method: request.method,
                                            target: response.redirectURL || 'Unknown destination'
                                        });
                                    }
                                }

                                analysis.statusCodes.redirect.items.push({
                                    url: request.url,
                                    status: status,
                                    method: request.method,
                                    to: response.redirectURL
                                });
                            } else if (status >= 400 && status < 500) {
                                // Client Error (4xx)
                                analysis.errorCount++;
                                analysis.statusCodes.clientError.count++;

                                // Check if this is a whitelisted URL with a client error
                                if (isWhitelisted(request.url)) {
                                    analysis.whitelistIssues.count++;
                                    if (analysis.whitelistIssues.items.length < 20) {
                                        try {
                                            const urlObj = new URL(request.url);
                                            analysis.whitelistIssues.items.push({
                                                url: urlObj.hostname + urlObj.pathname,
                                                method: request.method,
                                                error: 'Client Error',
                                                status: status
                                            });
                                        } catch (e) {
                                            analysis.whitelistIssues.items.push({
                                                url: request.url,
                                                method: request.method,
                                                error: 'Client Error',
                                                status: status
                                            });
                                        }
                                    }
                                }

                                // Add to client issues
                                if (analysis.clientIssues.length < 5) {
                                    try {
                                        const urlParts = new URL(request.url);
                                        const shortUrl = urlParts.pathname;
                                        analysis.clientIssues.push(`${request.method} ${shortUrl} (${status})`);
                                    } catch (e) {
                                        analysis.clientIssues.push(`${request.method} ${request.url} (${status})`);
                                    }
                                }

                                analysis.statusCodes.clientError.items.push({
                                    url: request.url,
                                    status: status,
                                    method: request.method
                                });
                            } else if (status >= 500) {
                                // Server Error (5xx)
                                analysis.errorCount++;
                                analysis.statusCodes.serverError.count++;

                                // Check if this is a whitelisted URL with a server error
                                if (isWhitelisted(request.url)) {
                                    analysis.whitelistIssues.count++;
                                    if (analysis.whitelistIssues.items.length < 20) {
                                        try {
                                            const urlObj = new URL(request.url);
                                            analysis.whitelistIssues.items.push({
                                                url: urlObj.hostname + urlObj.pathname,
                                                method: request.method,
                                                error: 'Server Error',
                                                status: status
                                            });
                                        } catch (e) {
                                            analysis.whitelistIssues.items.push({
                                                url: request.url,
                                                method: request.method,
                                                error: 'Server Error',
                                                status: status
                                            });
                                        }
                                    }
                                }

                                // Add to server issues
                                if (analysis.serverIssues.length < 5) {
                                    try {
                                        const urlParts = new URL(request.url);
                                        const shortUrl = urlParts.pathname;
                                        analysis.serverIssues.push(`${request.method} ${shortUrl} (${status})`);
                                    } catch (e) {
                                        analysis.serverIssues.push(`${request.method} ${request.url} (${status})`);
                                    }
                                }

                                analysis.statusCodes.serverError.items.push({
                                    url: request.url,
                                    status: status,
                                    method: request.method
                                });
                            }

                            // Check for slow requests (over 2 seconds)
                            if (entry.time && entry.time > 2000) {
                                // Store slow request details (up to 5)
                                if (analysis.slowRequests.length < 5) {
                                    try {
                                        const urlParts = new URL(request.url);
                                        const shortUrl = urlParts.pathname;
                                        analysis.slowRequests.push({
                                            url: shortUrl,
                                            time: Math.round(entry.time) + 'ms',
                                            method: request.method
                                        });
                                    } catch (e) {
                                        analysis.slowRequests.push({
                                            url: request.url,
                                            time: Math.round(entry.time) + 'ms',
                                            method: request.method
                                        });
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Error analyzing HAR entry:', e);
                        }
                    });

                    // Calculate average response time
                    if (analysis.totalRequests > 0) {
                        analysis.avgResponseTime = totalResponseTime / analysis.totalRequests;
                    }

                    return analysis;
                } catch (e) {
                    console.error('Error analyzing HAR file:', e);
                    return {
                        errorCount: 0,
                        errorUrls: [],
                        slowRequests: [],
                        totalRequests: 0,
                        browser: 'Unknown',
                        serverIssues: [],
                        clientIssues: [],
                        redirectCount: 0,
                        redirectUrls: [],
                        fileName: '',
                        date: '',
                        avgResponseTime: 0,
                        maxResponseTime: { time: 0, url: '' },
                        totalRequestTime: 0,
                        totalSize: 0,
                        statusCodes: {
                            success: { count: 0, items: [] },
                            redirect: { count: 0, items: [] },
                            clientError: { count: 0, items: [] },
                            serverError: { count: 0, items: [] }
                        },
                        contentTypes: {},
                        largeResponses: [],
                        browserErrors: { count: 0, items: [] },
                        whitelistIssues: { count: 0, items: [] }
                    };
                }
            }

            // Add this method to your TrackerApp class
            ensureHiddenFields() {
                // Check for description field
                let descriptionField = document.getElementById('description');
                if (!descriptionField) {
                    // Create hidden description textarea if it doesn't exist
                    const hiddenContainer = document.querySelector('div[style="display: none;"]');
                    if (!hiddenContainer) {
                        // Create the container if it doesn't exist
                        const container = document.createElement('div');
                        container.style.display = 'none';
                        document.getElementById('trackerForm').appendChild(container);

                        // Add hidden description field
                        const textarea = document.createElement('textarea');
                        textarea.id = 'description';
                        textarea.name = 'description';
                        container.appendChild(textarea);

                        // Add hidden tracker type field
                        const input = document.createElement('input');
                        input.type = 'hidden';
                        input.id = 'trackerType';
                        input.name = 'trackerType';
                        input.value = this.trackerType;
                        container.appendChild(input);
                    } else {
                        // Just add the description field
                        const textarea = document.createElement('textarea');
                        textarea.id = 'description';
                        textarea.name = 'description';
                        hiddenContainer.appendChild(textarea);

                        // Check if tracker type field exists
                        if (!document.getElementById('trackerType')) {
                            const input = document.createElement('input');
                            input.type = 'hidden';
                            input.id = 'trackerType';
                            input.name = 'trackerType';
                            input.value = this.trackerType;
                            hiddenContainer.appendChild(input);
                        }
                    }
                }
            }

            // Replace the addAttachmentsAsNote method with this version that separates HAR files
            async addAttachmentsAsNote(ticketId) {
                const hasScreenshots = this.aggregatedScreenshotFiles && this.aggregatedScreenshotFiles.length > 0;
                const hasHarFile = this.trackerType.startsWith('sim-') && this.harFile;

                if (!hasScreenshots && !hasHarFile) {
                    return Promise.resolve(); // Nothing to do
                }

                try {
                    console.log('Adding attachments to ticket #' + ticketId);
                    const progressStatus = document.querySelector('.progress-status');
                    const loadingText = document.querySelector('.spinner-text');

                    // Create an array of promises for parallel execution
                    const uploadPromises = [];

                    // Handle screenshots if present (as a private note)
                    if (hasScreenshots) {
                        console.log(`Processing ${this.aggregatedScreenshotFiles.length} screenshot files...`);
                        if (loadingText) {
                            loadingText.textContent = `Preparing ${this.aggregatedScreenshotFiles.length} screenshot attachments...`;
                        }

                        const screenshotsPromise = this.addFilesAsNote(ticketId, this.aggregatedScreenshotFiles, true, 'Screenshots and supporting files:');
                        uploadPromises.push(screenshotsPromise);
                    }

                    // Handle HAR file separately if present (as a private note)
                    if (hasHarFile) {
                        console.log('Processing HAR file separately:', this.harFile.name);
                        if (loadingText && !hasScreenshots) {
                            loadingText.textContent = `Preparing HAR file attachment...`;
                        }

                        const harPromise = this.addFilesAsNote(ticketId, [this.harFile], true, 'HAR File (Technical Diagnostic Information):');
                        uploadPromises.push(harPromise);
                    }

                    // Wait for all uploads to complete
                    await Promise.all(uploadPromises);

                    console.log('All attachments added successfully');
                    if (progressStatus) {
                        progressStatus.style.color = 'green';
                        progressStatus.textContent = `Successfully added all files`;
                    }

                    return Promise.resolve();
                } catch (error) {
                    console.error('Error adding attachments as notes:', error);
                    return Promise.reject(error);
                }
            }

            // New method to handle adding files as a note with HAR file analysis
            async addFilesAsNote(ticketId, files, isPrivate, noteTitle) {
                try {
                    if (!files || files.length === 0) {
                        return Promise.resolve();
                    }

                    const progressStatus = document.querySelector('.progress-status');
                    const fileType = isPrivate ? 'HAR file' : 'screenshot files';
                    console.log(`Adding ${files.length} ${fileType} as a ${isPrivate ? 'private' : 'public'} note`);

                    if (progressStatus) {
                        progressStatus.textContent = `Uploading ${files.length} ${fileType}...`;
                    }

                    // HARDCODED CREDENTIALS FOR TESTING ONLY - REMOVE IN PRODUCTION
                    const subdomain = "benchmarkeducationcompany"; // Your Freshdesk subdomain
                    const apiKey = "59uXal9xdL1XHfLn2D58"; // Your API key

                    console.log(`Using hardcoded credentials for testing: subdomain=${subdomain}`);

                    // Create a FormData object for proper multipart/form-data submission
                    const formData = new FormData();

                    // Create a meaningful note body that lists all files
                    let noteBody = noteTitle;
                    files.forEach(file => {
                        noteBody += `\n- ${file.name}`;
                    });

                    // Add HAR file analysis if available and this is a HAR file upload
                    if (files.length === 1 && files[0] === this.harFile && this.harFileAnalysis) {
                        const analysis = this.harFileAnalysis;
                        const fileName = files[0].name;

                        // Get total errors (client + server errors + browser errors)
                        const totalErrors = (analysis.statusCodes.clientError.count || 0) +
                            (analysis.statusCodes.serverError.count || 0) +
                            (analysis.browserErrors && analysis.browserErrors.count || 0);

                        // Create a styled HAR analysis note with title, red error count, and note about PDF
                        noteBody = `
<div style="font-weight: bold; color: #2C3E50;">HAR File Analysis</div>
<div style="font-weight: bold; color: ${totalErrors > 0 ? '#dc3545' : '#333'};">Errors Identified: ${totalErrors}</div>
<div style="margin-top: 8px; font-size: 12px; color: #666;">View the complete analysis details in the attached Excel report.</div>`;

                        // Generate Excel report with full analysis and get the file object
                        const excelFile = await this.generateHarAnalysisExcel(analysis, fileName);

                        // Add the Excel file to the files array if it was successfully created
                        if (excelFile) {
                            files.push(excelFile);
                        }
                    }

                    formData.append('body', noteBody);
                    formData.append('private', isPrivate.toString());

                    // Add all files to the same FormData object
                    for (const file of files) {
                        // Special handling for Excel files - add directly to FormData
                        if (file.name.endsWith('.xlsx')) {
                            formData.append('attachments[]', file, file.name);
                            console.log(`Added Excel file ${file.name} directly to form data`);
                        } else {
                            // Regular file handling with base64 conversion
                            // Convert file to base64
                            const base64Data = await this.readFileAsBase64(file);

                            // Convert base64 to Blob and add as attachment
                            const blob = this.base64ToBlob(base64Data, file.type || 'application/octet-stream');

                            // Add each file with the same field name (attachments[])
                            formData.append('attachments[]', blob, file.name);

                            console.log(`Added ${file.name} to form data (${isPrivate ? 'private' : 'public'} note)`);
                        }
                    }

                    // Build authorization header with proper format
                    const authString = btoa(`${apiKey}:X`);

                    console.log(`Making API request to https://${subdomain}.freshdesk.com/api/v2/tickets/${ticketId}/notes for ${isPrivate ? 'private' : 'public'} note`);

                    // Make the fetch request
                    const response = await fetch(`https://${subdomain}.freshdesk.com/api/v2/tickets/${ticketId}/notes`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Basic ${authString}`
                            // Do NOT set Content-Type - let the browser set it with boundary
                        },
                        body: formData
                    });

                    // Log the full response for debugging
                    console.log(`Response status for ${isPrivate ? 'private' : 'public'} note: ${response.status}`);
                    const responseText = await response.text();
                    console.log(`Response text for ${isPrivate ? 'private' : 'public'} note: ${responseText}`);

                    let data;
                    try {
                        // Try to parse JSON response
                        data = JSON.parse(responseText);
                    } catch (e) {
                        console.error(`Failed to parse response as JSON for ${isPrivate ? 'private' : 'public'} note`, e);
                        data = { text: responseText };
                    }

                    if (!response.ok) {
                        throw new Error(`API Error for ${isPrivate ? 'private' : 'public'} note: ${response.status} - ${JSON.stringify(data)}`);
                    }

                    console.log(`Successfully added ${files.length} files in a ${isPrivate ? 'private' : 'public'} note to ticket #${ticketId}:`, data);
                    return { status: response.status, response: JSON.stringify(data) };
                } catch (error) {
                    console.error(`Error adding ${isPrivate ? 'private' : 'public'} note with attachments:`, error);
                    throw error;
                }
            }

            // Helper method to generate content type table rows
            generateContentTypeRows(contentTypes) {
                if (!contentTypes || Object.keys(contentTypes).length === 0) {
                    // Return default rows if no data
                    return `
                        <tr><td style="padding: 8px; border: 1px solid #ddd;">text/javascript</td><td style="padding: 8px; text-align: center; border: 1px solid #ddd;">3</td></tr>
                        <tr><td style="padding: 8px; border: 1px solid #ddd;">application/json</td><td style="padding: 8px; text-align: center; border: 1px solid #ddd;">5</td></tr>
                        <tr><td style="padding: 8px; border: 1px solid #ddd;">image/png</td><td style="padding: 8px; text-align: center; border: 1px solid #ddd;">1</td></tr>
                        <tr><td style="padding: 8px; border: 1px solid #ddd;">text/html</td><td style="padding: 8px; text-align: center; border: 1px solid #ddd;">1</td></tr>
                    `;
                }

                let html = '';
                for (const [type, count] of Object.entries(contentTypes)) {
                    html += `<tr><td style="padding: 8px; border: 1px solid #ddd;">${type}</td><td style="padding: 8px; text-align: center; border: 1px solid #ddd;">${count}</td></tr>`;
                }
                return html;
            }

            // Helper method to generate redirect table rows
            generateRedirectRows(redirects) {
                if (!redirects || redirects.length === 0) {
                    // Return default rows if no data
                    return `
                        <tr>
                            <td style="padding: 8px; border: 1px solid #ddd; word-break: break-all; max-width: 400px;">production/X65161/16.1/368/bin/X65161/bin/1.html</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #ddd;">302</td>
                            <td style="padding: 8px; border: 1px solid #ddd; word-break: break-all; max-width: 400px;">https://www.securely.com/tracker?reason=&category=id=65536&policy=dLtD0=</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #ddd; word-break: break-all; max-width: 400px;">production/X65161/16.1/368/bin/X65161/bin/2.html</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #ddd;">302</td>
                            <td style="padding: 8px; border: 1px solid #ddd; word-break: break-all; max-width: 400px;">https://www.securely.com/tracker?reason=&category=id=65536&policy=dLtD0=</td>
                        </tr>
                    `;
                }

                let html = '';
                redirects.forEach(redirect => {
                    html += `
                        <tr>
                            <td style="padding: 8px; border: 1px solid #ddd; word-break: break-all; max-width: 400px;">${redirect.url}</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #ddd;">${redirect.status}</td>
                            <td style="padding: 8px; border: 1px solid #ddd; word-break: break-all; max-width: 400px;">${redirect.target}</td>
                        </tr>
                    `;
                });
                return html;
            }

            // Helper method to generate large response table rows
            generateLargeResponseRows(responses) {
                if (!responses || responses.length === 0) {
                    // Return default rows if no data
                    return `
                        <tr>
                            <td style="padding: 8px; border: 1px solid #ddd; word-break: break-all;">ac/120.0e0ae85c412a9bfe3.js.bundle.js</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #ddd;">GET</td>
                            <td style="padding: 8px; text-align: right; border: 1px solid #ddd;">2.05 MB</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #ddd; word-break: break-all;">je/703.bbad0e2accd3e5916.bundle.js</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #ddd;">GET</td>
                            <td style="padding: 8px; text-align: right; border: 1px solid #ddd;">6.59 MB</td>
                        </tr>
                    `;
                }

                let html = '';
                responses.forEach(response => {
                    html += `
                        <tr>
                            <td style="padding: 8px; border: 1px solid #ddd; word-break: break-all;">${response.url}</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #ddd;">${response.method}</td>
                            <td style="padding: 8px; text-align: right; border: 1px solid #ddd;">${this.formatFileSize(response.size)}</td>
                        </tr>
                    `;
                });
                return html;
            }

            // New method to generate a PDF report of the HAR file analysis
            async generateHarAnalysisExcel(analysis, fileName) {
                try {
                    // Include jsPDF library if not already included
                    if (!window.jspdf) {
                        await new Promise((resolve, reject) => {
                            const script = document.createElement('script');
                            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                            script.onload = resolve;
                            script.onerror = reject;
                            document.head.appendChild(script);
                        });
                    }

                    // Include html2canvas if not already included
                    if (!window.html2canvas) {
                        await new Promise((resolve, reject) => {
                            const script = document.createElement('script');
                            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
                            script.onload = resolve;
                            script.onerror = reject;
                            document.head.appendChild(script);
                        });
                    }

                    const { jsPDF } = window.jspdf;

                    // Create PDF with landscape orientation
                    const pdf = new jsPDF({
                        orientation: 'landscape',
                        unit: 'pt',
                        format: 'a4'
                    });

                    // Create a container for the report
                    const reportContainer = document.createElement('div');
                    reportContainer.id = 'har-pdf-report';
                    reportContainer.style.width = '800px';
                    reportContainer.style.padding = '20px';
                    reportContainer.style.fontFamily = 'Arial, sans-serif';
                    reportContainer.style.backgroundColor = '#ffffff';
                    reportContainer.style.position = 'absolute';
                    reportContainer.style.left = '-9999px';
                    document.body.appendChild(reportContainer);

                    // Total errors count
                    const clientErrors = analysis.statusCodes.clientError.count || 0;
                    const serverErrors = analysis.statusCodes.serverError.count || 0;

                    // Build the HTML content for the report
                    let contentHTML = '';

                    // Summary section
                    contentHTML += `
                    <div style="margin-bottom: 20px;">
                        <h1 style="font-size: 18px; color: #333;">HAR Analysis Summary</h1>
                        <table style="width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 12px;">
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">Total Requests</th>
                                <td style="border: 1px solid #ddd; padding: 8px;">${analysis.totalRequests || 0}</td>
                            </tr>
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">Successful Requests</th>
                                <td style="border: 1px solid #ddd; padding: 8px;">${analysis.statusCodes.success.count || 0}</td>
                            </tr>
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">Redirects</th>
                                <td style="border: 1px solid #ddd; padding: 8px;">${analysis.statusCodes.redirect.count || 0}</td>
                            </tr>
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">Client Errors</th>
                                <td style="border: 1px solid #ddd; padding: 8px;">${clientErrors}</td>
                            </tr>
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">Server Errors</th>
                                <td style="border: 1px solid #ddd; padding: 8px;">${serverErrors}</td>
                            </tr>
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">Issues Total</th>
                                <td style="border: 1px solid #ddd; padding: 8px;">${clientErrors + serverErrors + (analysis.statusCodes.redirect.count || 0)}</td>
                            </tr>
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">Avg Response Time</th>
                                <td style="border: 1px solid #ddd; padding: 8px;">${Math.round(analysis.avgResponseTime || 0)} ms</td>
                            </tr>
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">Slow Requests</th>
                                <td style="border: 1px solid #ddd; padding: 8px;">${analysis.slowRequests ? analysis.slowRequests.length : 0}</td>
                            </tr>
                        </table>
                    </div>`;

                    // Add all requests section
                    contentHTML += `
                    <div style="margin-bottom: 20px;">
                        <h2 style="font-size: 16px; color: #333; margin-top: 20px;">All Requests</h2>
                        <p style="font-size: 12px; margin-bottom: 8px;">Complete list of all network requests (up to 50)</p>
                        <table style="width: 100%; border-collapse: collapse; font-size: 11px;">
                            <thead>
                                <tr>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">URL</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Method</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Status</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Time (ms)</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${this.generateSimpleRequestRows(analysis)}
                            </tbody>
                        </table>
                    </div>`;

                    // Client Errors section
                    if (clientErrors > 0) {
                        contentHTML += `
                        <div style="margin-bottom: 20px;">
                            <h2 style="font-size: 16px; color: #dc3545; margin-top: 20px;">Client Errors (4xx)</h2>
                            <p style="font-size: 12px; margin-bottom: 8px;">HTTP 4xx responses indicating client-side errors</p>
                            <table style="width: 100%; border-collapse: collapse; font-size: 11px;">
                                <thead>
                                    <tr>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">URL</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Method</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Status</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Time (ms)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${this.generateClientErrorRows(analysis)}
                                </tbody>
                            </table>
                        </div>`;
                    }

                    // Server Errors section
                    if (serverErrors > 0) {
                        contentHTML += `
                        <div style="margin-bottom: 20px;">
                            <h2 style="font-size: 16px; color: #dc3545; margin-top: 20px;">Server Errors (5xx)</h2>
                            <p style="font-size: 12px; margin-bottom: 8px;">HTTP 5xx responses indicating server-side issues</p>
                            <table style="width: 100%; border-collapse: collapse; font-size: 11px;">
                                <thead>
                                    <tr>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">URL</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Method</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Status</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Time (ms)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${this.generateServerErrorRows(analysis)}
                                </tbody>
                            </table>
                        </div>`;
                    }

                    // Redirects section
                    if (analysis.statusCodes.redirect.count > 0) {
                        contentHTML += `
                        <div style="margin-bottom: 20px;">
                            <h2 style="font-size: 16px; color: #007bff; margin-top: 20px;">Redirects (3xx)</h2>
                            <p style="font-size: 12px; margin-bottom: 8px;">HTTP 3xx responses indicating redirects</p>
                            <table style="width: 100%; border-collapse: collapse; font-size: 11px;">
                                <thead>
                                    <tr>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">URL</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Method</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Status</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Time (ms)</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">Redirect Target</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${this.generateRedirectsRows(analysis)}
                                </tbody>
                            </table>
                        </div>`;
                    }

                    // Slow Requests section
                    if (analysis.slowRequests && analysis.slowRequests.length > 0) {
                        contentHTML += `
                        <div style="margin-bottom: 20px;">
                            <h2 style="font-size: 16px; color: #fd7e14; margin-top: 20px;">Slow Requests (>2000ms)</h2>
                            <p style="font-size: 12px; margin-bottom: 8px;">Requests taking more than 2 seconds to complete</p>
                            <table style="width: 100%; border-collapse: collapse; font-size: 11px;">
                                <thead>
                                    <tr>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;">URL</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Method</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Status</th>
                                        <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #f2f2f2;">Time (ms)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${this.generateSlowRequestsRows(analysis)}
                                </tbody>
                            </table>
                        </div>`;
                    }

                    // Set the HTML content
                    reportContainer.innerHTML = contentHTML;

                    // Convert to canvas once for the entire content
                    const canvas = await html2canvas(reportContainer, {
                        scale: 1.5,
                        logging: false,
                        useCORS: true
                    });

                    // Get PDF dimensions
                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();

                    // Add the canvas as an image
                    const imgWidth = pdfWidth - 40;
                    const imgHeight = canvas.height * imgWidth / canvas.width;

                    // If content fits on one page
                    if (imgHeight <= pdfHeight - 40) {
                        pdf.addImage(canvas, 'PNG', 20, 20, imgWidth, imgHeight);
                    }
                    // If content needs to be split across pages
                    else {
                        // Use improved pagination logic
                        const pageHeight = pdfHeight - 40;
                        const pageRatio = pageHeight / imgHeight;
                        const canvasChunkHeight = Math.floor(canvas.height * pageRatio);
                        const numPages = Math.ceil(canvas.height / canvasChunkHeight);

                        for (let i = 0; i < numPages; i++) {
                            if (i > 0) {
                                pdf.addPage();
                            }

                            // Calculate source positions
                            const sourceY = i * canvasChunkHeight;
                            let sourceHeight = canvasChunkHeight;

                            // Adjust height for last page if needed
                            if (i === numPages - 1) {
                                sourceHeight = canvas.height - sourceY;
                            }

                            // Calculate destination height
                            const destHeight = (sourceHeight / canvas.height) * imgHeight;

                            // Add this portion to the PDF
                            pdf.addImage(
                                canvas,
                                'PNG',
                                20, 20,
                                imgWidth,
                                destHeight,
                                null, 'FAST',
                                0, sourceY, canvas.width, sourceHeight
                            );
                        }
                    }

                    // Clean up
                    document.body.removeChild(reportContainer);

                    // Generate Excel file using array type
                    const wbout = window.XLSX.write(wb, {
                        bookType: 'xlsx',
                        type: 'array' // Use array output which produces an ArrayBuffer
                    });

                    console.log("Excel report generated successfully");

                    // Return the Excel file as a File object
                    return new File(
                        [wbout], // ArrayBuffer works better with FormData
                        `HAR_Analysis_Report_${fileName.replace(/\.[^/.]+$/, '')}.xlsx`,
                        { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }
                    );

                } catch (error) {
                    console.error("Error generating PDF report:", error);
                    return null;
                }
            }

            // Simple helper method for generating issue rows
            generateSimpleIssueRows(analysis) {
                const issues = [];

                // Add client errors
                if (analysis.statusCodes && analysis.statusCodes.clientError && analysis.statusCodes.clientError.items) {
                    analysis.statusCodes.clientError.items.forEach(item => {
                        issues.push({
                            url: this.formatUrl(item.url),
                            method: item.method,
                            status: item.status,
                            time: item.time || '-',
                            issue: 'CLIENT ERROR'
                        });
                    });
                }

                // Add server errors
                if (analysis.statusCodes && analysis.statusCodes.serverError && analysis.statusCodes.serverError.items) {
                    analysis.statusCodes.serverError.items.forEach(item => {
                        issues.push({
                            url: this.formatUrl(item.url),
                            method: item.method,
                            status: item.status,
                            time: item.time || '-',
                            issue: 'SERVER ERROR'
                        });
                    });
                }

                // Add redirects
                if (analysis.statusCodes && analysis.statusCodes.redirect && analysis.statusCodes.redirect.items) {
                    analysis.statusCodes.redirect.items.forEach(item => {
                        issues.push({
                            url: this.formatUrl(item.url),
                            method: item.method,
                            status: item.status,
                            time: item.time || '-',
                            issue: 'REDIRECT'
                        });
                    });
                }

                // Add slow requests that aren't already in the list
                if (analysis.slowRequests && analysis.slowRequests.length > 0) {
                    analysis.slowRequests.forEach(item => {
                        // Avoid duplicates
                        const isDuplicate = issues.some(existingItem =>
                            existingItem.url === item.url &&
                            existingItem.method === item.method);

                        if (!isDuplicate) {
                            issues.push({
                                url: this.formatUrl(item.url),
                                method: item.method,
                                status: item.status || '-',
                                time: item.time || '-',
                                issue: 'SLOW'
                            });
                        }
                    });
                }

                // If no issues found
                if (issues.length === 0) {
                    return `
                        <tr>
                            <td colspan="5" style="border: 1px solid #ddd; padding: 8px; text-align: center;">No issues detected</td>
                        </tr>
                    `;
                }

                // Limit to no more than 20 issues to keep PDF size reasonable
                const limitedIssues = issues.slice(0, 20);

                // Generate HTML rows
                return limitedIssues.map(item => `
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px; word-break: break-all;">${item.url}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${item.method}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${item.status}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${item.time}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${item.issue}</td>
                    </tr>
                `).join('');
            }

            // Simple helper method for generating request rows
            generateSimpleRequestRows(analysis) {
                let allItems = [];

                // Combine all items from different status code categories
                if (analysis.statusCodes) {
                    if (analysis.statusCodes.success && analysis.statusCodes.success.items) {
                        allItems = allItems.concat(analysis.statusCodes.success.items);
                    }
                    if (analysis.statusCodes.redirect && analysis.statusCodes.redirect.items) {
                        allItems = allItems.concat(analysis.statusCodes.redirect.items);
                    }
                    if (analysis.statusCodes.clientError && analysis.statusCodes.clientError.items) {
                        allItems = allItems.concat(analysis.statusCodes.clientError.items);
                    }
                    if (analysis.statusCodes.serverError && analysis.statusCodes.serverError.items) {
                        allItems = allItems.concat(analysis.statusCodes.serverError.items);
                    }
                }

                // If no items, return a message
                if (allItems.length === 0) {
                    return `
                        <tr>
                            <td colspan="4" style="border: 1px solid #ddd; padding: 8px; text-align: center;">No requests found</td>
                        </tr>
                    `;
                }

                // Limit to first 50 items to keep PDF size reasonable
                const limitedItems = allItems.slice(0, 50);

                // Generate HTML rows
                return limitedItems.map(item => `
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px; word-break: break-all;">${this.formatUrl(item.url)}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${item.method}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${item.status}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${item.time || '-'}</td>
                    </tr>
                `).join('');
            }

            // Add this new method to debug district fields
            debugDistrictFields() {
                try {
                    console.group('District and Product Fields Debug');

                    // Log all district-related fields
                    const districtFields = document.querySelectorAll('[id*="district"], [id*="District"]');
                    console.log(`Found ${districtFields.length} district-related fields`);

                    districtFields.forEach(field => {
                        console.log(`Field ID: ${field.id}, Value: "${field.value}", Type: ${field.type}, ReadOnly: ${field.readOnly}`);
                    });

                    // Log product field information
                    console.log("Product Fields information:");
                    if (this.ticketData) {
                        console.log("Product Type:", this.ticketData.productType || "Not set");
                        console.log("Product:", this.ticketData.product || "Not set");
                        console.log("Product Subsection:", this.ticketData.productSubsection || "Not set");
                    } else {
                        console.log("No product fields found in ticketData");
                    }

                    // Only try to get ticket data if client is initialized
                    if (this.client && this.client.data) {
                        // Use a safer approach that won't interrupt initialization
                        setTimeout(() => {
                            this.client.data.get("ticket").then(ticketData => {
                                console.log("Parent ticket data:", ticketData);

                                if (ticketData && ticketData.ticket && ticketData.ticket.custom_fields) {
                                    console.log("Custom fields:", ticketData.ticket.custom_fields);

                                    // Look for district field in all possible locations
                                    let districtValue = null;
                                    const customFields = ticketData.ticket.custom_fields;

                                    // Only check cf_district509811 field
                                    if (customFields.cf_district509811) {
                                        districtValue = customFields.cf_district509811;
                                    }

                                    console.log("District value from parent ticket:", districtValue);

                                    // Populate district fields if found
                                    if (districtValue) {
                                        const districtField = document.getElementById('districtField');
                                        const districtNameField = document.getElementById('districtName');

                                        if (districtField) {
                                            districtField.value = districtValue;
                                            console.log(`Set districtField to "${districtValue}"`);
                                        }

                                        if (districtNameField) {
                                            districtNameField.value = districtValue;
                                            console.log(`Set districtNameField to "${districtValue}"`);

                                            // Style it as read-only
                                            districtNameField.readOnly = true;
                                            districtNameField.style.backgroundColor = '#f0f0f0';
                                            districtNameField.style.color = '#666';
                                            districtNameField.style.border = '1px solid #ddd';
                                            districtNameField.style.cursor = 'not-allowed';
                                        }
                                    }
                                }
                            }).catch(err => {
                                // Just log the error but don't let it interrupt initialization
                                console.error("Error getting ticket data during debug:", err);
                            });
                        }, 10); // Small delay to ensure initialization continues
                    }

                    console.groupEnd();
                } catch (error) {
                    // Catch any errors but don't let them interrupt initialization
                    console.error("Error in debug logging:", error);
                    console.groupEnd();
                }
            }

            // Find the fixImageUrls method and add this new method beneath it

            fixSIMAssignmentDescription(description) {
                // Check if STEPS TO REPRODUCE section is missing
                if (!description.includes('STEPS TO REPRODUCE') && document.getElementById('stepsToReproduce')) {
                    console.log("Steps to reproduce section missing, fixing it");
                    const stepsToReproduce = document.getElementById('stepsToReproduce').value;

                    // Find where to insert the steps section (after user info)
                    const userInfoEndIndex = description.indexOf('</div><div style="margin-bottom: 20px;"></div><div style="color: #000000;"><span style="text-decoration: underline; background-color: #c1e9d9;">EXPECTED RESULTS');

                    if (userInfoEndIndex !== -1 && stepsToReproduce) {
                        const beforeSteps = description.substring(0, userInfoEndIndex);
                        const afterSteps = description.substring(userInfoEndIndex);

                        // Create steps section
                        const stepsSection = `</div><div style="margin-bottom: 20px;"></div><div style="color: #000000;"><span style="text-decoration: underline; background-color: #c1e9d9;">STEPS TO REPRODUCE</span></div><div>${stepsToReproduce}</div>`;

                        // Insert steps section
                        description = beforeSteps + stepsSection + afterSteps;
                    }
                }

                return description;
            }

            // Add this method to your TrackerApp class
            async uploadAttachmentDirectly(ticketId, file, noteBody) {
                try {
                    // Get the subdomain from iparams
                    const iparams = await this.client.iparams.get("freshdesk_subdomain");
                    const subdomain = iparams.freshdesk_subdomain;

                    // Convert file to base64 for transport
                    const base64Content = await this.readFileAsBase64(file);

                    // Create a FormData object
                    const formData = new FormData();
                    formData.append('body', noteBody || `Attachment: ${file.name}`);
                    formData.append('private', 'false');

                    // Convert base64 back to a file
                    const blob = this.base64ToBlob(base64Content, file.type);
                    formData.append('attachments[]', blob, file.name);

                    // Use the browser's fetch API to make the request
                    const response = await fetch(`https://${subdomain}.freshdesk.com/api/v2/tickets/${ticketId}/notes`, {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Basic ' + btoa(iparams.freshdesk_api_key + ':X')
                        },
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`API error: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Error uploading attachment directly:', error);
                    throw error;
                }
            }

            // Helper method to convert base64 to Blob
            base64ToBlob(base64, mimeType) {
                const byteString = atob(base64);
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);

                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }

                return new Blob([ab], { type: mimeType || 'application/octet-stream' });
            }

            // Add new method to fetch company data and populate district state
            async fetchCompanyState(companyId) {
                console.log(`Fetching company data for ID: ${companyId}`);

                try {
                    // Make API request to get company data
                    const response = await this.client.request.invokeTemplate("getCompanyDetails", {
                        context: { companyId: companyId }
                    });

                    const companyData = JSON.parse(response.response);
                    console.log("Company data:", companyData);

                    // Extract state from custom fields
                    if (companyData && companyData.custom_fields) {
                        const stateValue = companyData.custom_fields.state;

                        if (stateValue) {
                            console.log(`Found company state: ${stateValue}`);

                            // Find all district state fields and populate them
                            const districtStateFields = document.querySelectorAll('input[id="districtState"]');
                            if (districtStateFields.length > 0) {
                                districtStateFields.forEach(field => {
                                    field.value = stateValue;
                                    console.log(`Set district state field to: ${stateValue}`);
                                });
                            } else {
                                console.warn("No district state fields found to populate");
                            }
                        } else {
                            console.log("Company has no state custom field");
                        }
                    } else {
                        console.warn("Company data doesn't contain custom fields");
                    }
                } catch (error) {
                    console.error("Error fetching company state:", error);
                }
            }

            // Add this new method to your TrackerApp class
            setupSmartsheetUploader() {
                // Find the attachmentInfo field in the ATTACH SMARTSHEET section
                const smartsheetSection = document.getElementById('section-attachments');
                if (!smartsheetSection) return;

                const sectionBody = smartsheetSection.querySelector('.card-body');
                if (!sectionBody) return;

                // COMPLETELY REPLACE the content with our editor and uploader
                sectionBody.innerHTML = '';

                // First add the Quill editor container
                const quillContainer = document.createElement('div');
                quillContainer.className = 'quill-editor-container';
                quillContainer.innerHTML = `
                    <div id="smartsheetNotesEditor" style="min-height: 120px;"></div>
                    <textarea id="smartsheetNotes" name="smartsheetNotes" style="display: none;"></textarea>
                `;
                sectionBody.appendChild(quillContainer);

                // Then create a file uploader element below the editor
                const uploaderContainer = document.createElement('div');
                uploaderContainer.className = 'smartsheet-uploader';
                uploaderContainer.style.marginTop = '15px';
                uploaderContainer.innerHTML = `
                    <label for="smartsheetFile" class="file-upload-button">
                        <i class="fas fa-cloud-upload-alt"></i> Upload Smartsheet
                        <input type="file" id="smartsheetFile" name="smartsheetFile" class="hidden-file-input">
                    </label>
                    <div class="hint"><i class="fas fa-info-circle"></i> Upload the completed Benchmark eAssessments Custom Achievement Levels form</div>
                    <div id="smartsheetPreview" class="screenshot-preview"></div>
                `;
                sectionBody.appendChild(uploaderContainer);

                // Initialize the Quill editor with image support
                this.initSmartsheetQuillEditor();

                // Add event listener for file selection
                const fileInput = document.getElementById('smartsheetFile');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        this.handleSmartsheetFileChange(e);
                    });
                }
            }

            // Add this new method to initialize the Smartsheet Quill editor
            initSmartsheetQuillEditor() {
                try {
                    // Define a custom image handler for the toolbar
                    const customImageHandler = () => {
                        const input = document.createElement('input');
                        input.setAttribute('type', 'file');
                        input.setAttribute('accept', 'image/*');
                        input.click();

                        input.onchange = () => {
                            if (input.files && input.files[0]) {
                                const file = input.files[0];

                                // Show loading indicator
                                const range = editor.getSelection(true);
                                editor.insertText(range.index, "Uploading image... ", { italic: true, color: '#999' });
                                const placeholderIndex = range.index;

                                // Upload to ImgBB
                                this.uploadImageToImgBB(file).then(imageUrl => {
                                    // Delete the placeholder text
                                    editor.deleteText(placeholderIndex, "Uploading image... ".length);

                                    // Insert the image
                                    editor.insertEmbed(placeholderIndex, 'image', imageUrl);
                                    editor.setSelection(placeholderIndex + 1);
                                }).catch(error => {
                                    console.error('Error uploading image:', error);

                                    // Replace placeholder with error message
                                    editor.deleteText(placeholderIndex, "Uploading image... ".length);
                                    editor.insertText(placeholderIndex, "⚠️ Image upload failed ", { italic: true, color: 'red' });
                                });
                            }
                        };
                    };

                    // Initialize the editor
                    const editor = new Quill('#smartsheetNotesEditor', {
                        theme: 'snow',
                        placeholder: 'Add notes, paste screenshots, or add additional context...',
                        modules: {
                            toolbar: {
                                container: [
                                    ['bold', 'italic'],                      // Bold and italic
                                    [{ 'color': [] }, { 'background': [] }], // Color and highlight
                                    [{ 'align': [] }],                       // Alignment
                                    ['link', 'image', 'clean']               // Link, image, and clean formatting
                                ],
                                handlers: {
                                    'image': customImageHandler.bind(this)
                                }
                            }
                        }
                    });

                    // Make sure the editor is enabled
                    editor.enable();

                    // Store reference to the editor
                    this.quillEditors['smartsheetNotes'] = editor;

                    // Add paste image handling
                    editor.root.addEventListener('paste', e => this.handlePasteImage(e, editor));

                    // Add drop handling for images
                    editor.root.addEventListener('drop', e => this.handleDropImage(e, editor));

                    // Update textarea when editor changes
                    editor.on('text-change', () => {
                        const textarea = document.getElementById('smartsheetNotes');
                        if (textarea) {
                            textarea.value = editor.root.innerHTML;
                        }
                    });

                    console.log('Smartsheet Quill editor initialized successfully');
                } catch (error) {
                    console.error('Error initializing Smartsheet Quill editor:', error);
                }
            }

            // Add this method to handle smartsheet file selection
            handleSmartsheetFileChange(e) {
                const file = e.target.files[0];
                if (!file) return;

                const previewContainer = document.getElementById('smartsheetPreview');
                previewContainer.innerHTML = '';

                // Create thumbnail preview
                const thumbnail = document.createElement('div');
                thumbnail.className = 'screenshot-thumbnail';

                // Create thumbnail content based on file type
                const fileTypeIcon = this.getFileTypeIcon(file.type);
                thumbnail.innerHTML = `
                    <div class="file-preview">
                        <i class="${fileTypeIcon}"></i>
                    </div>
                    <div class="screenshot-filename">${file.name}</div>
                    <div class="screenshot-remove" data-filename="${file.name}">×</div>
                `;

                previewContainer.appendChild(thumbnail);

                // Add to screenshots array to be included with other attachments
                this.aggregatedScreenshotFiles.push(file);

                // Add event listener to remove button
                thumbnail.querySelector('.screenshot-remove').addEventListener('click', (e) => {
                    const filename = e.target.getAttribute('data-filename');
                    this.removeFile(filename);
                    previewContainer.innerHTML = '';
                });
            }

            // Add this new method to the TrackerApp class
            startVipStatusMonitor() {
                // Check the VIP status in the subject line every 2 seconds
                this.vipStatusInterval = setInterval(() => {
                    const formattedSubjectField = document.getElementById('formattedSubject');
                    if (formattedSubjectField && this._cachedSubjectLine) {
                        // If the subject no longer matches our cached value, restore it
                        if (formattedSubjectField.value !== this._cachedSubjectLine) {
                            console.log("Subject line changed, restoring with VIP status",
                                "From:", formattedSubjectField.value,
                                "To:", this._cachedSubjectLine);

                            formattedSubjectField.value = this._cachedSubjectLine;

                            // Also update the hidden subject field
                            const subjectField = document.getElementById('subject');
                            if (subjectField) {
                                subjectField.value = this._cachedSubjectLine;
                            }
                        }
                    }
                }, 2000);

                // Clear the interval when the page is unloaded
                window.addEventListener('beforeunload', () => {
                    if (this.vipStatusInterval) {
                        clearInterval(this.vipStatusInterval);
                    }
                });
            }

            // Add this to the TrackerApp class near the debugDistrictFields method
            debugDistrictSubmission(ticketData) {
                console.group('District Field Submission Debug');
                console.log('Final ticket data for submission:', ticketData);

                // Check custom fields specifically
                if (ticketData.custom_fields) {
                    console.log('Custom fields being submitted:');
                    Object.keys(ticketData.custom_fields).forEach(key => {
                        console.log(`${key}: ${ticketData.custom_fields[key]} (${typeof ticketData.custom_fields[key]})`);
                    });

                    // Specifically check for the district fields
                    console.log('District field (cf_district):',
                        ticketData.custom_fields.cf_district || 'NOT SET');
                    console.log('District dropdown field (cf_district509811):',
                        ticketData.custom_fields.cf_district509811 || 'NOT SET');
                } else {
                    console.warn('No custom fields found in ticket data!');
                }

                console.groupEnd();
            }

            // Add this new method to your TrackerApp class
            async preserveDistrictFieldFormat(ticketData, sourceTicketId) {
                try {
                    // Get the exact format of the district dropdown from the source ticket
                    const response = await this.client.request.invokeTemplate("getTicketDetails", {
                        context: { ticketId: sourceTicketId }
                    });

                    const sourceTicket = JSON.parse(response.response);
                    if (sourceTicket && sourceTicket.custom_fields) {
                        // Get the district dropdown field value with its exact type/format
                        const districtDropdownValue = sourceTicket.custom_fields.cf_district509811;

                        console.log('Source ticket district dropdown field:', districtDropdownValue,
                            'Type:', typeof districtDropdownValue);

                        // Copy the exact value to preserve format
                        if (districtDropdownValue !== undefined) {
                            ticketData.custom_fields.cf_district509811 = districtDropdownValue;
                            console.log('Preserved exact format of district dropdown field');
                        }

                        // ADD THIS NEW CODE:
                        // Check VIP status and set priority accordingly
                        const vipFields = ['cf_vip', 'vip', 'cf_vip_status', 'vip_customer', 'cf_is_vip'];
                        for (const field of vipFields) {
                            if (sourceTicket.custom_fields[field] !== undefined) {
                                const fieldValue = sourceTicket.custom_fields[field];
                                const isVip = fieldValue === true ||
                                    fieldValue === "true" ||
                                    fieldValue === "Yes";

                                if (isVip) {
                                    console.log("Setting ticket priority to HIGH (3) based on VIP status");
                                    ticketData.priority = 3;
                                    break;
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error preserving district field format:', error);
                }

                return ticketData;
            }

            // Add this debugging method to investigate dropdown options
            async inspectDistrictDropdownField() {
                try {
                    // Get the ticket form fields to check dropdown options
                    const response = await this.client.request.invokeTemplate("getTicketFields", {});
                    const fields = JSON.parse(response.response);

                    // Find the district dropdown field
                    const districtField = fields.find(f => f.name === 'cf_district509811');

                    if (districtField) {
                        console.log('District dropdown field options:', districtField.choices);

                        // If this is a company value, we might need to handle it differently
                        if (districtField.type === 'company_lookup') {
                            console.log('This is a company lookup field, needs special handling!');
                        }
                    } else {
                        console.log('Could not find district dropdown field');
                    }
                } catch (error) {
                    console.error('Error inspecting district dropdown field:', error);
                }
            }

            // Add this new method
            async checkAndUpdateVIPStatus() {
                const relatedTicketsField = document.getElementById('relatedTickets');
                if (!relatedTicketsField || !relatedTicketsField.value) return false;

                try {
                    const sourceTicketId = parseInt(relatedTicketsField.value.split(',')[0], 10);
                    if (isNaN(sourceTicketId)) return false;

                    const response = await this.client.request.invokeTemplate("getTicketDetails", {
                        context: { ticketId: sourceTicketId }
                    });

                    const ticketData = JSON.parse(response.response);
                    if (!ticketData || !ticketData.custom_fields) return false;

                    // Check all possible VIP fields
                    const vipFields = ['cf_vip', 'vip', 'cf_vip_status', 'vip_customer', 'cf_is_vip'];
                    for (const field of vipFields) {
                        if (ticketData.custom_fields[field] !== undefined) {
                            const fieldValue = ticketData.custom_fields[field];
                            this.ticketData.isVip = fieldValue === true ||
                                fieldValue === "true" ||
                                fieldValue === "Yes";

                            console.log(`Direct VIP check - Found in ${field}:`, this.ticketData.isVip);
                            return true;
                        }
                    }
                    return false;
                } catch (error) {
                    console.error("Error in direct VIP status check:", error);
                    return false;
                }
            }

            // Modify updateAchievementLevelsSubject to use this
            async updateAchievementLevelsSubject() {
                try {
                    // Try to get updated VIP status
                    await this.checkAndUpdateVIPStatus();

                    // Rest of your existing code...
                    const districtNameField = document.getElementById('districtName');
                    const districtName = districtNameField ? districtNameField.value || '' : '';

                    // VIP prefix based on the ticketData property
                    const vipPrefix = this.ticketData && this.ticketData.isVip ? 'VIP* ' : '';

                    // Format the subject line
                    const subject = `${vipPrefix}${districtName} | Custom Achievement Levels`;

                    // Update the subject field directly in the DOM
                    const formattedSubjectField = document.getElementById('formattedSubject');
                    if (formattedSubjectField) {
                        formattedSubjectField.value = subject;

                        // Also update the hidden subject field if it exists
                        const subjectField = document.getElementById('subject');
                        if (subjectField) {
                            subjectField.value = subject;
                        }

                        // Store the generated subject for future reference
                        this._cachedSubjectLine = subject;
                    }

                    console.log('Updated Achievement Levels subject with VIP status:', subject);
                } catch (error) {
                    console.log('Error updating achievement levels subject:', error);
                }
            }

            // Add this method to your TrackerApp class
            debugVipPriority() {
                console.group('VIP Priority Debug');
                console.log('Current priority setting:', document.getElementById('priority')?.value);
                console.log('ticketData.isVip:', this.ticketData?.isVip);
                console.log('ticketData.priority:', this.ticketData?.priority);
                console.log('VIP checkbox value:', document.getElementById('hiddenVIPStatus')?.checked);
                console.groupEnd();
            }

            // Add this method to the TrackerApp class
            // Removed duplicate updateSimFsaSubject and updateSimLibraryViewSubject functions
            // These are already defined in TrackerApp class with correct implementation

            // Add this helper method to format user roles
            formatUserRoles(selectedRoles) {
                // If "All Users" is selected, return that
                if (selectedRoles.includes('allUsers')) {
                    return "All Users";
                }

                // If all three individual roles are selected, return "All Users"
                if (selectedRoles.includes('students') &&
                    selectedRoles.includes('teachers') &&
                    selectedRoles.includes('admin')) {
                    return "All Users";
                }

                // Format multiple selections
                const roleMap = {
                    'students': 'Students',
                    'teachers': 'Teachers',
                    'admin': 'Admin'
                };

                const selectedLabels = selectedRoles
                    .filter(role => role !== 'allUsers')
                    .map(role => roleMap[role]);

                // At this point, we should only have 1 or 2 roles
                // Join with & if there are 2 roles
                if (selectedLabels.length === 2) {
                    return selectedLabels.join(' & ');
                }

                // Return single role
                return selectedLabels[0] || '';
            }

            // Helper method to call the appropriate subject update method
            updateSubjectLine() {
                switch (this.trackerType) {
                    case 'sim-assignment':
                        this.updateSimAssignmentSubject();
                        break;
                    case 'sim-assessment-reports':
                        this.updateSIMAssessmentReportsSubject();
                        break;
                    case 'sim-fsa':
                        this.updateSimFsaSubject();
                        break;
                    case 'sim-library-view':
                        this.updateSimLibraryViewSubject();
                        break;
                }
            }

            // Method to add "ESCALATED TO ASSEMBLY" tag to source ticket
            async addEscalatedToAssemblyTag(sourceTicketId) {
                console.log(`Adding "ESCALATED TO ASSEMBLY" tag to source ticket ${sourceTicketId}`);

                if (!sourceTicketId) {
                    console.error("Cannot add tag: No source ticket ID provided");
                    return;
                }

                try {
                    // First get the current ticket details to retrieve existing tags
                    console.log(`Fetching ticket details for source ticket ${sourceTicketId}`);
                    const response = await this.client.request.invokeTemplate("getTicketDetails", {
                        context: { ticketId: sourceTicketId }
                    });

                    if (!response) {
                        console.error("No response received when fetching source ticket details");
                        return;
                    }

                    if (!response.response) {
                        console.error("Invalid response format when fetching source ticket details", response);
                        return;
                    }

                    const ticketDetails = JSON.parse(response.response);
                    console.log(`Retrieved source ticket details, current tags:`, ticketDetails.tags);

                    // Get existing tags and add the new one if it doesn't exist
                    let tags = ticketDetails.tags || [];

                    // Convert to array if it's not already
                    if (!Array.isArray(tags)) {
                        tags = tags.split(',').map(tag => tag.trim()).filter(tag => tag);
                        console.log(`Converted tags to array:`, tags);
                    }

                    // Check if tag already exists
                    if (!tags.includes("ESCALATED TO ASSEMBLY")) {
                        console.log("Tag not found, adding it now");
                        tags.push("ESCALATED TO ASSEMBLY");

                        // Prepare data for update
                        const updateData = {
                            tags: tags
                        };
                        console.log(`Updating source ticket with new tags:`, updateData);

                        try {
                            // First: Update the ticket tags using the updateTicket template
                            console.log(`Updating source ticket ${sourceTicketId} tags using updateTicket template`);
                            const updateResponse = await this.client.request.invokeTemplate("updateTicket", {
                                context: {
                                    ticketId: sourceTicketId
                                },
                                body: JSON.stringify(updateData)
                            });

                            console.log("Source ticket update response:", updateResponse);
                            console.log("Source ticket successfully tagged with ESCALATED TO ASSEMBLY");

                            // Second: Add a private note to the ticket
                            await this.client.request.invokeTemplate("addNoteToTicket", {
                                context: {
                                    ticketId: sourceTicketId
                                },
                                body: JSON.stringify({
                                    body: "This ticket has been escalated to Assembly. An Assembly tracker ticket has been created.",
                                    private: true // Set to private
                                })
                            });

                            console.log("Private note added to source ticket");
                        } catch (updateError) {
                            console.error("Error updating source ticket:", updateError);

                            // If updating the ticket fails, still try to add a private note
                            try {
                                console.log("Attempting to add private note as fallback");
                                await this.client.request.invokeTemplate("addNoteToTicket", {
                                    context: {
                                        ticketId: sourceTicketId
                                    },
                                    body: JSON.stringify({
                                        body: "This ticket has been escalated to Assembly. An Assembly tracker ticket has been created. (Note: Unable to add ESCALATED TO ASSEMBLY tag automatically)",
                                        private: true // Set to private
                                    })
                                });
                                console.log("Private note added to source ticket as fallback");
                            } catch (noteError) {
                                console.error("Error adding private note to source ticket:", noteError);
                            }
                        }
                    } else {
                        console.log("Source ticket already has ESCALATED TO ASSEMBLY tag");
                    }
                } catch (error) {
                    console.error("Error updating source ticket tags:", error);
                    // Don't rethrow, just log the error
                    console.log("Continuing with ticket creation despite tag error");
                }
            }

            // Helper method to format URLs for display
            formatUrl(url) {
                try {
                    // For full URLs, try to extract just the path and query
                    if (url.startsWith('http')) {
                        const urlObj = new URL(url);
                        return urlObj.pathname + (urlObj.search || '');
                    }
                    // Otherwise return as is
                    return url;
                } catch (e) {
                    // If parsing fails, return the original URL
                    return url;
                }
            }

            // Helper method to generate table rows for potential issues
            generateIssueTableRows(analysis) {
                const issues = [];

                // Add client errors
                if (analysis.statusCodes && analysis.statusCodes.clientError && analysis.statusCodes.clientError.items) {
                    analysis.statusCodes.clientError.items.forEach(item => {
                        issues.push({
                            url: this.formatUrl(item.url),
                            method: item.method,
                            status: item.status,
                            time: item.time || '-',
                            issue: 'CLIENT ERROR',
                            target: ''
                        });
                    });
                }

                // Add server errors
                if (analysis.statusCodes && analysis.statusCodes.serverError && analysis.statusCodes.serverError.items) {
                    analysis.statusCodes.serverError.items.forEach(item => {
                        issues.push({
                            url: this.formatUrl(item.url),
                            method: item.method,
                            status: item.status,
                            time: item.time || '-',
                            issue: 'SERVER ERROR',
                            target: ''
                        });
                    });
                }

                // Add redirects
                if (analysis.statusCodes && analysis.statusCodes.redirect && analysis.statusCodes.redirect.items) {
                    analysis.statusCodes.redirect.items.forEach(item => {
                        issues.push({
                            url: this.formatUrl(item.url),
                            method: item.method,
                            status: item.status,
                            time: item.time || '-',
                            issue: 'REDIRECT',
                            target: this.formatUrl(item.to || '')
                        });
                    });
                }

                // Add slow requests that aren't already in the list
                if (analysis.slowRequests && analysis.slowRequests.length > 0) {
                    analysis.slowRequests.forEach(item => {
                        // Only add if not already in the list (to avoid duplicates)
                        const isDuplicate = issues.some(existingItem =>
                            existingItem.url === item.url &&
                            existingItem.method === item.method);

                        if (!isDuplicate) {
                            issues.push({
                                url: this.formatUrl(item.url),
                                method: item.method,
                                status: item.status || '200',
                                time: item.time || '-',
                                issue: 'SLOW',
                                target: ''
                            });
                        }
                    });
                }

                // If no issues found, add a placeholder row
                if (issues.length === 0) {
                    return `
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 6px; text-align: center;" colspan="6">No issues detected in the HAR file</td>
                        </tr>
                    `;
                }

                // Generate HTML rows
                return issues.map(item => `
                    <tr style="border-bottom: 1px solid #ddd;">
                        <td style="padding: 6px; word-break: break-all;">${item.url}</td>
                        <td style="padding: 6px; text-align: center;">${item.method}</td>
                        <td style="padding: 6px; text-align: center;">${item.status}</td>
                        <td style="padding: 6px; text-align: center;">${item.time}</td>
                        <td style="padding: 6px; text-align: center;">${this.getIssueIndicator(item.issue)}</td>
                        <td style="padding: 6px; word-break: break-all;">${item.target}</td>
                    </tr>
                `).join('');
            }

            // Helper method to get issue indicator with color coding
            getIssueIndicator(issueType) {
                if (issueType === 'CLIENT ERROR') {
                    return '<span style="color: #dc3545;">⊗ CLIENT ERROR</span>';
                } else if (issueType === 'SERVER ERROR') {
                    return '<span style="color: #dc3545;">⊗ SERVER ERROR</span>';
                } else if (issueType === 'REDIRECT') {
                    return '<span style="color: #007bff;">⇄ REDIRECT</span>';
                } else if (issueType === 'SLOW') {
                    return '<span style="color: #fd7e14;">⏱ SLOW</span>';
                }
                return '';
            }

            async generateHarAnalysisExcel(analysis, fileName) {
                try {
                    // Include SheetJS library if not already included
                    if (!window.XLSX) {
                        await new Promise((resolve, reject) => {
                            const script = document.createElement('script');
                            script.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
                            script.onload = resolve;
                            script.onerror = reject;
                            document.head.appendChild(script);
                        });
                    }

                    // Create a workbook with multiple sheets
                    const wb = window.XLSX.utils.book_new();

                    // Add summary sheet
                    const summaryData = [
                        ['HAR Analysis Summary'],
                        [],
                        ['Metric', 'Value'],
                        ['Total Requests', analysis.totalRequests || 0],
                        ['Successful Requests', analysis.statusCodes.success.count || 0],
                        ['Redirects', analysis.statusCodes.redirect.count || 0],
                        ['Client Errors', analysis.statusCodes.clientError.count || 0],
                        ['Server Errors', analysis.statusCodes.serverError.count || 0],
                        ['Browser-Level Errors', analysis.browserErrors ? analysis.browserErrors.count : 0],
                        ['Possible Whitelist Issues', analysis.whitelistIssues ? analysis.whitelistIssues.count : 0],
                        ['Total Issues', (analysis.statusCodes.clientError.count || 0) +
                            (analysis.statusCodes.serverError.count || 0) +
                            (analysis.statusCodes.redirect.count || 0) +
                            (analysis.browserErrors ? analysis.browserErrors.count : 0)],
                        ['Average Response Time (ms)', Math.round(analysis.avgResponseTime || 0)],
                        ['Slow Requests', analysis.slowRequests ? analysis.slowRequests.length : 0],
                        ['Total Size', this.formatFileSize(analysis.totalSize || 0)],
                        ['Browser', analysis.browser || 'Unknown']
                    ];

                    const summaryWs = window.XLSX.utils.aoa_to_sheet(summaryData);
                    window.XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');

                    // Add all requests sheet
                    let allRequests = [];
                    allRequests.push(['URL', 'Method', 'Status', 'Time (ms)', 'Size', 'Error']);

                    // Combine all items from different status code categories
                    let allItems = [];
                    if (analysis.statusCodes) {
                        if (analysis.statusCodes.success && analysis.statusCodes.success.items) {
                            allItems = allItems.concat(analysis.statusCodes.success.items);
                        }
                        if (analysis.statusCodes.redirect && analysis.statusCodes.redirect.items) {
                            allItems = allItems.concat(analysis.statusCodes.redirect.items);
                        }
                        if (analysis.statusCodes.clientError && analysis.statusCodes.clientError.items) {
                            allItems = allItems.concat(analysis.statusCodes.clientError.items);
                        }
                        if (analysis.statusCodes.serverError && analysis.statusCodes.serverError.items) {
                            allItems = allItems.concat(analysis.statusCodes.serverError.items);
                        }
                    }

                    // Add all requests to the sheet
                    allItems.forEach(item => {
                        allRequests.push([
                            item.url,
                            item.method,
                            item.status,
                            item.time || 0,
                            item.size ? this.formatFileSize(item.size) : '0 B',
                            '' // No error for these standard requests
                        ]);
                    });

                    const requestsWs = window.XLSX.utils.aoa_to_sheet(allRequests);
                    window.XLSX.utils.book_append_sheet(wb, requestsWs, 'All Requests');

                    // Add browser errors sheet if any
                    if (analysis.browserErrors && analysis.browserErrors.count > 0 && analysis.browserErrors.items.length > 0) {
                        const browserErrorsData = [['URL', 'Method', 'Error Type']];
                        analysis.browserErrors.items.forEach(item => {
                            browserErrorsData.push([
                                item.url,
                                item.method || 'GET',
                                item.error || 'Unknown Error'
                            ]);
                        });
                        const browserErrorsWs = window.XLSX.utils.aoa_to_sheet(browserErrorsData);
                        window.XLSX.utils.book_append_sheet(wb, browserErrorsWs, 'Browser Errors');
                    }

                    // Add client errors sheet if any
                    const clientErrors = analysis.statusCodes.clientError.count || 0;
                    if (clientErrors > 0) {
                        const clientErrorsData = [['URL', 'Method', 'Status', 'Time (ms)']];
                        analysis.statusCodes.clientError.items.forEach(item => {
                            clientErrorsData.push([
                                item.url,
                                item.method,
                                item.status,
                                item.time || 0
                            ]);
                        });
                        const clientErrorsWs = window.XLSX.utils.aoa_to_sheet(clientErrorsData);
                        window.XLSX.utils.book_append_sheet(wb, clientErrorsWs, 'Client Errors');
                    }

                    // Add server errors sheet if any
                    const serverErrors = analysis.statusCodes.serverError.count || 0;
                    if (serverErrors > 0) {
                        const serverErrorsData = [['URL', 'Method', 'Status', 'Time (ms)']];
                        analysis.statusCodes.serverError.items.forEach(item => {
                            serverErrorsData.push([
                                item.url,
                                item.method,
                                item.status,
                                item.time || 0
                            ]);
                        });
                        const serverErrorsWs = window.XLSX.utils.aoa_to_sheet(serverErrorsData);
                        window.XLSX.utils.book_append_sheet(wb, serverErrorsWs, 'Server Errors');
                    }

                    // Add redirects sheet - always include this sheet
                    const redirectsData = [['URL', 'Method', 'Status', 'Time (ms)', 'Redirect Target', 'Redirect Type']];

                    if (analysis.statusCodes.redirect && analysis.statusCodes.redirect.count > 0 && analysis.statusCodes.redirect.items) {
                        analysis.statusCodes.redirect.items.forEach(item => {
                            redirectsData.push([
                                item.url,
                                item.method,
                                item.status,
                                item.time || 0,
                                item.to || '',
                                this.getRedirectTypeDescription(item.status)
                            ]);
                        });
                    } else {
                        // Add an empty row if no redirects found
                        redirectsData.push(['No redirects found', '-', '-', '-', '-', '-']);
                    }

                    const redirectsWs = window.XLSX.utils.aoa_to_sheet(redirectsData);
                    window.XLSX.utils.book_append_sheet(wb, redirectsWs, 'Redirects');

                    // Add slow requests sheet if any
                    if (analysis.slowRequests && analysis.slowRequests.length > 0) {
                        const slowRequestsData = [['URL', 'Method', 'Status', 'Time (ms)']];
                        analysis.slowRequests.forEach(item => {
                            slowRequestsData.push([
                                item.url,
                                item.method || '-',
                                item.status || '-',
                                item.time || 0
                            ]);
                        });
                        const slowRequestsWs = window.XLSX.utils.aoa_to_sheet(slowRequestsData);
                        window.XLSX.utils.book_append_sheet(wb, slowRequestsWs, 'Slow Requests');
                    }

                    // Add whitelist issues sheet if any
                    if (analysis.whitelistIssues && analysis.whitelistIssues.count > 0 && analysis.whitelistIssues.items.length > 0) {
                        const whitelistIssuesData = [['URL', 'Method', 'Status', 'Error Type']];
                        analysis.whitelistIssues.items.forEach(item => {
                            whitelistIssuesData.push([
                                item.url,
                                item.method || 'GET',
                                item.status || '-',
                                item.error || 'Unknown Error'
                            ]);
                        });
                        const whitelistIssuesWs = window.XLSX.utils.aoa_to_sheet(whitelistIssuesData);
                        window.XLSX.utils.book_append_sheet(wb, whitelistIssuesWs, 'Possible Whitelist Issues');
                    }

                    // Generate Excel file
                    const excelBlob = window.XLSX.write(wb, {
                        bookType: 'xlsx',
                        type: 'binary'
                    });

                    // Convert string to ArrayBuffer
                    const buf = new ArrayBuffer(excelBlob.length);
                    const view = new Uint8Array(buf);
                    for (let i = 0; i < excelBlob.length; i++) {
                        view[i] = excelBlob.charCodeAt(i) & 0xFF;
                    }

                    console.log("Excel report generated successfully");

                    // Return the Excel file as a File object
                    return new File(
                        [buf],
                        `HAR_Analysis_Report_${fileName.replace(/\.[^/.]+$/, '')}.xlsx`,
                        { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }
                    );

                } catch (error) {
                    console.error("Error generating Excel report:", error);
                    return null;
                }
            }

            // Helper method to get redirect type description based on status code
            getRedirectTypeDescription(statusCode) {
                switch (statusCode) {
                    case 301:
                        return 'Moved Permanently';
                    case 302:
                        return 'Found (Temporary Redirect)';
                    case 303:
                        return 'See Other';
                    case 304:
                        return 'Not Modified';
                    case 307:
                        return 'Temporary Redirect';
                    case 308:
                        return 'Permanent Redirect';
                    default:
                        return `Redirect (${statusCode})`;
                }
            }

            // ... existing code ...

            // Add save as draft handler
            handleSaveAsDraft() {
                console.log("handleSaveAsDraft called");

                // Show a dialog to get draft name
                const draftName = prompt('Enter a name for your draft:', `Draft - ${new Date().toLocaleDateString()}`);

                if (!draftName || draftName.trim() === '') {
                    return;
                }

                try {
                    // Collect all form data
                    const formData = this.collectFormData();

                    // Check if draftManager is available
                    if (!window.draftManager) {
                        console.warn("Draft manager not available, loading it now");
                        // Try to load it
                        const script = document.createElement('script');
                        script.src = 'tracker-config.js';
                        script.onload = () => {
                            if (window.draftManager) {
                                this.saveDraftWithManager(draftName.trim(), formData);
                            } else {
                                alert('Draft system not available. Please refresh the page and try again.');
                            }
                        };
                        document.head.appendChild(script);
                    } else {
                        this.saveDraftWithManager(draftName.trim(), formData);
                    }
                } catch (error) {
                    console.error('Error saving draft:', error);
                    alert('Failed to save draft. Please try again.');
                }
            }

            // Helper method to save draft using the manager
            saveDraftWithManager(draftName, formData) {
                try {
                    const draftId = window.draftManager.saveDraft(
                        draftName,
                        this.selectedTemplate,
                        formData
                    );

                    // Store current draft ID for auto-save
                    this.currentDraftId = draftId;
                    this.currentDraftName = draftName;

                    alert(`Draft "${draftName}" saved successfully!`);
                    console.log(`Draft saved with ID: ${draftId}`);

                    // Automatically redirect to the template selector page
                    setTimeout(() => {
                        window.location.href = 'template-selector.html';
                    }, 1000); // Small delay to allow the alert to be seen
                } catch (error) {
                    console.error('Error in saveDraftWithManager:', error);
                    alert('Failed to save draft. Please try again.');
                }
            }

            // Method to collect all form data including rich text editors
            collectFormData() {
                const formData = {};

                // Get all form inputs
                const form = document.getElementById('trackerForm');
                if (!form) return formData;

                // Regular form fields
                const inputs = form.querySelectorAll('input, select, textarea');
                inputs.forEach(input => {
                    if (input.type === 'checkbox') {
                        if (input.name && input.name.includes('userRole')) {
                            // Handle checkbox groups
                            if (!formData[input.name]) {
                                formData[input.name] = [];
                            }
                            if (input.checked) {
                                formData[input.name].push(input.value || input.id);
                            }
                        } else {
                            formData[input.id] = input.checked;
                        }
                    } else if (input.type !== 'file') { // Skip file inputs
                        formData[input.id] = input.value;
                    }
                });

                // Collect Quill editor content
                if (this.quillEditors) {
                    Object.keys(this.quillEditors).forEach(fieldId => {
                        const editor = this.quillEditors[fieldId];
                        if (editor && editor.root) {
                            formData[fieldId] = editor.root.innerHTML;
                        }
                    });
                }

                return formData;
            }

            // Method to load draft data when returning from template selector
            loadDraftIfAvailable() {
                try {
                    const loadingDraft = localStorage.getItem('loadingDraft');
                    if (loadingDraft) {
                        const { draftId, formData } = JSON.parse(loadingDraft);
                        console.log(`Loading draft ${draftId}`);

                        this.currentDraftId = draftId;

                        // Populate form with draft data
                        this.populateFormWithDraftData(formData);

                        // Clear the loading draft data
                        localStorage.removeItem('loadingDraft');

                        // Show notification
                        this.showNotification('Draft loaded successfully', 'success');
                    }
                } catch (error) {
                    console.error('Error loading draft:', error);
                    localStorage.removeItem('loadingDraft');
                }
            }

            // Method to populate form with draft data
            populateFormWithDraftData(formData) {
                if (!formData) return;

                // Set a flag to prevent triggering change events during population
                this.isLoadingDraft = true;

                // Populate regular form fields
                Object.keys(formData).forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (!field) return;

                    if (field.type === 'checkbox') {
                        field.checked = formData[fieldId];
                    } else if (field.name && field.name.includes('userRole') && Array.isArray(formData[fieldId])) {
                        // Handle checkbox groups
                        formData[fieldId].forEach(value => {
                            const checkbox = document.getElementById(value) ||
                                document.querySelector(`input[name="${field.name}"][value="${value}"]`);
                            if (checkbox) {
                                checkbox.checked = true;
                            }
                        });
                    } else {
                        field.value = formData[fieldId];

                        // Trigger change event for select fields to update dependent fields
                        if (field.tagName === 'SELECT') {
                            field.dispatchEvent(new Event('change'));
                        }
                    }
                });

                // Immediately update subject line for SEDCUST after field population
                if (this.trackerType === 'sedcust') {
                    console.log('Updating SEDCUST subject line immediately after field population');
                    // Small delay to ensure all fields are set
                    setTimeout(() => {
                        this.updateSedcustSubject();
                    }, 100);
                }

                // Populate Quill editors
                setTimeout(() => {
                    if (this.quillEditors) {
                        Object.keys(this.quillEditors).forEach(fieldId => {
                            const editor = this.quillEditors[fieldId];
                            if (editor && formData[fieldId] && typeof formData[fieldId] === 'string' && formData[fieldId].includes('<')) {
                                editor.root.innerHTML = formData[fieldId];
                            }
                        });
                    }

                    // Clear the loading flag
                    this.isLoadingDraft = false;

                    // Force update the subject line for SEDCUST templates after draft loading
                    if (this.trackerType === 'sedcust') {
                        console.log('Forcing SEDCUST subject line update after draft loading');
                        this.updateSedcustSubject();
                    }

                    // Also update subject lines for other template types
                    if (this.trackerType === 'assembly') {
                        this.updateFormattedSubject();
                    }
                }, 500);

                // Add an additional delayed update to ensure all fields are properly set
                setTimeout(() => {
                    if (this.trackerType === 'sedcust') {
                        console.log('Final SEDCUST subject line update after draft loading');
                        this.updateSedcustSubject();
                    }
                }, 1000);
            }

            // Helper method to show notifications
            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    background-color: ${type === 'success' ? '#4caf50' : '#2196f3'};
                    color: white;
                    border-radius: 4px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                    z-index: 10000;
                    animation: slideIn 0.3s ease-out;
                `;
                notification.textContent = message;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }
        }

        // Add global error handler for network errors
        window.addEventListener('error', function (event) {
            // Check for network errors related to payload size
            if (event && event.target && event.target.tagName === 'SCRIPT' &&
                event.target.src && event.target.src.includes('host-network-events.js')) {

                console.error('Network error detected, checking for 413 status');

                // Use a small timeout to let the actual error log to console
                setTimeout(function () {
                    // Look for recent 413 errors in console
                    if (window.client &&
                        (document.body.innerHTML.includes('413') ||
                            document.documentElement.outerHTML.includes('413 (Payload Too Large)'))) {

                        // Show a professional notification about the error
                        client.interface.trigger("showNotify", {
                            type: "warning",
                            message: "Your form submission exceeds the maximum allowed size. Please reduce the number of pasted screenshots and consider using file attachments instead."
                        }).catch(console.error);
                    }
                }, 100);
            }
        }, true);

        document.addEventListener('DOMContentLoaded', function () {
            // Intercept XMLHttpRequest to detect 413 errors
            const originalXhrSend = XMLHttpRequest.prototype.send;
            XMLHttpRequest.prototype.send = function () {
                this.addEventListener('load', function () {
                    if (this.status === 413) {
                        console.error('413 Payload Too Large error detected');
                        if (window.client) {
                            client.interface.trigger("showNotify", {
                                type: "warning",
                                message: "Your form submission exceeds the maximum allowed size. Please reduce the number of pasted screenshots and consider using file attachments instead."
                            }).catch(console.error);
                        }
                    }
                });

                return originalXhrSend.apply(this, arguments);
            };

            // Also intercept fetch requests
            const originalFetch = window.fetch;
            window.fetch = function () {
                return originalFetch.apply(this, arguments)
                    .then(response => {
                        if (response.status === 413) {
                            console.error('413 Payload Too Large error detected in fetch');
                            if (window.client) {
                                client.interface.trigger("showNotify", {
                                    type: "warning",
                                    message: "Your form submission exceeds the maximum allowed size. Please reduce the number of pasted screenshots and consider using file attachments instead."
                                }).catch(console.error);
                            }
                        }
                        return response;
                    });
            };
        });
    </script>
</body>

</html>